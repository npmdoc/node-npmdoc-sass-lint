<div class="apidocDiv">
<style>
/*csslint
*/
.apidocDiv {
    background: #fff;
    font-family: Arial, Helvetica, sans-serif;
}
.apidocDiv a[href] {
    color: #33f;
    font-weight: bold;
    text-decoration: none;
}
.apidocDiv a[href]:hover {
    text-decoration: underline;
}
.apidocCodeCommentSpan {
    background: #bbf;
    color: #000;
    display: block;
}
.apidocCodeKeywordSpan {
    color: #d00;
    font-weight: bold;
}
.apidocCodePre {
    background: #eef;
    border: 1px solid;
    color: #777;
    padding: 5px;
    white-space: pre-wrap;
}
.apidocFooterDiv {
    margin-top: 20px;
    text-align: center;
}
.apidocModuleLi {
    margin-top: 10px;
}
.apidocSectionDiv {
    border-top: 1px solid;
    margin-top: 20px;
}
.apidocSignatureSpan {
    color: #777;
    font-weight: bold;
}
</style>
<h1>api documentation for
    <a

        href="https://github.com/sasstools/sass-lint"

    >sass-lint (v1.10.2)</a>
</h1>
<h4>All Node Sass linter!</h4>
<div class="apidocSectionDiv"><a
    href="#apidoc.tableOfContents"
    id="apidoc.tableOfContents"
><h1>table of contents</h1></a><ol>

    <li class="apidocModuleLi"><a href="#apidoc.module.sass-lint">module sass-lint</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sass-lint.sass-lint">
            function <span class="apidocSignatureSpan"></span>sass-lint
            <span class="apidocSignatureSpan">(config)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sass-lint.errorCount">
            function <span class="apidocSignatureSpan">sass-lint.</span>errorCount
            <span class="apidocSignatureSpan">(results)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sass-lint.failOnError">
            function <span class="apidocSignatureSpan">sass-lint.</span>failOnError
            <span class="apidocSignatureSpan">(results, options, configPath)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sass-lint.format">
            function <span class="apidocSignatureSpan">sass-lint.</span>format
            <span class="apidocSignatureSpan">(results, options, configPath)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sass-lint.getConfig">
            function <span class="apidocSignatureSpan">sass-lint.</span>getConfig
            <span class="apidocSignatureSpan">(config, configPath)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sass-lint.lintFileText">
            function <span class="apidocSignatureSpan">sass-lint.</span>lintFileText
            <span class="apidocSignatureSpan">(file, options, configPath)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sass-lint.lintFiles">
            function <span class="apidocSignatureSpan">sass-lint.</span>lintFiles
            <span class="apidocSignatureSpan">(files, options, configPath)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sass-lint.lintText">
            function <span class="apidocSignatureSpan">sass-lint.</span>lintText
            <span class="apidocSignatureSpan">(file, options, configPath)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sass-lint.outputResults">
            function <span class="apidocSignatureSpan">sass-lint.</span>outputResults
            <span class="apidocSignatureSpan">(results, options, configPath)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sass-lint.resultCount">
            function <span class="apidocSignatureSpan">sass-lint.</span>resultCount
            <span class="apidocSignatureSpan">(results)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sass-lint.warningCount">
            function <span class="apidocSignatureSpan">sass-lint.</span>warningCount
            <span class="apidocSignatureSpan">(results)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">sass-lint.</span>attribute_quotes</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">sass-lint.</span>bem_depth</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">sass-lint.</span>border_zero</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">sass-lint.</span>brace_style</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">sass-lint.</span>class_name_format</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">sass-lint.</span>clean_import_paths</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">sass-lint.</span>config_helpers</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">sass-lint.</span>declarations_before_nesting</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">sass-lint.</span>empty_args</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">sass-lint.</span>empty_line_between_blocks</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">sass-lint.</span>exceptions</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">sass-lint.</span>extends_before_declarations</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">sass-lint.</span>extends_before_mixins</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">sass-lint.</span>final_newline</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">sass-lint.</span>force_attribute_nesting</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">sass-lint.</span>force_element_nesting</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">sass-lint.</span>force_pseudo_nesting</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">sass-lint.</span>function_name_format</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">sass-lint.</span>helpers</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">sass-lint.</span>hex_length</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">sass-lint.</span>hex_notation</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">sass-lint.</span>id_name_format</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">sass-lint.</span>indentation</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">sass-lint.</span>leading_zero</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">sass-lint.</span>max_file_line_count</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">sass-lint.</span>max_line_length</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">sass-lint.</span>mixin_name_format</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">sass-lint.</span>mixins_before_declarations</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">sass-lint.</span>nesting_depth</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">sass-lint.</span>no_attribute_selectors</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">sass-lint.</span>no_color_hex</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">sass-lint.</span>no_color_keywords</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">sass-lint.</span>no_color_literals</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">sass-lint.</span>no_combinators</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">sass-lint.</span>no_css_comments</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">sass-lint.</span>no_debug</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">sass-lint.</span>no_disallowed_properties</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">sass-lint.</span>no_duplicate_properties</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">sass-lint.</span>no_empty_rulesets</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">sass-lint.</span>no_extends</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">sass-lint.</span>no_ids</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">sass-lint.</span>no_important</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">sass-lint.</span>no_invalid_hex</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">sass-lint.</span>no_mergeable_selectors</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">sass-lint.</span>no_misspelled_properties</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">sass-lint.</span>no_qualifying_elements</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">sass-lint.</span>no_trailing_whitespace</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">sass-lint.</span>no_trailing_zero</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">sass-lint.</span>no_transition_all</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">sass-lint.</span>no_universal_selectors</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">sass-lint.</span>no_url_domains</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">sass-lint.</span>no_url_protocols</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">sass-lint.</span>no_warn</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">sass-lint.</span>one_declaration_per_line</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">sass-lint.</span>placeholder_in_extend</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">sass-lint.</span>placeholder_name_format</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">sass-lint.</span>property_sort_order</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">sass-lint.</span>property_units</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">sass-lint.</span>pseudo_element</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">sass-lint.</span>quotes</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">sass-lint.</span>ruleToggler</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">sass-lint.</span>selector_helpers</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">sass-lint.</span>shorthand_values</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">sass-lint.</span>single_line_per_selector</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">sass-lint.</span>space_after_bang</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">sass-lint.</span>space_after_colon</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">sass-lint.</span>space_after_comma</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">sass-lint.</span>space_around_operator</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">sass-lint.</span>space_before_bang</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">sass-lint.</span>space_before_brace</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">sass-lint.</span>space_before_colon</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">sass-lint.</span>space_between_parens</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">sass-lint.</span>trailing_semicolon</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">sass-lint.</span>url_quotes</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">sass-lint.</span>variable_for_property</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">sass-lint.</span>variable_name_format</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">sass-lint.</span>zero_unit</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.sass-lint.attribute_quotes">module sass-lint.attribute_quotes</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sass-lint.attribute_quotes.detect">
            function <span class="apidocSignatureSpan">sass-lint.attribute_quotes.</span>detect
            <span class="apidocSignatureSpan">(ast, parser)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">sass-lint.attribute_quotes.</span>defaults</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">sass-lint.attribute_quotes.</span>name</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.sass-lint.bem_depth">module sass-lint.bem_depth</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sass-lint.bem_depth.detect">
            function <span class="apidocSignatureSpan">sass-lint.bem_depth.</span>detect
            <span class="apidocSignatureSpan">(ast, parser)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">sass-lint.bem_depth.</span>defaults</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">sass-lint.bem_depth.</span>name</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.sass-lint.border_zero">module sass-lint.border_zero</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sass-lint.border_zero.detect">
            function <span class="apidocSignatureSpan">sass-lint.border_zero.</span>detect
            <span class="apidocSignatureSpan">(ast, parser)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">sass-lint.border_zero.</span>defaults</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">sass-lint.border_zero.</span>name</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.sass-lint.brace_style">module sass-lint.brace_style</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sass-lint.brace_style.detect">
            function <span class="apidocSignatureSpan">sass-lint.brace_style.</span>detect
            <span class="apidocSignatureSpan">(ast, parser)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">sass-lint.brace_style.</span>defaults</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">sass-lint.brace_style.</span>name</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.sass-lint.class_name_format">module sass-lint.class_name_format</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sass-lint.class_name_format.detect">
            function <span class="apidocSignatureSpan">sass-lint.class_name_format.</span>detect
            <span class="apidocSignatureSpan">(ast, parser)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">sass-lint.class_name_format.</span>defaults</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">sass-lint.class_name_format.</span>name</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.sass-lint.clean_import_paths">module sass-lint.clean_import_paths</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sass-lint.clean_import_paths.detect">
            function <span class="apidocSignatureSpan">sass-lint.clean_import_paths.</span>detect
            <span class="apidocSignatureSpan">(ast, parser)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">sass-lint.clean_import_paths.</span>defaults</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">sass-lint.clean_import_paths.</span>name</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.sass-lint.config_helpers">module sass-lint.config_helpers</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sass-lint.config_helpers.checkForConfigExtend">
            function <span class="apidocSignatureSpan">sass-lint.config_helpers.</span>checkForConfigExtend
            <span class="apidocSignatureSpan">(config, curConfPath)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sass-lint.config_helpers.findFile">
            function <span class="apidocSignatureSpan">sass-lint.config_helpers.</span>findFile
            <span class="apidocSignatureSpan">(configPath, filename)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sass-lint.config_helpers.loadConfig">
            function <span class="apidocSignatureSpan">sass-lint.config_helpers.</span>loadConfig
            <span class="apidocSignatureSpan">(cPath)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sass-lint.config_helpers.loadDefaults">
            function <span class="apidocSignatureSpan">sass-lint.config_helpers.</span>loadDefaults
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.sass-lint.declarations_before_nesting">module sass-lint.declarations_before_nesting</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sass-lint.declarations_before_nesting.detect">
            function <span class="apidocSignatureSpan">sass-lint.declarations_before_nesting.</span>detect
            <span class="apidocSignatureSpan">(ast, parser)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">sass-lint.declarations_before_nesting.</span>defaults</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">sass-lint.declarations_before_nesting.</span>name</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.sass-lint.empty_args">module sass-lint.empty_args</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sass-lint.empty_args.detect">
            function <span class="apidocSignatureSpan">sass-lint.empty_args.</span>detect
            <span class="apidocSignatureSpan">(ast, parser)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">sass-lint.empty_args.</span>defaults</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">sass-lint.empty_args.</span>name</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.sass-lint.empty_line_between_blocks">module sass-lint.empty_line_between_blocks</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sass-lint.empty_line_between_blocks.detect">
            function <span class="apidocSignatureSpan">sass-lint.empty_line_between_blocks.</span>detect
            <span class="apidocSignatureSpan">(ast, parser)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">sass-lint.empty_line_between_blocks.</span>defaults</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">sass-lint.empty_line_between_blocks.</span>name</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.sass-lint.exceptions">module sass-lint.exceptions</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sass-lint.exceptions.MaxWarningsExceededError">
            function <span class="apidocSignatureSpan">sass-lint.exceptions.</span>MaxWarningsExceededError
            <span class="apidocSignatureSpan">(message)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sass-lint.exceptions.SassLintFailureError">
            function <span class="apidocSignatureSpan">sass-lint.exceptions.</span>SassLintFailureError
            <span class="apidocSignatureSpan">(message)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.sass-lint.extends_before_declarations">module sass-lint.extends_before_declarations</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sass-lint.extends_before_declarations.detect">
            function <span class="apidocSignatureSpan">sass-lint.extends_before_declarations.</span>detect
            <span class="apidocSignatureSpan">(ast, parser)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">sass-lint.extends_before_declarations.</span>defaults</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">sass-lint.extends_before_declarations.</span>name</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.sass-lint.extends_before_mixins">module sass-lint.extends_before_mixins</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sass-lint.extends_before_mixins.detect">
            function <span class="apidocSignatureSpan">sass-lint.extends_before_mixins.</span>detect
            <span class="apidocSignatureSpan">(ast, parser)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">sass-lint.extends_before_mixins.</span>defaults</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">sass-lint.extends_before_mixins.</span>name</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.sass-lint.final_newline">module sass-lint.final_newline</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sass-lint.final_newline.detect">
            function <span class="apidocSignatureSpan">sass-lint.final_newline.</span>detect
            <span class="apidocSignatureSpan">(ast, parser)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">sass-lint.final_newline.</span>defaults</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">sass-lint.final_newline.</span>name</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.sass-lint.force_attribute_nesting">module sass-lint.force_attribute_nesting</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sass-lint.force_attribute_nesting.detect">
            function <span class="apidocSignatureSpan">sass-lint.force_attribute_nesting.</span>detect
            <span class="apidocSignatureSpan">(ast, parser)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">sass-lint.force_attribute_nesting.</span>defaults</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">sass-lint.force_attribute_nesting.</span>name</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.sass-lint.force_element_nesting">module sass-lint.force_element_nesting</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sass-lint.force_element_nesting.detect">
            function <span class="apidocSignatureSpan">sass-lint.force_element_nesting.</span>detect
            <span class="apidocSignatureSpan">(ast, parser)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">sass-lint.force_element_nesting.</span>defaults</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">sass-lint.force_element_nesting.</span>name</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.sass-lint.force_pseudo_nesting">module sass-lint.force_pseudo_nesting</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sass-lint.force_pseudo_nesting.detect">
            function <span class="apidocSignatureSpan">sass-lint.force_pseudo_nesting.</span>detect
            <span class="apidocSignatureSpan">(ast, parser)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">sass-lint.force_pseudo_nesting.</span>defaults</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">sass-lint.force_pseudo_nesting.</span>name</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.sass-lint.function_name_format">module sass-lint.function_name_format</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sass-lint.function_name_format.detect">
            function <span class="apidocSignatureSpan">sass-lint.function_name_format.</span>detect
            <span class="apidocSignatureSpan">(ast, parser)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">sass-lint.function_name_format.</span>defaults</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">sass-lint.function_name_format.</span>name</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.sass-lint.helpers">module sass-lint.helpers</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sass-lint.helpers.addUnique">
            function <span class="apidocSignatureSpan">sass-lint.helpers.</span>addUnique
            <span class="apidocSignatureSpan">(results, item)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sass-lint.helpers.attemptTraversal">
            function <span class="apidocSignatureSpan">sass-lint.helpers.</span>attemptTraversal
            <span class="apidocSignatureSpan">(node, traversalPath)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sass-lint.helpers.collectSuffixExtensions">
            function <span class="apidocSignatureSpan">sass-lint.helpers.</span>collectSuffixExtensions
            <span class="apidocSignatureSpan">(ruleset, selectorType)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sass-lint.helpers.hasEOL">
            function <span class="apidocSignatureSpan">sass-lint.helpers.</span>hasEOL
            <span class="apidocSignatureSpan">(str)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sass-lint.helpers.isCamelCase">
            function <span class="apidocSignatureSpan">sass-lint.helpers.</span>isCamelCase
            <span class="apidocSignatureSpan">(str)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sass-lint.helpers.isEmptyLine">
            function <span class="apidocSignatureSpan">sass-lint.helpers.</span>isEmptyLine
            <span class="apidocSignatureSpan">(str)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sass-lint.helpers.isEqual">
            function <span class="apidocSignatureSpan">sass-lint.helpers.</span>isEqual
            <span class="apidocSignatureSpan">(a, b)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sass-lint.helpers.isHyphenatedBEM">
            function <span class="apidocSignatureSpan">sass-lint.helpers.</span>isHyphenatedBEM
            <span class="apidocSignatureSpan">(str)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sass-lint.helpers.isHyphenatedLowercase">
            function <span class="apidocSignatureSpan">sass-lint.helpers.</span>isHyphenatedLowercase
            <span class="apidocSignatureSpan">(str)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sass-lint.helpers.isLowerCase">
            function <span class="apidocSignatureSpan">sass-lint.helpers.</span>isLowerCase
            <span class="apidocSignatureSpan">(str)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sass-lint.helpers.isNestable">
            function <span class="apidocSignatureSpan">sass-lint.helpers.</span>isNestable
            <span class="apidocSignatureSpan">(currentVal, previousVal, elements, nestable)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sass-lint.helpers.isNewLine">
            function <span class="apidocSignatureSpan">sass-lint.helpers.</span>isNewLine
            <span class="apidocSignatureSpan">(node)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sass-lint.helpers.isNumber">
            function <span class="apidocSignatureSpan">sass-lint.helpers.</span>isNumber
            <span class="apidocSignatureSpan">(val)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sass-lint.helpers.isPartialStringMatch">
            function <span class="apidocSignatureSpan">sass-lint.helpers.</span>isPartialStringMatch
            <span class="apidocSignatureSpan">(needle, haystack)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sass-lint.helpers.isPascalCase">
            function <span class="apidocSignatureSpan">sass-lint.helpers.</span>isPascalCase
            <span class="apidocSignatureSpan">(str)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sass-lint.helpers.isSnakeCase">
            function <span class="apidocSignatureSpan">sass-lint.helpers.</span>isSnakeCase
            <span class="apidocSignatureSpan">(str)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sass-lint.helpers.isSpace">
            function <span class="apidocSignatureSpan">sass-lint.helpers.</span>isSpace
            <span class="apidocSignatureSpan">(node)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sass-lint.helpers.isStrictBEM">
            function <span class="apidocSignatureSpan">sass-lint.helpers.</span>isStrictBEM
            <span class="apidocSignatureSpan">(str)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sass-lint.helpers.isUnique">
            function <span class="apidocSignatureSpan">sass-lint.helpers.</span>isUnique
            <span class="apidocSignatureSpan">(results, item)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sass-lint.helpers.isUpperCase">
            function <span class="apidocSignatureSpan">sass-lint.helpers.</span>isUpperCase
            <span class="apidocSignatureSpan">(str)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sass-lint.helpers.isValidHex">
            function <span class="apidocSignatureSpan">sass-lint.helpers.</span>isValidHex
            <span class="apidocSignatureSpan">(str)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sass-lint.helpers.loadConfigFile">
            function <span class="apidocSignatureSpan">sass-lint.helpers.</span>loadConfigFile
            <span class="apidocSignatureSpan">(configPath)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sass-lint.helpers.log">
            function <span class="apidocSignatureSpan">sass-lint.helpers.</span>log
            <span class="apidocSignatureSpan">(input)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sass-lint.helpers.propertySearch">
            function <span class="apidocSignatureSpan">sass-lint.helpers.</span>propertySearch
            <span class="apidocSignatureSpan">(haystack, needle, property)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sass-lint.helpers.sortDetects">
            function <span class="apidocSignatureSpan">sass-lint.helpers.</span>sortDetects
            <span class="apidocSignatureSpan">(a, b)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sass-lint.helpers.stripBom">
            function <span class="apidocSignatureSpan">sass-lint.helpers.</span>stripBom
            <span class="apidocSignatureSpan">(str)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sass-lint.helpers.stripLastSpace">
            function <span class="apidocSignatureSpan">sass-lint.helpers.</span>stripLastSpace
            <span class="apidocSignatureSpan">(selector)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sass-lint.helpers.stripPrefix">
            function <span class="apidocSignatureSpan">sass-lint.helpers.</span>stripPrefix
            <span class="apidocSignatureSpan">(str)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sass-lint.helpers.stripQuotes">
            function <span class="apidocSignatureSpan">sass-lint.helpers.</span>stripQuotes
            <span class="apidocSignatureSpan">(str)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.sass-lint.hex_length">module sass-lint.hex_length</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sass-lint.hex_length.detect">
            function <span class="apidocSignatureSpan">sass-lint.hex_length.</span>detect
            <span class="apidocSignatureSpan">(ast, parser)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">sass-lint.hex_length.</span>defaults</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">sass-lint.hex_length.</span>name</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.sass-lint.hex_notation">module sass-lint.hex_notation</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sass-lint.hex_notation.detect">
            function <span class="apidocSignatureSpan">sass-lint.hex_notation.</span>detect
            <span class="apidocSignatureSpan">(ast, parser)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">sass-lint.hex_notation.</span>defaults</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">sass-lint.hex_notation.</span>name</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.sass-lint.id_name_format">module sass-lint.id_name_format</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sass-lint.id_name_format.detect">
            function <span class="apidocSignatureSpan">sass-lint.id_name_format.</span>detect
            <span class="apidocSignatureSpan">(ast, parser)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">sass-lint.id_name_format.</span>defaults</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">sass-lint.id_name_format.</span>name</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.sass-lint.indentation">module sass-lint.indentation</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sass-lint.indentation.detect">
            function <span class="apidocSignatureSpan">sass-lint.indentation.</span>detect
            <span class="apidocSignatureSpan">(ast, parser)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">sass-lint.indentation.</span>defaults</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">sass-lint.indentation.</span>name</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.sass-lint.leading_zero">module sass-lint.leading_zero</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sass-lint.leading_zero.detect">
            function <span class="apidocSignatureSpan">sass-lint.leading_zero.</span>detect
            <span class="apidocSignatureSpan">(ast, parser)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">sass-lint.leading_zero.</span>defaults</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">sass-lint.leading_zero.</span>name</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.sass-lint.max_file_line_count">module sass-lint.max_file_line_count</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sass-lint.max_file_line_count.detect">
            function <span class="apidocSignatureSpan">sass-lint.max_file_line_count.</span>detect
            <span class="apidocSignatureSpan">(ast, parser)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">sass-lint.max_file_line_count.</span>defaults</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">sass-lint.max_file_line_count.</span>name</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.sass-lint.max_line_length">module sass-lint.max_line_length</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sass-lint.max_line_length.detect">
            function <span class="apidocSignatureSpan">sass-lint.max_line_length.</span>detect
            <span class="apidocSignatureSpan">(ast, parser)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">sass-lint.max_line_length.</span>defaults</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">sass-lint.max_line_length.</span>name</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.sass-lint.mixin_name_format">module sass-lint.mixin_name_format</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sass-lint.mixin_name_format.detect">
            function <span class="apidocSignatureSpan">sass-lint.mixin_name_format.</span>detect
            <span class="apidocSignatureSpan">(ast, parser)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">sass-lint.mixin_name_format.</span>defaults</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">sass-lint.mixin_name_format.</span>name</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.sass-lint.mixins_before_declarations">module sass-lint.mixins_before_declarations</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sass-lint.mixins_before_declarations.detect">
            function <span class="apidocSignatureSpan">sass-lint.mixins_before_declarations.</span>detect
            <span class="apidocSignatureSpan">(ast, parser)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">sass-lint.mixins_before_declarations.</span>defaults</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">sass-lint.mixins_before_declarations.</span>name</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.sass-lint.nesting_depth">module sass-lint.nesting_depth</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sass-lint.nesting_depth.detect">
            function <span class="apidocSignatureSpan">sass-lint.nesting_depth.</span>detect
            <span class="apidocSignatureSpan">(ast, parser)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">sass-lint.nesting_depth.</span>defaults</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">sass-lint.nesting_depth.</span>name</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.sass-lint.no_attribute_selectors">module sass-lint.no_attribute_selectors</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sass-lint.no_attribute_selectors.detect">
            function <span class="apidocSignatureSpan">sass-lint.no_attribute_selectors.</span>detect
            <span class="apidocSignatureSpan">(ast, parser)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">sass-lint.no_attribute_selectors.</span>defaults</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">sass-lint.no_attribute_selectors.</span>name</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.sass-lint.no_color_hex">module sass-lint.no_color_hex</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sass-lint.no_color_hex.detect">
            function <span class="apidocSignatureSpan">sass-lint.no_color_hex.</span>detect
            <span class="apidocSignatureSpan">(ast, parser)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">sass-lint.no_color_hex.</span>defaults</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">sass-lint.no_color_hex.</span>name</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.sass-lint.no_color_keywords">module sass-lint.no_color_keywords</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sass-lint.no_color_keywords.detect">
            function <span class="apidocSignatureSpan">sass-lint.no_color_keywords.</span>detect
            <span class="apidocSignatureSpan">(ast, parser)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">sass-lint.no_color_keywords.</span>defaults</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">sass-lint.no_color_keywords.</span>name</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.sass-lint.no_color_literals">module sass-lint.no_color_literals</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sass-lint.no_color_literals.detect">
            function <span class="apidocSignatureSpan">sass-lint.no_color_literals.</span>detect
            <span class="apidocSignatureSpan">(ast, parser)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">sass-lint.no_color_literals.</span>defaults</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">sass-lint.no_color_literals.</span>name</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.sass-lint.no_combinators">module sass-lint.no_combinators</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sass-lint.no_combinators.detect">
            function <span class="apidocSignatureSpan">sass-lint.no_combinators.</span>detect
            <span class="apidocSignatureSpan">(ast, parser)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">sass-lint.no_combinators.</span>defaults</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">sass-lint.no_combinators.</span>name</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.sass-lint.no_css_comments">module sass-lint.no_css_comments</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sass-lint.no_css_comments.detect">
            function <span class="apidocSignatureSpan">sass-lint.no_css_comments.</span>detect
            <span class="apidocSignatureSpan">(ast, parser)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">sass-lint.no_css_comments.</span>defaults</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">sass-lint.no_css_comments.</span>name</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.sass-lint.no_debug">module sass-lint.no_debug</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sass-lint.no_debug.detect">
            function <span class="apidocSignatureSpan">sass-lint.no_debug.</span>detect
            <span class="apidocSignatureSpan">(ast, parser)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">sass-lint.no_debug.</span>defaults</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">sass-lint.no_debug.</span>name</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.sass-lint.no_disallowed_properties">module sass-lint.no_disallowed_properties</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sass-lint.no_disallowed_properties.detect">
            function <span class="apidocSignatureSpan">sass-lint.no_disallowed_properties.</span>detect
            <span class="apidocSignatureSpan">(ast, parser)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">sass-lint.no_disallowed_properties.</span>defaults</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">sass-lint.no_disallowed_properties.</span>name</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.sass-lint.no_duplicate_properties">module sass-lint.no_duplicate_properties</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sass-lint.no_duplicate_properties.detect">
            function <span class="apidocSignatureSpan">sass-lint.no_duplicate_properties.</span>detect
            <span class="apidocSignatureSpan">(ast, parser)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">sass-lint.no_duplicate_properties.</span>defaults</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">sass-lint.no_duplicate_properties.</span>name</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.sass-lint.no_empty_rulesets">module sass-lint.no_empty_rulesets</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sass-lint.no_empty_rulesets.detect">
            function <span class="apidocSignatureSpan">sass-lint.no_empty_rulesets.</span>detect
            <span class="apidocSignatureSpan">(ast, parser)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">sass-lint.no_empty_rulesets.</span>defaults</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">sass-lint.no_empty_rulesets.</span>name</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.sass-lint.no_extends">module sass-lint.no_extends</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sass-lint.no_extends.detect">
            function <span class="apidocSignatureSpan">sass-lint.no_extends.</span>detect
            <span class="apidocSignatureSpan">(ast, parser)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">sass-lint.no_extends.</span>defaults</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">sass-lint.no_extends.</span>name</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.sass-lint.no_ids">module sass-lint.no_ids</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sass-lint.no_ids.detect">
            function <span class="apidocSignatureSpan">sass-lint.no_ids.</span>detect
            <span class="apidocSignatureSpan">(ast, parser)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">sass-lint.no_ids.</span>defaults</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">sass-lint.no_ids.</span>name</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.sass-lint.no_important">module sass-lint.no_important</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sass-lint.no_important.detect">
            function <span class="apidocSignatureSpan">sass-lint.no_important.</span>detect
            <span class="apidocSignatureSpan">(ast, parser)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">sass-lint.no_important.</span>defaults</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">sass-lint.no_important.</span>name</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.sass-lint.no_invalid_hex">module sass-lint.no_invalid_hex</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sass-lint.no_invalid_hex.detect">
            function <span class="apidocSignatureSpan">sass-lint.no_invalid_hex.</span>detect
            <span class="apidocSignatureSpan">(ast, parser)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">sass-lint.no_invalid_hex.</span>defaults</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">sass-lint.no_invalid_hex.</span>name</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.sass-lint.no_mergeable_selectors">module sass-lint.no_mergeable_selectors</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sass-lint.no_mergeable_selectors.detect">
            function <span class="apidocSignatureSpan">sass-lint.no_mergeable_selectors.</span>detect
            <span class="apidocSignatureSpan">(ast, parser)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">sass-lint.no_mergeable_selectors.</span>defaults</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">sass-lint.no_mergeable_selectors.</span>name</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.sass-lint.no_misspelled_properties">module sass-lint.no_misspelled_properties</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sass-lint.no_misspelled_properties.detect">
            function <span class="apidocSignatureSpan">sass-lint.no_misspelled_properties.</span>detect
            <span class="apidocSignatureSpan">(ast, parser)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">sass-lint.no_misspelled_properties.</span>defaults</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">sass-lint.no_misspelled_properties.</span>name</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.sass-lint.no_qualifying_elements">module sass-lint.no_qualifying_elements</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sass-lint.no_qualifying_elements.detect">
            function <span class="apidocSignatureSpan">sass-lint.no_qualifying_elements.</span>detect
            <span class="apidocSignatureSpan">(ast, parser)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">sass-lint.no_qualifying_elements.</span>defaults</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">sass-lint.no_qualifying_elements.</span>name</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.sass-lint.no_trailing_whitespace">module sass-lint.no_trailing_whitespace</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sass-lint.no_trailing_whitespace.detect">
            function <span class="apidocSignatureSpan">sass-lint.no_trailing_whitespace.</span>detect
            <span class="apidocSignatureSpan">(ast, parser)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">sass-lint.no_trailing_whitespace.</span>defaults</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">sass-lint.no_trailing_whitespace.</span>name</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.sass-lint.no_trailing_zero">module sass-lint.no_trailing_zero</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sass-lint.no_trailing_zero.detect">
            function <span class="apidocSignatureSpan">sass-lint.no_trailing_zero.</span>detect
            <span class="apidocSignatureSpan">(ast, parser)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">sass-lint.no_trailing_zero.</span>defaults</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">sass-lint.no_trailing_zero.</span>name</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.sass-lint.no_transition_all">module sass-lint.no_transition_all</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sass-lint.no_transition_all.detect">
            function <span class="apidocSignatureSpan">sass-lint.no_transition_all.</span>detect
            <span class="apidocSignatureSpan">(ast, parser)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">sass-lint.no_transition_all.</span>defaults</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">sass-lint.no_transition_all.</span>name</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.sass-lint.no_universal_selectors">module sass-lint.no_universal_selectors</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sass-lint.no_universal_selectors.detect">
            function <span class="apidocSignatureSpan">sass-lint.no_universal_selectors.</span>detect
            <span class="apidocSignatureSpan">(ast, parser)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">sass-lint.no_universal_selectors.</span>defaults</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">sass-lint.no_universal_selectors.</span>name</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.sass-lint.no_url_domains">module sass-lint.no_url_domains</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sass-lint.no_url_domains.detect">
            function <span class="apidocSignatureSpan">sass-lint.no_url_domains.</span>detect
            <span class="apidocSignatureSpan">(ast, parser)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">sass-lint.no_url_domains.</span>defaults</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">sass-lint.no_url_domains.</span>name</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.sass-lint.no_url_protocols">module sass-lint.no_url_protocols</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sass-lint.no_url_protocols.detect">
            function <span class="apidocSignatureSpan">sass-lint.no_url_protocols.</span>detect
            <span class="apidocSignatureSpan">(ast, parser)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">sass-lint.no_url_protocols.</span>defaults</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">sass-lint.no_url_protocols.</span>name</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.sass-lint.no_warn">module sass-lint.no_warn</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sass-lint.no_warn.detect">
            function <span class="apidocSignatureSpan">sass-lint.no_warn.</span>detect
            <span class="apidocSignatureSpan">(ast, parser)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">sass-lint.no_warn.</span>defaults</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">sass-lint.no_warn.</span>name</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.sass-lint.one_declaration_per_line">module sass-lint.one_declaration_per_line</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sass-lint.one_declaration_per_line.detect">
            function <span class="apidocSignatureSpan">sass-lint.one_declaration_per_line.</span>detect
            <span class="apidocSignatureSpan">(ast, parser)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">sass-lint.one_declaration_per_line.</span>defaults</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">sass-lint.one_declaration_per_line.</span>name</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.sass-lint.placeholder_in_extend">module sass-lint.placeholder_in_extend</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sass-lint.placeholder_in_extend.detect">
            function <span class="apidocSignatureSpan">sass-lint.placeholder_in_extend.</span>detect
            <span class="apidocSignatureSpan">(ast, parser)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">sass-lint.placeholder_in_extend.</span>defaults</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">sass-lint.placeholder_in_extend.</span>name</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.sass-lint.placeholder_name_format">module sass-lint.placeholder_name_format</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sass-lint.placeholder_name_format.detect">
            function <span class="apidocSignatureSpan">sass-lint.placeholder_name_format.</span>detect
            <span class="apidocSignatureSpan">(ast, parser)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">sass-lint.placeholder_name_format.</span>defaults</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">sass-lint.placeholder_name_format.</span>name</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.sass-lint.property_sort_order">module sass-lint.property_sort_order</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sass-lint.property_sort_order.detect">
            function <span class="apidocSignatureSpan">sass-lint.property_sort_order.</span>detect
            <span class="apidocSignatureSpan">(ast, parser)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">sass-lint.property_sort_order.</span>defaults</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">sass-lint.property_sort_order.</span>name</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.sass-lint.property_units">module sass-lint.property_units</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sass-lint.property_units.detect">
            function <span class="apidocSignatureSpan">sass-lint.property_units.</span>detect
            <span class="apidocSignatureSpan">(ast, parser)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">sass-lint.property_units.</span>defaults</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">sass-lint.property_units.</span>name</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.sass-lint.pseudo_element">module sass-lint.pseudo_element</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sass-lint.pseudo_element.detect">
            function <span class="apidocSignatureSpan">sass-lint.pseudo_element.</span>detect
            <span class="apidocSignatureSpan">(ast, parser)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">sass-lint.pseudo_element.</span>name</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.sass-lint.quotes">module sass-lint.quotes</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sass-lint.quotes.detect">
            function <span class="apidocSignatureSpan">sass-lint.quotes.</span>detect
            <span class="apidocSignatureSpan">(ast, parser)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">sass-lint.quotes.</span>defaults</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">sass-lint.quotes.</span>name</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.sass-lint.ruleToggler">module sass-lint.ruleToggler</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sass-lint.ruleToggler.getToggledRules">
            function <span class="apidocSignatureSpan">sass-lint.ruleToggler.</span>getToggledRules
            <span class="apidocSignatureSpan">(ast)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sass-lint.ruleToggler.isResultEnabled">
            function <span class="apidocSignatureSpan">sass-lint.ruleToggler.</span>isResultEnabled
            <span class="apidocSignatureSpan">(toggledRules)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.sass-lint.selector_helpers">module sass-lint.selector_helpers</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sass-lint.selector_helpers.constructSelector">
            function <span class="apidocSignatureSpan">sass-lint.selector_helpers.</span>constructSelector
            <span class="apidocSignatureSpan">(val)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.sass-lint.shorthand_values">module sass-lint.shorthand_values</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sass-lint.shorthand_values.detect">
            function <span class="apidocSignatureSpan">sass-lint.shorthand_values.</span>detect
            <span class="apidocSignatureSpan">(ast, parser)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">sass-lint.shorthand_values.</span>defaults</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">sass-lint.shorthand_values.</span>name</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.sass-lint.single_line_per_selector">module sass-lint.single_line_per_selector</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sass-lint.single_line_per_selector.detect">
            function <span class="apidocSignatureSpan">sass-lint.single_line_per_selector.</span>detect
            <span class="apidocSignatureSpan">(ast, parser)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">sass-lint.single_line_per_selector.</span>defaults</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">sass-lint.single_line_per_selector.</span>name</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.sass-lint.space_after_bang">module sass-lint.space_after_bang</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sass-lint.space_after_bang.detect">
            function <span class="apidocSignatureSpan">sass-lint.space_after_bang.</span>detect
            <span class="apidocSignatureSpan">(ast, parser)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">sass-lint.space_after_bang.</span>defaults</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">sass-lint.space_after_bang.</span>name</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.sass-lint.space_after_colon">module sass-lint.space_after_colon</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sass-lint.space_after_colon.detect">
            function <span class="apidocSignatureSpan">sass-lint.space_after_colon.</span>detect
            <span class="apidocSignatureSpan">(ast, parser)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">sass-lint.space_after_colon.</span>defaults</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">sass-lint.space_after_colon.</span>name</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.sass-lint.space_after_comma">module sass-lint.space_after_comma</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sass-lint.space_after_comma.detect">
            function <span class="apidocSignatureSpan">sass-lint.space_after_comma.</span>detect
            <span class="apidocSignatureSpan">(ast, parser)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">sass-lint.space_after_comma.</span>defaults</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">sass-lint.space_after_comma.</span>name</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.sass-lint.space_around_operator">module sass-lint.space_around_operator</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sass-lint.space_around_operator.detect">
            function <span class="apidocSignatureSpan">sass-lint.space_around_operator.</span>detect
            <span class="apidocSignatureSpan">(ast, parser)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">sass-lint.space_around_operator.</span>defaults</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">sass-lint.space_around_operator.</span>name</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.sass-lint.space_before_bang">module sass-lint.space_before_bang</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sass-lint.space_before_bang.detect">
            function <span class="apidocSignatureSpan">sass-lint.space_before_bang.</span>detect
            <span class="apidocSignatureSpan">(ast, parser)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">sass-lint.space_before_bang.</span>defaults</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">sass-lint.space_before_bang.</span>name</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.sass-lint.space_before_brace">module sass-lint.space_before_brace</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sass-lint.space_before_brace.detect">
            function <span class="apidocSignatureSpan">sass-lint.space_before_brace.</span>detect
            <span class="apidocSignatureSpan">(ast, parser)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">sass-lint.space_before_brace.</span>defaults</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">sass-lint.space_before_brace.</span>name</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.sass-lint.space_before_colon">module sass-lint.space_before_colon</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sass-lint.space_before_colon.detect">
            function <span class="apidocSignatureSpan">sass-lint.space_before_colon.</span>detect
            <span class="apidocSignatureSpan">(ast, parser)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">sass-lint.space_before_colon.</span>defaults</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">sass-lint.space_before_colon.</span>name</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.sass-lint.space_between_parens">module sass-lint.space_between_parens</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sass-lint.space_between_parens.detect">
            function <span class="apidocSignatureSpan">sass-lint.space_between_parens.</span>detect
            <span class="apidocSignatureSpan">(ast, parser)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">sass-lint.space_between_parens.</span>defaults</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">sass-lint.space_between_parens.</span>name</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.sass-lint.trailing_semicolon">module sass-lint.trailing_semicolon</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sass-lint.trailing_semicolon.detect">
            function <span class="apidocSignatureSpan">sass-lint.trailing_semicolon.</span>detect
            <span class="apidocSignatureSpan">(ast, parser)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">sass-lint.trailing_semicolon.</span>defaults</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">sass-lint.trailing_semicolon.</span>name</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.sass-lint.url_quotes">module sass-lint.url_quotes</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sass-lint.url_quotes.detect">
            function <span class="apidocSignatureSpan">sass-lint.url_quotes.</span>detect
            <span class="apidocSignatureSpan">(ast, parser)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">sass-lint.url_quotes.</span>defaults</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">sass-lint.url_quotes.</span>name</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.sass-lint.variable_for_property">module sass-lint.variable_for_property</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sass-lint.variable_for_property.detect">
            function <span class="apidocSignatureSpan">sass-lint.variable_for_property.</span>detect
            <span class="apidocSignatureSpan">(ast, parser)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">sass-lint.variable_for_property.</span>defaults</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">sass-lint.variable_for_property.</span>name</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.sass-lint.variable_name_format">module sass-lint.variable_name_format</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sass-lint.variable_name_format.detect">
            function <span class="apidocSignatureSpan">sass-lint.variable_name_format.</span>detect
            <span class="apidocSignatureSpan">(ast, parser)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">sass-lint.variable_name_format.</span>defaults</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">sass-lint.variable_name_format.</span>name</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.sass-lint.zero_unit">module sass-lint.zero_unit</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sass-lint.zero_unit.detect">
            function <span class="apidocSignatureSpan">sass-lint.zero_unit.</span>detect
            <span class="apidocSignatureSpan">(ast, parser)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">sass-lint.zero_unit.</span>defaults</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">sass-lint.zero_unit.</span>name</span>

        </li>

    </ol></li>

</ol></div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.sass-lint" id="apidoc.module.sass-lint">module sass-lint</a></h1>


    <h2>
        <a href="#apidoc.element.sass-lint.sass-lint" id="apidoc.element.sass-lint.sass-lint">
        function <span class="apidocSignatureSpan"></span>sass-lint
        <span class="apidocSignatureSpan">(config)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">sass-lint = function (config) { // eslint-disable-line no-unused-vars
  config = require(&#x27;./lib/config&#x27;)(config);
  return;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.sass-lint.errorCount" id="apidoc.element.sass-lint.errorCount">
        function <span class="apidocSignatureSpan">sass-lint.</span>errorCount
        <span class="apidocSignatureSpan">(results)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">errorCount = function (results) {
  var errors = {
    count: 0,
    files: []
  };

  results.forEach(function (result) {
    if (result.errorCount) {
      errors.count += result.errorCount;
      errors.files.push(result.filePath);
    }
  });

  return errors;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* a cumulative count of both
*
* @param {object} results our results object
* @returns {int} the cumulative count of errors and warnings detected
*/
sassLint.resultCount = function (results) {
 var warnings = this.warningCount(results),
     errors = this.<span class="apidocCodeKeywordSpan">errorCount</span>(results);

 return warnings.count + errors.count;
};

/**
* Runs each rule against our AST tree and returns our main object of detected
* errors, warnings, messages and filenames.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.sass-lint.failOnError" id="apidoc.element.sass-lint.failOnError">
        function <span class="apidocSignatureSpan">sass-lint.</span>failOnError
        <span class="apidocSignatureSpan">(results, options, configPath)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">failOnError = function (results, options, configPath) {
  // Default parameters
  options = typeof options !== &#x27;undefined&#x27; ? options : {};
  configPath = typeof configPath !== &#x27;undefined&#x27; ? configPath : null;

  var errorCount = this.errorCount(results),
      warningCount = this.warningCount(results),
      configOptions = this.getConfig(options, configPath).options;

  if (errorCount.count &#x3e; 0) {
    throw new exceptions.SassLintFailureError(errorCount.count + &#x27; errors were detected in \n- &#x27; + errorCount.files.join(&#x27;\n- &#x27;));
  }

  if (!isNaN(configOptions[&#x27;max-warnings&#x27;]) &#x26;&#x26; warningCount.count &#x3e; configOptions[&#x27;max-warnings&#x27;]) {
    throw new exceptions.MaxWarningsExceededError(
      &#x27;Number of warnings (&#x27; + warningCount.count +
      &#x27;) exceeds the allowed maximum of &#x27; + configOptions[&#x27;max-warnings&#x27;] +
      &#x27;.\n&#x27;
    );
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
}

if (lint.errorCount(detects).count || tooManyWarnings(detects, userConfig)) {
  exitCode = 1;
}

if (program.exit) {
  lint.<span class="apidocCodeKeywordSpan">failOnError</span>(detects, configOptions, configPath);
}
};

program
.version(meta.version)
.usage(&#x27;[options] &#x3c;pattern&#x3e;&#x27;)
.option(&#x27;-c, --config [path]&#x27;, &#x27;path to custom config file&#x27;)
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.sass-lint.format" id="apidoc.element.sass-lint.format">
        function <span class="apidocSignatureSpan">sass-lint.</span>format
        <span class="apidocSignatureSpan">(results, options, configPath)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">format = function (results, options, configPath) {
  var config = this.getConfig(options, configPath),
      format = config.options.formatter.toLowerCase();

  var formatted = require(&#x27;eslint/lib/formatters/&#x27; + format);

  return formatted(results);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * @returns {object} results our results object
 */
sassLint.outputResults = function (results, options, configPath) {
  var config = this.getConfig(options, configPath);

  if (this.resultCount(results)) {

var formatted = this.<span class="apidocCodeKeywordSpan">format</span>(results, options, configPath);

if (config.options[&#x27;output-file&#x27;]) {
  try {
    fs.outputFileSync(path.resolve(process.cwd(), config.options[&#x27;output-file&#x27;]), formatted);
    console.log(&#x27;Output successfully written to &#x27; + path.resolve(process.cwd(), config.options[&#x27;output-file&#x27;]));
  }
  catch (e) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.sass-lint.getConfig" id="apidoc.element.sass-lint.getConfig">
        function <span class="apidocSignatureSpan">sass-lint.</span>getConfig
        <span class="apidocSignatureSpan">(config, configPath)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getConfig = function (config, configPath) {
  return slConfig(config, configPath);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 *
 * @param {object} file file object from fs.readFileSync
 * @param {object} options user specified rules/options passed in
 * @param {string} configPath path to a config file
 * @returns {object} an object containing error &#x26; warning counts plus lint messages for each parsed file
 */
sassLint.lintText = function (file, options, configPath) {
var rules = slRules(this.<span class="apidocCodeKeywordSpan">getConfig</span>(options, configPath)),
    ast = {},
    detects,
    results = [],
    errors = 0,
    warnings = 0,
    ruleToggles = null,
    isEnabledFilter = null;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.sass-lint.lintFileText" id="apidoc.element.sass-lint.lintFileText">
        function <span class="apidocSignatureSpan">sass-lint.</span>lintFileText
        <span class="apidocSignatureSpan">(file, options, configPath)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">lintFileText = function (file, options, configPath) {
  var config = this.getConfig(options, configPath),
      ignores = config.files ? config.files.ignore : [];

  if (!globule.isMatch(ignores, file.filename)) {
    return this.lintText(file, options, configPath);
  }

  return {
    &#x27;filePath&#x27;: file.filename,
    &#x27;warningCount&#x27;: 0,
    &#x27;errorCount&#x27;: 0,
    &#x27;messages&#x27;: []
  };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.sass-lint.lintFiles" id="apidoc.element.sass-lint.lintFiles">
        function <span class="apidocSignatureSpan">sass-lint.</span>lintFiles
        <span class="apidocSignatureSpan">(files, options, configPath)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">lintFiles = function (files, options, configPath) {
  var that = this,
      results = [],
      includes = [],
      ignores = &#x27;&#x27;;

  // Files passed as a string on the command line
  if (files) {
    ignores = this.getConfig(options, configPath).files.ignore || &#x27;&#x27;;
    if (files.indexOf(&#x27;, &#x27;) !== -1) {
      files.split(&#x27;, &#x27;).forEach(function (pattern) {
        includes = includes.concat(glob.sync(pattern, {ignore: ignores, nodir: true}));
      });
    }
    else {
      includes = glob.sync(files, {ignore: ignores, nodir: true});
    }
  }
  // If not passed in then we look in the config file
  else {
    files = this.getConfig(options, configPath).files;
    // A glob pattern of files can be just a string
    if (typeof files === &#x27;string&#x27;) {
      includes = glob.sync(files, {nodir: true});
    }
    // Look into the include property of files and check if there&#x27;s an array of files
    else if (files.include &#x26;&#x26; files.include instanceof Array) {
      files.include.forEach(function (pattern) {
        includes = includes.concat(glob.sync(pattern, {ignore: files.ignore, nodir: true}));
      });
    }
    // Or there is only one pattern in the include property of files
    else {
      includes = glob.sync(files.include, {ignore: files.ignore, nodir: true});
    }
  }

  includes.forEach(function (file, index) {
    // Only lint non duplicate files from our glob results
    if (includes.indexOf(file) === index) {
      var lint = that.lintText({
        &#x27;text&#x27;: fs.readFileSync(file),
        &#x27;format&#x27;: options.syntax ? options.syntax : path.extname(file).replace(&#x27;.&#x27;, &#x27;&#x27;),
        &#x27;filename&#x27;: file
      }, options, configPath);
      results.push(lint);
    }
  });

  return results;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var tooManyWarnings = function (detects, userConfig) {
var warningCount = lint.warningCount(detects).count;

return warningCount &#x3e; 0 &#x26;&#x26; warningCount &#x3e; userConfig.options[&#x27;max-warnings&#x27;];
};

var detectPattern = function (pattern, userConfig) {
var detects = lint.<span class="apidocCodeKeywordSpan">lintFiles</span>(pattern, configOptions, configPath);

if (program.verbose) {
  lint.outputResults(detects, configOptions, configPath);
}

if (lint.errorCount(detects).count || tooManyWarnings(detects, userConfig)) {
  exitCode = 1;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.sass-lint.lintText" id="apidoc.element.sass-lint.lintText">
        function <span class="apidocSignatureSpan">sass-lint.</span>lintText
        <span class="apidocSignatureSpan">(file, options, configPath)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">lintText = function (file, options, configPath) {
  var rules = slRules(this.getConfig(options, configPath)),
      ast = {},
      detects,
      results = [],
      errors = 0,
      warnings = 0,
      ruleToggles = null,
      isEnabledFilter = null;

  try {
    ast = groot(file.text, file.format, file.filename);
  }
  catch (e) {
    var line = e.line || 1;
    errors++;

    results = [{
      ruleId: &#x27;Fatal&#x27;,
      line: line,
      column: 1,
      message: e.message,
      severity: 2
    }];
  }

  if (ast.content &#x26;&#x26; ast.content.length &#x3e; 0) {
    ruleToggles = getToggledRules(ast);
    isEnabledFilter = isResultEnabled(ruleToggles);

    rules.forEach(function (rule) {
      detects = rule.rule.detect(ast, rule)
        .filter(isEnabledFilter);
      results = results.concat(detects);
      if (detects.length) {
        if (rule.severity === 1) {
          warnings += detects.length;
        }
        else if (rule.severity === 2) {
          errors += detects.length;
        }
      }
    });
  }

  results.sort(helpers.sortDetects);

  return {
    &#x27;filePath&#x27;: file.filename,
    &#x27;warningCount&#x27;: warnings,
    &#x27;errorCount&#x27;: errors,
    &#x27;messages&#x27;: results
  };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * @returns {object} Return the results of lintText - a results object
 */
sassLint.lintFileText = function (file, options, configPath) {
var config = this.getConfig(options, configPath),
    ignores = config.files ? config.files.ignore : [];

if (!globule.isMatch(ignores, file.filename)) {
  return this.<span class="apidocCodeKeywordSpan">lintText</span>(file, options, configPath);
}

return {
  &#x27;filePath&#x27;: file.filename,
  &#x27;warningCount&#x27;: 0,
  &#x27;errorCount&#x27;: 0,
  &#x27;messages&#x27;: []
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.sass-lint.outputResults" id="apidoc.element.sass-lint.outputResults">
        function <span class="apidocSignatureSpan">sass-lint.</span>outputResults
        <span class="apidocSignatureSpan">(results, options, configPath)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">outputResults = function (results, options, configPath) {
  var config = this.getConfig(options, configPath);

  if (this.resultCount(results)) {

    var formatted = this.format(results, options, configPath);

    if (config.options[&#x27;output-file&#x27;]) {
      try {
        fs.outputFileSync(path.resolve(process.cwd(), config.options[&#x27;output-file&#x27;]), formatted);
        console.log(&#x27;Output successfully written to &#x27; + path.resolve(process.cwd(), config.options[&#x27;output-file&#x27;]));
      }
      catch (e) {
        console.log(&#x27;Error: Output was unable to be written to &#x27; + path.resolve(process.cwd(), config.options[&#x27;output-file&#x27;]));
      }
    }
    else {
      console.log(formatted);
    }
  }
  return results;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
return warningCount &#x3e; 0 &#x26;&#x26; warningCount &#x3e; userConfig.options[&#x27;max-warnings&#x27;];
};

var detectPattern = function (pattern, userConfig) {
var detects = lint.lintFiles(pattern, configOptions, configPath);

if (program.verbose) {
  lint.<span class="apidocCodeKeywordSpan">outputResults</span>(detects, configOptions, configPath);
}

if (lint.errorCount(detects).count || tooManyWarnings(detects, userConfig)) {
  exitCode = 1;
}

if (program.exit) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.sass-lint.resultCount" id="apidoc.element.sass-lint.resultCount">
        function <span class="apidocSignatureSpan">sass-lint.</span>resultCount
        <span class="apidocSignatureSpan">(results)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">resultCount = function (results) {
  var warnings = this.warningCount(results),
      errors = this.errorCount(results);

  return warnings.count + errors.count;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * @param {object} options user specified rules/options passed in
 * @param {string} configPath path to a config file
 * @returns {object} results our results object
 */
sassLint.outputResults = function (results, options, configPath) {
  var config = this.getConfig(options, configPath);

  if (this.<span class="apidocCodeKeywordSpan">resultCount</span>(results)) {

var formatted = this.format(results, options, configPath);

if (config.options[&#x27;output-file&#x27;]) {
  try {
    fs.outputFileSync(path.resolve(process.cwd(), config.options[&#x27;output-file&#x27;]), formatted);
    console.log(&#x27;Output successfully written to &#x27; + path.resolve(process.cwd(), config.options[&#x27;output-file&#x27;]));
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.sass-lint.warningCount" id="apidoc.element.sass-lint.warningCount">
        function <span class="apidocSignatureSpan">sass-lint.</span>warningCount
        <span class="apidocSignatureSpan">(results)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">warningCount = function (results) {
  var warnings = {
    count: 0,
    files: []
  };

  results.forEach(function (result) {
    if (result.warningCount) {
      warnings.count += result.warningCount;
      warnings.files.push(result.filePath);
    }
  });

  return warnings;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* Parses our results object to count warnings and errors and return
* a cumulative count of both
*
* @param {object} results our results object
* @returns {int} the cumulative count of errors and warnings detected
*/
sassLint.resultCount = function (results) {
 var warnings = this.<span class="apidocCodeKeywordSpan">warningCount</span>(results),
     errors = this.errorCount(results);

 return warnings.count + errors.count;
};

/**
* Runs each rule against our AST tree and returns our main object of detected
...</pre></li>
    </ul>




























































































































































</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.sass-lint.attribute_quotes" id="apidoc.module.sass-lint.attribute_quotes">module sass-lint.attribute_quotes</a></h1>


    <h2>
        <a href="#apidoc.element.sass-lint.attribute_quotes.detect" id="apidoc.element.sass-lint.attribute_quotes.detect">
        function <span class="apidocSignatureSpan">sass-lint.attribute_quotes.</span>detect
        <span class="apidocSignatureSpan">(ast, parser)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">detect = function (ast, parser) {
  var result = [];

  ast.traverseByType(&#x27;attributeValue&#x27;, function (item) {
    if (item.content[0].is(&#x27;string&#x27;) &#x26;&#x26; !parser.options.include) {
      result = helpers.addUnique(result, {
        &#x27;ruleId&#x27;: parser.rule.name,
        &#x27;line&#x27;: item.start.line,
        &#x27;column&#x27;: item.start.column,
        &#x27;message&#x27;: &#x27;Attribute values should not be surrounded by quotes&#x27;,
        &#x27;severity&#x27;: parser.severity
      });
    }
    else if (item.content[0].is(&#x27;ident&#x27;) &#x26;&#x26; parser.options.include) {
      result = helpers.addUnique(result, {
        &#x27;ruleId&#x27;: parser.rule.name,
        &#x27;line&#x27;: item.start.line,
        &#x27;column&#x27;: item.start.column,
        &#x27;message&#x27;: &#x27;Attribute values should be surrounded by quotes&#x27;,
        &#x27;severity&#x27;: parser.severity
      });
    }
  });

  return result;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  }

  if (ast.content &#x26;&#x26; ast.content.length &#x3e; 0) {
ruleToggles = getToggledRules(ast);
isEnabledFilter = isResultEnabled(ruleToggles);

rules.forEach(function (rule) {
  detects = rule.rule.<span class="apidocCodeKeywordSpan">detect</span>(ast, rule)
    .filter(isEnabledFilter);
  results = results.concat(detects);
  if (detects.length) {
    if (rule.severity === 1) {
      warnings += detects.length;
    }
    else if (rule.severity === 2) {
...</pre></li>
    </ul>






</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.sass-lint.bem_depth" id="apidoc.module.sass-lint.bem_depth">module sass-lint.bem_depth</a></h1>


    <h2>
        <a href="#apidoc.element.sass-lint.bem_depth.detect" id="apidoc.element.sass-lint.bem_depth.detect">
        function <span class="apidocSignatureSpan">sass-lint.bem_depth.</span>detect
        <span class="apidocSignatureSpan">(ast, parser)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">detect = function (ast, parser) {
  var result = [];

  ast.traverseByTypes([&#x27;ruleset&#x27;, &#x27;placeholder&#x27;], function (node) {
    var name,
        depth,
        selectorAndExtensions,
        maxDepth = parser.options[&#x27;max-depth&#x27;];

    if (node.is(&#x27;placeholder&#x27;)) {
      name = selectorHelpers.constructSelector(node);
      if (name) {
        depth = bemDepth(name);
        if (depth &#x3e; maxDepth) {
          result = helpers.addUnique(result, {
            &#x27;ruleId&#x27;: parser.rule.name,
            &#x27;line&#x27;: node.start.line,
            &#x27;column&#x27;: node.start.column,
            &#x27;message&#x27;: [&#x27;Placeholder \&#x27;%&#x27;, name, &#x27;\&#x27; should have &#x27;, maxDepth, &#x27; or fewer BEM elements, but &#x27;,
              depth, &#x27; were found.&#x27;].join(&#x27;&#x27;),
            &#x27;severity&#x27;: parser.severity
          });
        }
      }
    }
    else {
      selectorAndExtensions = helpers.collectSuffixExtensions(node, &#x27;class&#x27;);

      selectorAndExtensions.forEach(function (selector) {
        name = selector.content;
        depth = bemDepth(name);

        if (depth &#x3e; maxDepth) {
          result = helpers.addUnique(result, {
            &#x27;ruleId&#x27;: parser.rule.name,
            &#x27;line&#x27;: selector.start.line,
            &#x27;column&#x27;: selector.start.column,
            &#x27;message&#x27;: [&#x27;Selector \&#x27;.&#x27;, name, &#x27;\&#x27; should have &#x27;, maxDepth, &#x27; or fewer BEM elements, but &#x27;,
              depth, &#x27; were found.&#x27;].join(&#x27;&#x27;),
            &#x27;severity&#x27;: parser.severity
          });
        }
      });
    }
  });

  return result;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  }

  if (ast.content &#x26;&#x26; ast.content.length &#x3e; 0) {
ruleToggles = getToggledRules(ast);
isEnabledFilter = isResultEnabled(ruleToggles);

rules.forEach(function (rule) {
  detects = rule.rule.<span class="apidocCodeKeywordSpan">detect</span>(ast, rule)
    .filter(isEnabledFilter);
  results = results.concat(detects);
  if (detects.length) {
    if (rule.severity === 1) {
      warnings += detects.length;
    }
    else if (rule.severity === 2) {
...</pre></li>
    </ul>






</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.sass-lint.border_zero" id="apidoc.module.sass-lint.border_zero">module sass-lint.border_zero</a></h1>


    <h2>
        <a href="#apidoc.element.sass-lint.border_zero.detect" id="apidoc.element.sass-lint.border_zero.detect">
        function <span class="apidocSignatureSpan">sass-lint.border_zero.</span>detect
        <span class="apidocSignatureSpan">(ast, parser)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">detect = function (ast, parser) {
  var result = [];
  var userConvention = parser.options.convention.toString();
  var convention = allowedConventions.indexOf(userConvention) !== -1
    ? userConvention
    : allowedConventions[0];
  var invalidConvention = convention !== userConvention;

  ast.traverseByType(&#x27;declaration&#x27;, function (declaration) {
    var isBorder = false;

    declaration.traverse(function (item) {
      if (item.type === &#x27;property&#x27;) {
        item.traverse(function (child) {
          if (borders.indexOf(child.content) !== -1) {
            isBorder = true;
          }
        });
      }

      if (isBorder) {
        if (item.type === &#x27;value&#x27;) {
          var node = item.content[0];
          if (node.type === &#x27;number&#x27; || node.type === &#x27;ident&#x27;) {
            if (node.content === &#x27;0&#x27; || node.content === &#x27;none&#x27;) {
              if (convention !== node.content) {
                if (invalidConvention) {
                  invalidConvention = false;
                  result = helpers.addUnique(result, {
                    &#x27;ruleId&#x27;: parser.rule.name,
                    &#x27;line&#x27;: 1,
                    &#x27;column&#x27;: 1,
                    &#x27;message&#x27;: &#x27;The border-zero convention `&#x27; + userConvention + &#x27; in your config file is not valid. Defaulted to
 convention\&#x27;0\&#x27;&#x27;,
                    &#x27;severity&#x27;: parser.severity
                  });
                }
                result = helpers.addUnique(result, {
                  &#x27;ruleId&#x27;: parser.rule.name,
                  &#x27;line&#x27;: node.start.line,
                  &#x27;column&#x27;: node.start.column,
                  &#x27;message&#x27;: &#x27;A value of `&#x27; + node.content + &#x27;` is not allowed. `&#x27; + convention + &#x27;` must be used.&#x27;,
                  &#x27;severity&#x27;: parser.severity
                });
              }
            }
          }
        }
      }
    });
  });

  return result;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  }

  if (ast.content &#x26;&#x26; ast.content.length &#x3e; 0) {
ruleToggles = getToggledRules(ast);
isEnabledFilter = isResultEnabled(ruleToggles);

rules.forEach(function (rule) {
  detects = rule.rule.<span class="apidocCodeKeywordSpan">detect</span>(ast, rule)
    .filter(isEnabledFilter);
  results = results.concat(detects);
  if (detects.length) {
    if (rule.severity === 1) {
      warnings += detects.length;
    }
    else if (rule.severity === 2) {
...</pre></li>
    </ul>






</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.sass-lint.brace_style" id="apidoc.module.sass-lint.brace_style">module sass-lint.brace_style</a></h1>


    <h2>
        <a href="#apidoc.element.sass-lint.brace_style.detect" id="apidoc.element.sass-lint.brace_style.detect">
        function <span class="apidocSignatureSpan">sass-lint.brace_style.</span>detect
        <span class="apidocSignatureSpan">(ast, parser)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">detect = function (ast, parser) {
  var result = [],
      acceptedAtrules = [
        &#x27;function&#x27;,
        &#x27;if&#x27;,
        &#x27;else&#x27;
      ];

  ast.traverseByTypes([&#x27;conditionalStatement&#x27;, &#x27;atrule&#x27;, &#x27;ruleset&#x27;, &#x27;mixin&#x27;, &#x27;loop&#x27;], function (node, i, parent) {
    var currentNode = false,
        previousNode = false,
        checks = {
          singleLineStatement: null,
          openingBraceOnNewLine: null,
          closingBraceOnNewLine: null,
          conditionOnNewLine: null
        },
        messages = [
          &#x27;Single line statements are not allowed&#x27;,
          &#x27;Opening brace must be on the same line as condition&#x27;,
          &#x27;Brace must be on a new line&#x27;,
          &#x27;Statement must start on the same line as the closing brace of the previous statement&#x27;,
          &#x27;Statement must begin on a new line&#x27;,
          &#x27;Closing brace must be on a new line&#x27;
        ];

    // SCSS syntax only rule
    if (ast.syntax === &#x27;sass&#x27;) {
      return false;
    }

    // Filter at-rule types
    if (filterAtrule(node, acceptedAtrules)) {
      return false;
    }

    // Assign current &#x26; previous nodes based on node type
    currentNode = getCurrentNode(node);
    previousNode = getPreviousNode(node);

    // If not an exception carry on
    if (!isException(node, currentNode, previousNode)) {

      // Run and store rule check results
      checks = runRuleChecks(node, currentNode, previousNode, parent, i);

      // Build single-line statement results
      if (checks.singleLineStatement === false &#x26;&#x26; checks.closingBraceOnNewLine === false) {
        result = helpers.addUnique(result, createIssue(parser, {
          line: currentNode.end.line,
          column: currentNode.end.column
        }, messages[5]));
      }

      if (checks.singleLineStatement === true) {
        if (parser.options[&#x27;allow-single-line&#x27;] === false) {
          result = helpers.addUnique(result, createIssue(parser, {
            line: node.start.line,
            column: node.start.column
          }, messages[0]));
        }
        return false;
      }

      // Build brace-style results
      if (previousNode &#x26;&#x26; currentNode) {
        if (parser.options.style === &#x27;1tbs&#x27;) {
          if (checks.openingBraceOnNewLine === false) {
            result = helpers.addUnique(result, createIssue(parser, {
              line: currentNode.start.line,
              column: currentNode.start.column
            }, messages[1]));
          }
          if (checks.conditionOnNewLine === true) {
            result = helpers.addUnique(result, createIssue(parser, {
              line: previousNode.start.line,
              column: previousNode.start.column
            }, messages[3]));
          }
        }

        if (parser.options.style === &#x27;stroustrup&#x27;) {
          if (checks.openingBraceOnNewLine === false) {
            result = helpers.addUnique(result, createIssue(parser, {
              line: currentNode.start.line,
              column: currentNode.start.column
            }, messages[1]));
          }
          if (checks.conditionOnNewLine === false) {
            result = helpers.addUnique(result, createIssue(parser, {
              line: previousNode.start.line,
              column: previousNode.start.column
            }, messages[4]));
          }
        }

        if (parser.options.style === &#x27;allman&#x27;) {
          if (checks.openingBraceOnNewLine === true) {
            result = helpers.addUnique(result, createIssue(parser, {
              line: currentNode.end.line,
              column: currentNode.end.column
            }, messages[2]));
          }
          if (checks.conditionOnNewLine === false) {
            result = helpers.addUnique(result, createIssue(parser, {
              line: previousNode.start.line,
              column: previousNode.start.column
            }, messages[4]));
          }
        }
      }
    }

    return true;
  });

  return result;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  }

  if (ast.content &#x26;&#x26; ast.content.length &#x3e; 0) {
ruleToggles = getToggledRules(ast);
isEnabledFilter = isResultEnabled(ruleToggles);

rules.forEach(function (rule) {
  detects = rule.rule.<span class="apidocCodeKeywordSpan">detect</span>(ast, rule)
    .filter(isEnabledFilter);
  results = results.concat(detects);
  if (detects.length) {
    if (rule.severity === 1) {
      warnings += detects.length;
    }
    else if (rule.severity === 2) {
...</pre></li>
    </ul>






</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.sass-lint.class_name_format" id="apidoc.module.sass-lint.class_name_format">module sass-lint.class_name_format</a></h1>


    <h2>
        <a href="#apidoc.element.sass-lint.class_name_format.detect" id="apidoc.element.sass-lint.class_name_format.detect">
        function <span class="apidocSignatureSpan">sass-lint.class_name_format.</span>detect
        <span class="apidocSignatureSpan">(ast, parser)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">detect = function (ast, parser) {
  var result = [];

  ast.traverseByType(&#x27;ruleset&#x27;, function (ruleset) {
    var selectorAndExtensions = helpers.collectSuffixExtensions(ruleset, &#x27;class&#x27;);

    selectorAndExtensions.forEach(function (node) {
      var name = node.content,
          strippedName,
          violationMessage = false;

      if (parser.options.ignore.indexOf(name) !== -1) {
        return;
      }

      strippedName = name;

      if (parser.options[&#x27;allow-leading-underscore&#x27;] &#x26;&#x26; name[0] === &#x27;_&#x27;) {
        strippedName = name.slice(1);
      }

      switch (parser.options.convention) {
      case &#x27;hyphenatedlowercase&#x27;:
        if (!helpers.isHyphenatedLowercase(strippedName)) {
          violationMessage = &#x27;Class \&#x27;.&#x27; + name + &#x27;\&#x27; should be written in lowercase with hyphens&#x27;;
        }
        break;
      case &#x27;camelcase&#x27;:
        if (!helpers.isCamelCase(strippedName)) {
          violationMessage = &#x27;Class \&#x27;.&#x27; + name + &#x27;\&#x27; should be written in camelCase&#x27;;
        }
        break;
      case &#x27;pascalcase&#x27;:
        if (!helpers.isPascalCase(strippedName)) {
          violationMessage = &#x27;Class \&#x27;.&#x27; + name + &#x27;\&#x27; should be written in PascalCase&#x27;;
        }
        break;
      case &#x27;snakecase&#x27;:
        if (!helpers.isSnakeCase(strippedName)) {
          violationMessage = &#x27;Class \&#x27;.&#x27; + name + &#x27;\&#x27; should be written in snake_case&#x27;;
        }
        break;
      case &#x27;strictbem&#x27;:
        if (!helpers.isStrictBEM(strippedName)) {
          violationMessage = &#x27;Class \&#x27;.&#x27; + name + &#x27;\&#x27; should be written in BEM (Block Element Modifier) format&#x27;;
        }
        break;
      case &#x27;hyphenatedbem&#x27;:
        if (!helpers.isHyphenatedBEM(strippedName)) {
          violationMessage = &#x27;Class \&#x27;.&#x27; + name + &#x27;\&#x27; should be written in hyphenated BEM (Block Element Modifier) format&#x27;;
        }
        break;
      default:
        if (!(new RegExp(parser.options.convention).test(strippedName))) {
          violationMessage = &#x27;Class \&#x27;.&#x27; + name + &#x27;\&#x27; should match regular expression /&#x27; + parser.options.convention + &#x27;/&#x27;;

          // convention-message overrides violationMessage
          if (parser.options[&#x27;convention-explanation&#x27;]) {
            violationMessage = parser.options[&#x27;convention-explanation&#x27;];
          }
        }
      }

      if (violationMessage) {
        result = helpers.addUnique(result, {
          &#x27;ruleId&#x27;: parser.rule.name,
          &#x27;line&#x27;: node.start.line,
          &#x27;column&#x27;: node.start.column,
          &#x27;message&#x27;: violationMessage,
          &#x27;severity&#x27;: parser.severity
        });
      }
    });
  });

  return result;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  }

  if (ast.content &#x26;&#x26; ast.content.length &#x3e; 0) {
ruleToggles = getToggledRules(ast);
isEnabledFilter = isResultEnabled(ruleToggles);

rules.forEach(function (rule) {
  detects = rule.rule.<span class="apidocCodeKeywordSpan">detect</span>(ast, rule)
    .filter(isEnabledFilter);
  results = results.concat(detects);
  if (detects.length) {
    if (rule.severity === 1) {
      warnings += detects.length;
    }
    else if (rule.severity === 2) {
...</pre></li>
    </ul>






</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.sass-lint.clean_import_paths" id="apidoc.module.sass-lint.clean_import_paths">module sass-lint.clean_import_paths</a></h1>


    <h2>
        <a href="#apidoc.element.sass-lint.clean_import_paths.detect" id="apidoc.element.sass-lint.clean_import_paths.detect">
        function <span class="apidocSignatureSpan">sass-lint.clean_import_paths.</span>detect
        <span class="apidocSignatureSpan">(ast, parser)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">detect = function (ast, parser) {
  var result = [];

  ast.traverseByType(&#x27;atkeyword&#x27;, function (keyword, i, parent) {
    keyword.forEach(function (item) {
      if (item.content === &#x27;import&#x27;) {
        var importPath = getImportPath(parent, keyword.syntax);

        if (importPath) {
          if (typeof importPath === &#x27;string&#x27;) {
            var filename = path.basename(importPath),
                fileExtension = path.extname(filename);

            if (fileExtension === &#x27;.sass&#x27; || fileExtension === &#x27;.scss&#x27; || fileExtension === &#x27;&#x27;) {
              if (filename.charAt(0) === &#x27;_&#x27;) {
                if (!parser.options[&#x27;leading-underscore&#x27;]) {
                  result = helpers.addUnique(result, {
                    &#x27;ruleId&#x27;: parser.rule.name,
                    &#x27;line&#x27;: item.start.line,
                    &#x27;column&#x27;: item.start.column,
                    &#x27;message&#x27;: &#x27;Leading underscores are not allowed&#x27;,
                    &#x27;severity&#x27;: parser.severity
                  });
                }
              }
              else {
                if (parser.options[&#x27;leading-underscore&#x27;]) {
                  result = helpers.addUnique(result, {
                    &#x27;ruleId&#x27;: parser.rule.name,
                    &#x27;line&#x27;: item.start.line,
                    &#x27;column&#x27;: item.start.column,
                    &#x27;message&#x27;: &#x27;Leading underscores are required&#x27;,
                    &#x27;severity&#x27;: parser.severity
                  });
                }
              }

              if (fileExtension) {
                if (!parser.options[&#x27;filename-extension&#x27;]) {
                  result = helpers.addUnique(result, {
                    &#x27;ruleId&#x27;: parser.rule.name,
                    &#x27;line&#x27;: item.start.line,
                    &#x27;column&#x27;: item.start.column,
                    &#x27;message&#x27;: &#x27;File extensions are not allowed&#x27;,
                    &#x27;severity&#x27;: parser.severity
                  });
                }
              }
              else {
                if (parser.options[&#x27;filename-extension&#x27;]) {
                  result = helpers.addUnique(result, {
                    &#x27;ruleId&#x27;: parser.rule.name,
                    &#x27;line&#x27;: item.start.line,
                    &#x27;column&#x27;: item.start.column,
                    &#x27;message&#x27;: &#x27;File extensions are required&#x27;,
                    &#x27;severity&#x27;: parser.severity
                  });
                }
              }
            }
          }
        }
      }
    });
  });

  return result;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  }

  if (ast.content &#x26;&#x26; ast.content.length &#x3e; 0) {
ruleToggles = getToggledRules(ast);
isEnabledFilter = isResultEnabled(ruleToggles);

rules.forEach(function (rule) {
  detects = rule.rule.<span class="apidocCodeKeywordSpan">detect</span>(ast, rule)
    .filter(isEnabledFilter);
  results = results.concat(detects);
  if (detects.length) {
    if (rule.severity === 1) {
      warnings += detects.length;
    }
    else if (rule.severity === 2) {
...</pre></li>
    </ul>






</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.sass-lint.config_helpers" id="apidoc.module.sass-lint.config_helpers">module sass-lint.config_helpers</a></h1>


    <h2>
        <a href="#apidoc.element.sass-lint.config_helpers.checkForConfigExtend" id="apidoc.element.sass-lint.config_helpers.checkForConfigExtend">
        function <span class="apidocSignatureSpan">sass-lint.config_helpers.</span>checkForConfigExtend
        <span class="apidocSignatureSpan">(config, curConfPath)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">checkForConfigExtend = function (config, curConfPath) {
  var mergedConfig = config,
      subConfig = config.options[&#x27;config-file&#x27;] || false,
      confPath,
      resolvedSubConfig;

  if (subConfig) {
    if (!pathIsAbsolute(subConfig)) {
      // Process.cwd() in most IDE&#x27;s will be / so therefore we need to pass the current directory
      // of the config from which you are &#x27;extending&#x27; or we resort to process.cwd() which on the CLI
      // will be correct
      confPath = curConfPath ? path.dirname(curConfPath) : process.cwd();
      subConfig = path.resolve(confPath, subConfig);
    }
    // Attempt to load the new found config file
    resolvedSubConfig = loadConfig(subConfig, curConfPath);
    // Check the new config file to see if it too is extending
    resolvedSubConfig = checkForConfigExtend(resolvedSubConfig, subConfig);
    // Merge our configs with the first encountered being the most important, down to the last config
    // being the least.
    mergedConfig = merge.recursive(resolvedSubConfig, config);
  }

  return mergedConfig;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  }
}
else if (!pathIsAbsolute(configPath)) {
  configPath = path.resolve(process.cwd(), configPath);
}

config = confHelpers.loadConfig(configPath);
config = confHelpers.<span class="apidocCodeKeywordSpan">checkForConfigExtend</span>(config, configPath);

// check to see if user config contains an options property and whether property has a property called merge-default-rules
configMergeExists = (config.options &#x26;&#x26; typeof config.options[&#x27;merge-default-rules&#x27;] !== &#x27;undefined&#x27
;);

// If it does then retrieve the value of it here or return false
configMerge = configMergeExists ? config.options[&#x27;merge-default-rules&#x27;] : false;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.sass-lint.config_helpers.findFile" id="apidoc.element.sass-lint.config_helpers.findFile">
        function <span class="apidocSignatureSpan">sass-lint.config_helpers.</span>findFile
        <span class="apidocSignatureSpan">(configPath, filename)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function findFile(configPath, filename) {
  var HOME = process.env.HOME || process.env.HOMEPATH || process.env.USERPROFILE,
      dirname = null,
      parentDirname = null;

  configPath = configPath || path.join(process.cwd(), filename);

  if (configPath &#x26;&#x26; fs.existsSync(configPath)) {
    return fs.realpathSync(configPath);
  }
  dirname = path.dirname(configPath);
  parentDirname = path.dirname(dirname);

  if (dirname === null || dirname === HOME || dirname === parentDirname) {
    return null;
  }
  configPath = path.join(parentDirname, filename);

  return findFile(configPath, filename);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  }

  if (options.options &#x26;&#x26; options.options[&#x27;config-file&#x27;]) {
configPath = options.options[&#x27;config-file&#x27;];
  }

  if (!configPath) {
metaPath = confHelpers.<span class="apidocCodeKeywordSpan">findFile</span>(false, &#x27;package.json&#x27;);
if (metaPath) {
  meta = require(metaPath);
}

if (meta &#x26;&#x26; meta.sasslintConfig) {
  configPath = path.resolve(path.dirname(metaPath), meta.sasslintConfig);
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.sass-lint.config_helpers.loadConfig" id="apidoc.element.sass-lint.config_helpers.loadConfig">
        function <span class="apidocSignatureSpan">sass-lint.config_helpers.</span>loadConfig
        <span class="apidocSignatureSpan">(cPath)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">loadConfig = function (cPath) {
  var configPath = cPath,
      resolvedConfig = {};

  if (configPath) {
    if (fs.existsSync(configPath)) {
      resolvedConfig = yaml.safeLoad(fs.readFileSync(configPath, &#x27;utf8&#x27;)) || {};
    }
  }

  return {
    options: resolvedConfig.options || {},
    files: resolvedConfig.files || {},
    rules: resolvedConfig.rules || {}
  };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    configPath = confHelpers.findFile(false, &#x27;.sass-lint.yml&#x27;);
  }
}
else if (!pathIsAbsolute(configPath)) {
  configPath = path.resolve(process.cwd(), configPath);
}

config = confHelpers.<span class="apidocCodeKeywordSpan">loadConfig</span>(configPath);
config = confHelpers.checkForConfigExtend(config, configPath);

// check to see if user config contains an options property and whether property has a property called merge-default-rules
configMergeExists = (config.options &#x26;&#x26; typeof config.options[&#x27;merge-default-rules&#x27;] !== &#x27;undefined&#x27
;);

// If it does then retrieve the value of it here or return false
configMerge = configMergeExists ? config.options[&#x27;merge-default-rules&#x27;] : false;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.sass-lint.config_helpers.loadDefaults" id="apidoc.element.sass-lint.config_helpers.loadDefaults">
        function <span class="apidocSignatureSpan">sass-lint.config_helpers.</span>loadDefaults
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function loadDefaults() {
  return yaml.safeLoad(fs.readFileSync(path.join(__dirname, &#x27;config&#x27;, &#x27;sass-lint.yml&#x27;), &#x27;utf8&#x27;));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
// If it does then retrieve the value of it here or return false
optionsMerge = optionsMergeExists ? options.options[&#x27;merge-default-rules&#x27;] : false;


// order of preference is inline options &#x3e; user config &#x3e; default config
// merge-default-rules defaults to true so each step above should merge with the previous. If at any step merge-default-rules is
 set to
// false it should skip that steps merge.
defaults = confHelpers.<span class="apidocCodeKeywordSpan">loadDefaults</span>();
finalConfig = merge.recursive(defaults, config, options);

// if merge-default-rules is set to false in user config file then we essentially skip the merging with default rules by overwriting
 our
// final rules with the content of our user config otherwise we don&#x27;t take action here as the default merging has already happened
if (configMergeExists &#x26;&#x26; !configMerge) {
  finalConfig.rules = config.rules;
}
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.sass-lint.declarations_before_nesting" id="apidoc.module.sass-lint.declarations_before_nesting">module sass-lint.declarations_before_nesting</a></h1>


    <h2>
        <a href="#apidoc.element.sass-lint.declarations_before_nesting.detect" id="apidoc.element.sass-lint.declarations_before_nesting.detect">
        function <span class="apidocSignatureSpan">sass-lint.declarations_before_nesting.</span>detect
        <span class="apidocSignatureSpan">(ast, parser)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">detect = function (ast, parser) {
  var result = [],
      error;

  ast.traverseByType(&#x27;block&#x27;, function (block) {
    if (block.contains(&#x27;ruleset&#x27;) &#x26;&#x26; block.contains(&#x27;declaration&#x27;)) {
      var rulesetIndex;

      block.forEach(function (item, j) {
        var declarationIndex;
        var declaration;

        if (item.is(&#x27;ruleset&#x27;) &#x26;&#x26; rulesetIndex === void 0) {
          rulesetIndex = j;
        }

        if (item.is(&#x27;declaration&#x27;)) {
          var property = item.content[0];

          if (property &#x26;&#x26; property.is(&#x27;property&#x27;)) {
            if (property.content[0] &#x26;&#x26; property.content[0].is(&#x27;variable&#x27;)) {
              return;
            }
          }

          declarationIndex = j;
          declaration = item;
        }

        if (rulesetIndex &#x3c; declarationIndex &#x26;&#x26; declaration) {
          error = {
            &#x27;ruleId&#x27;: parser.rule.name,
            &#x27;line&#x27;: declaration.start.line,
            &#x27;column&#x27;: declaration.start.column,
            &#x27;message&#x27;: &#x27;Declarations should come before nestings&#x27;,
            &#x27;severity&#x27;: parser.severity
          };
          result = helpers.addUnique(result, error);
        }
      });

      rulesetIndex = null;
    }
  });

  return result;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  }

  if (ast.content &#x26;&#x26; ast.content.length &#x3e; 0) {
ruleToggles = getToggledRules(ast);
isEnabledFilter = isResultEnabled(ruleToggles);

rules.forEach(function (rule) {
  detects = rule.rule.<span class="apidocCodeKeywordSpan">detect</span>(ast, rule)
    .filter(isEnabledFilter);
  results = results.concat(detects);
  if (detects.length) {
    if (rule.severity === 1) {
      warnings += detects.length;
    }
    else if (rule.severity === 2) {
...</pre></li>
    </ul>






</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.sass-lint.empty_args" id="apidoc.module.sass-lint.empty_args">module sass-lint.empty_args</a></h1>


    <h2>
        <a href="#apidoc.element.sass-lint.empty_args.detect" id="apidoc.element.sass-lint.empty_args.detect">
        function <span class="apidocSignatureSpan">sass-lint.empty_args.</span>detect
        <span class="apidocSignatureSpan">(ast, parser)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">detect = function (ast, parser) {
  var result = [];

  ast.traverseByTypes([&#x27;mixin&#x27;, &#x27;include&#x27;], function (item) {
    if (item.contains(&#x27;arguments&#x27;)) {
      item.traverse(function (node) {
        if (node.type === &#x27;arguments&#x27;) {
          if (node.content.length === 0) {
            if (!parser.options.include) {
              result = helpers.addUnique(result, {
                &#x27;ruleId&#x27;: parser.rule.name,
                &#x27;line&#x27;: node.start.line,
                &#x27;column&#x27;: node.start.column,
                &#x27;message&#x27;: &#x27;Parenthesis should be removed.&#x27;,
                &#x27;severity&#x27;: parser.severity
              });
            }
          }
        }
      });
    }
    else {
      if (parser.options.include) {
        result = helpers.addUnique(result, {
          &#x27;ruleId&#x27;: parser.rule.name,
          &#x27;line&#x27;: item.start.line,
          &#x27;column&#x27;: item.start.column,
          &#x27;message&#x27;: &#x27;Parenthesis are required.&#x27;,
          &#x27;severity&#x27;: parser.severity
        });
      }
    }
  });

  return result;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  }

  if (ast.content &#x26;&#x26; ast.content.length &#x3e; 0) {
ruleToggles = getToggledRules(ast);
isEnabledFilter = isResultEnabled(ruleToggles);

rules.forEach(function (rule) {
  detects = rule.rule.<span class="apidocCodeKeywordSpan">detect</span>(ast, rule)
    .filter(isEnabledFilter);
  results = results.concat(detects);
  if (detects.length) {
    if (rule.severity === 1) {
      warnings += detects.length;
    }
    else if (rule.severity === 2) {
...</pre></li>
    </ul>






</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.sass-lint.empty_line_between_blocks" id="apidoc.module.sass-lint.empty_line_between_blocks">module sass-lint.empty_line_between_blocks</a></h1>


    <h2>
        <a href="#apidoc.element.sass-lint.empty_line_between_blocks.detect" id="apidoc.element.sass-lint.empty_line_between_blocks.detect">
        function <span class="apidocSignatureSpan">sass-lint.empty_line_between_blocks.</span>detect
        <span class="apidocSignatureSpan">(ast, parser)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">detect = function (ast, parser) {
  var result = [];
  syntax = ast.syntax;

  ast.traverseByType(&#x27;ruleset&#x27;, function (node, j, p) {
    var space;

    if ((node.start.line === node.end.line) &#x26;&#x26; parser.options[&#x27;allow-single-line-rulesets&#x27;]) {
      return false;
    }

    if (syntax === &#x27;scss&#x27;) {
      space = findNearestReturnSCSS(p, j);

      if (space) {
        if (parser.options.include &#x26;&#x26; !space.space &#x26;&#x26; j !== 1) {
          result = helpers.addUnique(result, {
            &#x27;ruleId&#x27;: parser.rule.name,
            &#x27;line&#x27;: space.previous.end.line,
            &#x27;column&#x27;: 1,
            &#x27;message&#x27;: &#x27;Space expected between blocks&#x27;,
            &#x27;severity&#x27;: parser.severity
          });
        }
        else if (!parser.options.include &#x26;&#x26; space.space) {
          result = helpers.addUnique(result, {
            &#x27;ruleId&#x27;: parser.rule.name,
            &#x27;line&#x27;: space.previous.end.line,
            &#x27;column&#x27;: 1,
            &#x27;message&#x27;: &#x27;Space not allowed between blocks&#x27;,
            &#x27;severity&#x27;: parser.severity
          });
        }
      }
    }
    else if (syntax === &#x27;sass&#x27;) {
      // Reset the counter for each ruleset
      counter = 0;

      if (node.is(&#x27;ruleset&#x27;)) {

        node.forEach(&#x27;block&#x27;, function (block, i, parent) {
          var previous;

          // Capture the previous node
          if (parent.content[i - 1]) {
            previous = parent.content[i - 1];
          }
          else {
            // Else set the block to act as the previous node
            previous = block;
          }

          // If it&#x27;s a new line, lets go back up to the selector
          if (previous.is(&#x27;space&#x27;) &#x26;&#x26; helpers.hasEOL(previous.content)) {
            space = findNearestReturnSass(p, j);
          }
        });
      }

      if (space &#x26;&#x26; space.previous) {
        if (space.previous.start.line !== 1) {
          if (parser.options.include &#x26;&#x26; !space.space) {
            result = helpers.addUnique(result, {
              &#x27;ruleId&#x27;: parser.rule.name,
              &#x27;line&#x27;: space.previous.end.line + 1,
              &#x27;column&#x27;: 1,
              &#x27;message&#x27;: &#x27;Space expected between blocks&#x27;,
              &#x27;severity&#x27;: parser.severity
            });
          }
          else if (!parser.options.include &#x26;&#x26; space.space) {
            result = helpers.addUnique(result, {
              &#x27;ruleId&#x27;: parser.rule.name,
              &#x27;line&#x27;: space.previous.end.line + 1,
              &#x27;column&#x27;: 1,
              &#x27;message&#x27;: &#x27;Space not allowed between blocks&#x27;,
              &#x27;severity&#x27;: parser.severity
            });
          }
        }
      }
    }
    return true;
  });

  return result;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  }

  if (ast.content &#x26;&#x26; ast.content.length &#x3e; 0) {
ruleToggles = getToggledRules(ast);
isEnabledFilter = isResultEnabled(ruleToggles);

rules.forEach(function (rule) {
  detects = rule.rule.<span class="apidocCodeKeywordSpan">detect</span>(ast, rule)
    .filter(isEnabledFilter);
  results = results.concat(detects);
  if (detects.length) {
    if (rule.severity === 1) {
      warnings += detects.length;
    }
    else if (rule.severity === 2) {
...</pre></li>
    </ul>






</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.sass-lint.exceptions" id="apidoc.module.sass-lint.exceptions">module sass-lint.exceptions</a></h1>


    <h2>
        <a href="#apidoc.element.sass-lint.exceptions.MaxWarningsExceededError" id="apidoc.element.sass-lint.exceptions.MaxWarningsExceededError">
        function <span class="apidocSignatureSpan">sass-lint.exceptions.</span>MaxWarningsExceededError
        <span class="apidocSignatureSpan">(message)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">MaxWarningsExceededError = function (message) {
  Error.captureStackTrace(this, this.constructor);
  this.name = &#x27;MaxWarningsExceededError&#x27;;
  this.message = message;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
      configOptions = this.getConfig(options, configPath).options;

  if (errorCount.count &#x3e; 0) {
    throw new exceptions.SassLintFailureError(errorCount.count + &#x27; errors were detected in \n- &#x27; + errorCount.files.join
(&#x27;\n- &#x27;));
  }

  if (!isNaN(configOptions[&#x27;max-warnings&#x27;]) &#x26;&#x26; warningCount.count &#x3e; configOptions[&#x27;max-warnings&#x27
;]) {
    throw new exceptions.<span class="apidocCodeKeywordSpan">MaxWarningsExceededError</span>(
      &#x27;Number of warnings (&#x27; + warningCount.count +
      &#x27;) exceeds the allowed maximum of &#x27; + configOptions[&#x27;max-warnings&#x27;] +
      &#x27;.\n&#x27;
    );
  }
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.sass-lint.exceptions.SassLintFailureError" id="apidoc.element.sass-lint.exceptions.SassLintFailureError">
        function <span class="apidocSignatureSpan">sass-lint.exceptions.</span>SassLintFailureError
        <span class="apidocSignatureSpan">(message)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">SassLintFailureError = function (message) {
  Error.captureStackTrace(this, this.constructor);
  this.name = &#x27;SassLintFailureError&#x27;;
  this.message = message;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
configPath = typeof configPath !== &#x27;undefined&#x27; ? configPath : null;

var errorCount = this.errorCount(results),
    warningCount = this.warningCount(results),
    configOptions = this.getConfig(options, configPath).options;

if (errorCount.count &#x3e; 0) {
  throw new exceptions.<span class="apidocCodeKeywordSpan">SassLintFailureError</span>(errorCount.count + &#x27; errors were detected
 in\n- &#x27; + errorCount.files.join(&#x27;\n- &#x27;));
}

if (!isNaN(configOptions[&#x27;max-warnings&#x27;]) &#x26;&#x26; warningCount.count &#x3e; configOptions[&#x27;max-warnings&#x27
;]) {
  throw new exceptions.MaxWarningsExceededError(
    &#x27;Number of warnings (&#x27; + warningCount.count +
    &#x27;) exceeds the allowed maximum of &#x27; + configOptions[&#x27;max-warnings&#x27;] +
    &#x27;.\n&#x27;
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.sass-lint.extends_before_declarations" id="apidoc.module.sass-lint.extends_before_declarations">module sass-lint.extends_before_declarations</a></h1>


    <h2>
        <a href="#apidoc.element.sass-lint.extends_before_declarations.detect" id="apidoc.element.sass-lint.extends_before_declarations.detect">
        function <span class="apidocSignatureSpan">sass-lint.extends_before_declarations.</span>detect
        <span class="apidocSignatureSpan">(ast, parser)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">detect = function (ast, parser) {
  var result = [],
      error;

  ast.traverseByType(&#x27;block&#x27;, function (block) {
    var lastDeclaration = null;

    block.forEach(function (item, j) {
      if (item.is(&#x27;include&#x27;) || item.is(&#x27;extend&#x27;)) {
        if (item.contains(&#x27;atkeyword&#x27;)) {
          var atkeyword = item.first(&#x27;atkeyword&#x27;);

          if (atkeyword.contains(&#x27;ident&#x27;)) {
            var ident = atkeyword.first(&#x27;ident&#x27;);

            if (ident.content === &#x27;extend&#x27;) {
              if (j &#x3e; lastDeclaration &#x26;&#x26; lastDeclaration !== null) {
                error = {
                  &#x27;ruleId&#x27;: parser.rule.name,
                  &#x27;line&#x27;: item.start.line,
                  &#x27;column&#x27;: item.start.column,
                  &#x27;message&#x27;: &#x27;Extends should come before declarations&#x27;,
                  &#x27;severity&#x27;: parser.severity
                };
                result = helpers.addUnique(result, error);
              }
            }
          }
        }
      }

      if (item.is(&#x27;declaration&#x27;)) {
        lastDeclaration = j;
      }
    });
    lastDeclaration = null;
  });

  return result;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  }

  if (ast.content &#x26;&#x26; ast.content.length &#x3e; 0) {
ruleToggles = getToggledRules(ast);
isEnabledFilter = isResultEnabled(ruleToggles);

rules.forEach(function (rule) {
  detects = rule.rule.<span class="apidocCodeKeywordSpan">detect</span>(ast, rule)
    .filter(isEnabledFilter);
  results = results.concat(detects);
  if (detects.length) {
    if (rule.severity === 1) {
      warnings += detects.length;
    }
    else if (rule.severity === 2) {
...</pre></li>
    </ul>






</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.sass-lint.extends_before_mixins" id="apidoc.module.sass-lint.extends_before_mixins">module sass-lint.extends_before_mixins</a></h1>


    <h2>
        <a href="#apidoc.element.sass-lint.extends_before_mixins.detect" id="apidoc.element.sass-lint.extends_before_mixins.detect">
        function <span class="apidocSignatureSpan">sass-lint.extends_before_mixins.</span>detect
        <span class="apidocSignatureSpan">(ast, parser)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">detect = function (ast, parser) {
  var result = [];

  ast.traverseByType(&#x27;block&#x27;, function (block) {
    var lastMixin = null;

    block.forEach(function (item, j) {
      if (item.is(&#x27;include&#x27;) || item.is(&#x27;extend&#x27;)) {
        if (item.contains(&#x27;atkeyword&#x27;)) {
          var atkeyword = item.first(&#x27;atkeyword&#x27;);

          if (atkeyword.contains(&#x27;ident&#x27;)) {
            var ident = atkeyword.first(&#x27;ident&#x27;);

            if (ident.content === &#x27;extend&#x27;) {
              if (j &#x3e; lastMixin &#x26;&#x26; lastMixin !== null) {
                result = helpers.addUnique(result, {
                  &#x27;ruleId&#x27;: parser.rule.name,
                  &#x27;line&#x27;: item.start.line,
                  &#x27;column&#x27;: item.start.column,
                  &#x27;message&#x27;: &#x27;Extends should come before mixins&#x27;,
                  &#x27;severity&#x27;: parser.severity
                });
              }
            }
          }
        }
      }

      if (item.is(&#x27;include&#x27;)) {
        lastMixin = j;
      }
    });

    lastMixin = null;
  });

  return result;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  }

  if (ast.content &#x26;&#x26; ast.content.length &#x3e; 0) {
ruleToggles = getToggledRules(ast);
isEnabledFilter = isResultEnabled(ruleToggles);

rules.forEach(function (rule) {
  detects = rule.rule.<span class="apidocCodeKeywordSpan">detect</span>(ast, rule)
    .filter(isEnabledFilter);
  results = results.concat(detects);
  if (detects.length) {
    if (rule.severity === 1) {
      warnings += detects.length;
    }
    else if (rule.severity === 2) {
...</pre></li>
    </ul>






</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.sass-lint.final_newline" id="apidoc.module.sass-lint.final_newline">module sass-lint.final_newline</a></h1>


    <h2>
        <a href="#apidoc.element.sass-lint.final_newline.detect" id="apidoc.element.sass-lint.final_newline.detect">
        function <span class="apidocSignatureSpan">sass-lint.final_newline.</span>detect
        <span class="apidocSignatureSpan">(ast, parser)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">detect = function (ast, parser) {
  var result = [],
      last,
      error = {
        &#x27;ruleId&#x27;: parser.rule.name,
        &#x27;severity&#x27;: parser.severity
      };

  // If the syntax is Sass we must recursively loop to determine the last node.
  // This is not required for SCSS which will always use the last node in the
  // content of the parent stylesheet node
  if (ast.syntax === &#x27;sass&#x27;) {
    last = getLastNode(ast);
  }
  else {
    last = ast.content[ast.content.length - 1];
  }

  if (!last.is(&#x27;space&#x27;) &#x26;&#x26; !last.is(&#x27;declarationDelimiter&#x27;)) {
    if (parser.options.include) {
      error.line = last.end.line;
      error.column = last.end.column;
      error.message = &#x27;Files must end with a new line&#x27;;
      result = helpers.addUnique(result, error);
    }
  }
  else if ((last.is(&#x27;space&#x27;) || last.is(&#x27;declarationDelimiter&#x27;))) {
    if (!helpers.hasEOL(last.content) &#x26;&#x26; parser.options.include) {
      error.line = last.start.line;
      error.column = last.start.column;
      error.message = &#x27;Files must end with a new line&#x27;;
      result = helpers.addUnique(result, error);
    }
    else if (helpers.hasEOL(last.content) &#x26;&#x26; !parser.options.include) {
      error.line = last.start.line;
      error.column = last.start.column;
      error.message = &#x27;Files must not end with a new line&#x27;;
      result = helpers.addUnique(result, error);
    }
  }

  return result;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  }

  if (ast.content &#x26;&#x26; ast.content.length &#x3e; 0) {
ruleToggles = getToggledRules(ast);
isEnabledFilter = isResultEnabled(ruleToggles);

rules.forEach(function (rule) {
  detects = rule.rule.<span class="apidocCodeKeywordSpan">detect</span>(ast, rule)
    .filter(isEnabledFilter);
  results = results.concat(detects);
  if (detects.length) {
    if (rule.severity === 1) {
      warnings += detects.length;
    }
    else if (rule.severity === 2) {
...</pre></li>
    </ul>






</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.sass-lint.force_attribute_nesting" id="apidoc.module.sass-lint.force_attribute_nesting">module sass-lint.force_attribute_nesting</a></h1>


    <h2>
        <a href="#apidoc.element.sass-lint.force_attribute_nesting.detect" id="apidoc.element.sass-lint.force_attribute_nesting.detect">
        function <span class="apidocSignatureSpan">sass-lint.force_attribute_nesting.</span>detect
        <span class="apidocSignatureSpan">(ast, parser)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">detect = function (ast, parser) {
  var result = [],
      elements = nestableElements.concat(nestableAttributes, nestablePseudo);

  ast.traverseByType(&#x27;ruleset&#x27;, function (ruleset) {

    ruleset.forEach(&#x27;selector&#x27;, function (selector) {
      var previousVal;
      selector.forEach(function (item) {
        if (previousVal) {
          if (helpers.isNestable(item.type, previousVal.type, elements, nestableAttributes)) {
            helpers.addUnique(result, {
              &#x27;ruleId&#x27;: parser.rule.name,
              &#x27;line&#x27;: selector.start.line,
              &#x27;column&#x27;: selector.start.column,
              &#x27;message&#x27;: formatOutput(item.type) + &#x27; should be nested within its parent &#x27; + formatOutput(previousVal.type),
              &#x27;severity&#x27;: parser.severity
            });
          }
        }
        previousVal = item;
      });
    });
  });

  return result;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  }

  if (ast.content &#x26;&#x26; ast.content.length &#x3e; 0) {
ruleToggles = getToggledRules(ast);
isEnabledFilter = isResultEnabled(ruleToggles);

rules.forEach(function (rule) {
  detects = rule.rule.<span class="apidocCodeKeywordSpan">detect</span>(ast, rule)
    .filter(isEnabledFilter);
  results = results.concat(detects);
  if (detects.length) {
    if (rule.severity === 1) {
      warnings += detects.length;
    }
    else if (rule.severity === 2) {
...</pre></li>
    </ul>






</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.sass-lint.force_element_nesting" id="apidoc.module.sass-lint.force_element_nesting">module sass-lint.force_element_nesting</a></h1>


    <h2>
        <a href="#apidoc.element.sass-lint.force_element_nesting.detect" id="apidoc.element.sass-lint.force_element_nesting.detect">
        function <span class="apidocSignatureSpan">sass-lint.force_element_nesting.</span>detect
        <span class="apidocSignatureSpan">(ast, parser)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">detect = function (ast, parser) {
  var result = [],
      elements = nestableElements.concat(nestableAttributes, nestablePseudo);

  ast.traverseByType(&#x27;ruleset&#x27;, function (ruleset) {
    ruleset.forEach(function (selector) {

      var previousVal;
      selector.forEach(function (item) {
        if (previousVal) {
          if (helpers.isNestable(item.type, previousVal.type, elements, nestableElements)) {
            helpers.addUnique(result, {
              &#x27;ruleId&#x27;: parser.rule.name,
              &#x27;line&#x27;: selector.start.line,
              &#x27;column&#x27;: selector.start.column,
              &#x27;message&#x27;: formatOutput(item.type) + &#x27; should be nested within its parent &#x27; + formatOutput(previousVal.type),
              &#x27;severity&#x27;: parser.severity
            });
          }
        }
        if (!item.is(&#x27;space&#x27;)) {
          previousVal = item;
        }
      });
    });
  });

  return result;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  }

  if (ast.content &#x26;&#x26; ast.content.length &#x3e; 0) {
ruleToggles = getToggledRules(ast);
isEnabledFilter = isResultEnabled(ruleToggles);

rules.forEach(function (rule) {
  detects = rule.rule.<span class="apidocCodeKeywordSpan">detect</span>(ast, rule)
    .filter(isEnabledFilter);
  results = results.concat(detects);
  if (detects.length) {
    if (rule.severity === 1) {
      warnings += detects.length;
    }
    else if (rule.severity === 2) {
...</pre></li>
    </ul>






</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.sass-lint.force_pseudo_nesting" id="apidoc.module.sass-lint.force_pseudo_nesting">module sass-lint.force_pseudo_nesting</a></h1>


    <h2>
        <a href="#apidoc.element.sass-lint.force_pseudo_nesting.detect" id="apidoc.element.sass-lint.force_pseudo_nesting.detect">
        function <span class="apidocSignatureSpan">sass-lint.force_pseudo_nesting.</span>detect
        <span class="apidocSignatureSpan">(ast, parser)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">detect = function (ast, parser) {
  var result = [],
      elements = nestableElements.concat(nestableAttributes, nestablePseudo);

  ast.traverseByType(&#x27;ruleset&#x27;, function (ruleset) {

    ruleset.forEach(&#x27;selector&#x27;, function (selector) {
      var previousVal;
      selector.forEach(function (item) {
        if (previousVal) {
          if (helpers.isNestable(item.type, previousVal.type, elements, nestablePseudo)) {
            helpers.addUnique(result, {
              &#x27;ruleId&#x27;: parser.rule.name,
              &#x27;line&#x27;: selector.start.line,
              &#x27;column&#x27;: selector.start.column,
              &#x27;message&#x27;: formatOutput(item.type) + &#x27; should be nested within its parent &#x27; + formatOutput(previousVal.type),
              &#x27;severity&#x27;: parser.severity
            });
          }
        }
        previousVal = item;
      });
    });
  });

  return result;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  }

  if (ast.content &#x26;&#x26; ast.content.length &#x3e; 0) {
ruleToggles = getToggledRules(ast);
isEnabledFilter = isResultEnabled(ruleToggles);

rules.forEach(function (rule) {
  detects = rule.rule.<span class="apidocCodeKeywordSpan">detect</span>(ast, rule)
    .filter(isEnabledFilter);
  results = results.concat(detects);
  if (detects.length) {
    if (rule.severity === 1) {
      warnings += detects.length;
    }
    else if (rule.severity === 2) {
...</pre></li>
    </ul>






</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.sass-lint.function_name_format" id="apidoc.module.sass-lint.function_name_format">module sass-lint.function_name_format</a></h1>


    <h2>
        <a href="#apidoc.element.sass-lint.function_name_format.detect" id="apidoc.element.sass-lint.function_name_format.detect">
        function <span class="apidocSignatureSpan">sass-lint.function_name_format.</span>detect
        <span class="apidocSignatureSpan">(ast, parser)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">detect = function (ast, parser) {
  var result = [];

  ast.traverseByType(&#x27;function&#x27;, function (node) {
    var name = node.first(&#x27;ident&#x27;).content,
        strippedName,
        violationMessage = false;

    // ignore functions on whitelist - css3 transforms
    if (whitelist.indexOf(name) !== -1) {
      return;
    }

    strippedName = name;

    if (parser.options[&#x27;allow-leading-underscore&#x27;] &#x26;&#x26; name[0] === &#x27;_&#x27;) {
      strippedName = name.slice(1);
    }

    switch (parser.options.convention) {
    case &#x27;hyphenatedlowercase&#x27;:
      if (!helpers.isHyphenatedLowercase(strippedName)) {
        violationMessage = &#x27;Function \&#x27;&#x27; + name + &#x27;\&#x27; should be written in lowercase with hyphens&#x27;;
      }
      break;
    case &#x27;camelcase&#x27;:
      if (!helpers.isCamelCase(strippedName)) {
        violationMessage = &#x27;Function \&#x27;&#x27; + name + &#x27;\&#x27; should be written in camelCase&#x27;;
      }
      break;
    case &#x27;pascalcase&#x27;:
      if (!helpers.isPascalCase(strippedName)) {
        violationMessage = &#x27;Function \&#x27;&#x27; + name + &#x27;\&#x27; should be written in PascalCase&#x27;;
      }
      break;
    case &#x27;snakecase&#x27;:
      if (!helpers.isSnakeCase(strippedName)) {
        violationMessage = &#x27;Function \&#x27;&#x27; + name + &#x27;\&#x27; should be written in snake_case&#x27;;
      }
      break;
    case &#x27;strictbem&#x27;:
      if (!helpers.isStrictBEM(strippedName)) {
        violationMessage = &#x27;Function \&#x27;&#x27; + name + &#x27;\&#x27; should be written in BEM (Block Element Modifier) format&#x27;;
      }
      break;
    case &#x27;hyphenatedbem&#x27;:
      if (!helpers.isHyphenatedBEM(strippedName)) {
        violationMessage = &#x27;Function \&#x27;&#x27; + name + &#x27;\&#x27; should be written in hyphenated BEM (Block Element Modifier) format&#x27;;
      }
      break;
    default:
      if (!(new RegExp(parser.options.convention).test(strippedName))) {
        violationMessage = &#x27;Function \&#x27;&#x27; + name + &#x27;\&#x27; should match regular expression /&#x27; + parser.options.convention + &#x27;/&#x27;;

        // convention-message overrides violationMessage
        if (parser.options[&#x27;convention-explanation&#x27;]) {
          violationMessage = parser.options[&#x27;convention-explanation&#x27;];
        }
      }
    }

    if (violationMessage) {
      result = helpers.addUnique(result, {
        &#x27;ruleId&#x27;: parser.rule.name,
        &#x27;line&#x27;: node.start.line,
        &#x27;column&#x27;: node.start.column,
        &#x27;message&#x27;: violationMessage,
        &#x27;severity&#x27;: parser.severity
      });
    }
  });

  return result;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  }

  if (ast.content &#x26;&#x26; ast.content.length &#x3e; 0) {
ruleToggles = getToggledRules(ast);
isEnabledFilter = isResultEnabled(ruleToggles);

rules.forEach(function (rule) {
  detects = rule.rule.<span class="apidocCodeKeywordSpan">detect</span>(ast, rule)
    .filter(isEnabledFilter);
  results = results.concat(detects);
  if (detects.length) {
    if (rule.severity === 1) {
      warnings += detects.length;
    }
    else if (rule.severity === 2) {
...</pre></li>
    </ul>






</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.sass-lint.helpers" id="apidoc.module.sass-lint.helpers">module sass-lint.helpers</a></h1>


    <h2>
        <a href="#apidoc.element.sass-lint.helpers.addUnique" id="apidoc.element.sass-lint.helpers.addUnique">
        function <span class="apidocSignatureSpan">sass-lint.helpers.</span>addUnique
        <span class="apidocSignatureSpan">(results, item)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">addUnique = function (results, item) {
  if (this.isUnique(results, item)) {
    results.push(item);
  }
  return results;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
&#x27;include&#x27;: true
  },
  &#x27;detect&#x27;: function (ast, parser) {
var result = [];

ast.traverseByType(&#x27;attributeValue&#x27;, function (item) {
  if (item.content[0].is(&#x27;string&#x27;) &#x26;&#x26; !parser.options.include) {
    result = helpers.<span class="apidocCodeKeywordSpan">addUnique</span>(result, {
      &#x27;ruleId&#x27;: parser.rule.name,
      &#x27;line&#x27;: item.start.line,
      &#x27;column&#x27;: item.start.column,
      &#x27;message&#x27;: &#x27;Attribute values should not be surrounded by quotes&#x27;,
      &#x27;severity&#x27;: parser.severity
    });
  }
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.sass-lint.helpers.attemptTraversal" id="apidoc.element.sass-lint.helpers.attemptTraversal">
        function <span class="apidocSignatureSpan">sass-lint.helpers.</span>attemptTraversal
        <span class="apidocSignatureSpan">(node, traversalPath)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">attemptTraversal = function (node, traversalPath) {
  var i,
      nextNodeList,
      currentNodeList = [],
      processChildNode = function processChildNode (child) {
        child.forEach(traversalPath[i], function (n) {
          nextNodeList.push(n);
        });
      };

  node.forEach(traversalPath[0], function (n) {
    currentNodeList.push(n);
  });

  for (i = 1; i &#x3c; traversalPath.length; i++) {
    if (currentNodeList.length === 0) {
      return [];
    }

    nextNodeList = [];
    currentNodeList.forEach(processChildNode);
    currentNodeList = nextNodeList;
  }
  return currentNodeList;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * Collects all suffix extensions for a selector
 * @param   {object}  ruleset      ASTNode of type ruleset, containing a selector with nested suffix extensions
 * @param   {string}  selectorType Node type of the selector (e.g. class, id)
 * @returns {array}                Array of Nodes with the content property replaced by the complete selector
 *                                       (without &#x27;.&#x27;, &#x27;#&#x27;, etc) resulting from suffix extensions
 */
helpers.collectSuffixExtensions = function (ruleset, selectorType) {
var parentSelectors = helpers.<span class="apidocCodeKeywordSpan">attemptTraversal</span>(ruleset, [&#x27;selector&#x27;, selectorType
, &#x27;ident&#x27;]),
    childSuffixes = helpers.attemptTraversal(ruleset, [&#x27;block&#x27;, &#x27;ruleset&#x27;]),
    selectorList = [];

if (parentSelectors.length === 0) {
  return [];
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.sass-lint.helpers.collectSuffixExtensions" id="apidoc.element.sass-lint.helpers.collectSuffixExtensions">
        function <span class="apidocSignatureSpan">sass-lint.helpers.</span>collectSuffixExtensions
        <span class="apidocSignatureSpan">(ruleset, selectorType)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">collectSuffixExtensions = function (ruleset, selectorType) {
  var parentSelectors = helpers.attemptTraversal(ruleset, [&#x27;selector&#x27;, selectorType, &#x27;ident&#x27;]),
      childSuffixes = helpers.attemptTraversal(ruleset, [&#x27;block&#x27;, &#x27;ruleset&#x27;]),
      selectorList = [];

  if (parentSelectors.length === 0) {
    return [];
  }

  // Goes recursively through all nodes that look like suffix extensions. There may be multiple parents that are
  // extended, so lots of looping is required.
  var processChildSuffix = function (child, parents) {
    var currentParents = [],
        selectors = helpers.attemptTraversal(child, [&#x27;selector&#x27;, &#x27;parentSelectorExtension&#x27;, &#x27;ident&#x27;]),
        nestedChildSuffixes = helpers.attemptTraversal(child, [&#x27;block&#x27;, &#x27;ruleset&#x27;]);

    selectors.forEach(function (childSuffixNode) {
      // append suffix extension to all parent selectors
      parents.forEach(function (parent) {
        // clone so we don&#x27;t modify the actual AST
        var clonedChildSuffixNode = gonzales.createNode(childSuffixNode);
        clonedChildSuffixNode.content = parent.content + clonedChildSuffixNode.content;

        currentParents.push(clonedChildSuffixNode);
      });
    });

    selectorList = selectorList.concat(currentParents);

    nestedChildSuffixes.forEach(function (childSuffix) {
      processChildSuffix(childSuffix, currentParents);
    });
  };

  childSuffixes.forEach(function (childSuffix) {
    processChildSuffix(childSuffix, parentSelectors);
  });

  return parentSelectors.concat(selectorList);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
      depth, &#x27; were found.&#x27;].join(&#x27;&#x27;),
    &#x27;severity&#x27;: parser.severity
  });
}
        }
      }
      else {
        selectorAndExtensions = helpers.<span class="apidocCodeKeywordSpan">collectSuffixExtensions</span>(node, &#x27;class&#x27
;);

        selectorAndExtensions.forEach(function (selector) {
name = selector.content;
depth = bemDepth(name);

if (depth &#x3e; maxDepth) {
  result = helpers.addUnique(result, {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.sass-lint.helpers.hasEOL" id="apidoc.element.sass-lint.helpers.hasEOL">
        function <span class="apidocSignatureSpan">sass-lint.helpers.</span>hasEOL
        <span class="apidocSignatureSpan">(str)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">hasEOL = function (str) {
  return /\r\n|\n/.test(str);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 */
var isClosingBraceOnNewLine = function (node) {
  if (node.contains(&#x27;block&#x27;)) {
    var content = node.first(&#x27;block&#x27;),
        contentLength = content.length - 1,
        lastNode = content.get(contentLength);

    if (lastNode &#x26;&#x26; lastNode.is(&#x27;space&#x27;) &#x26;&#x26; helpers.<span class="apidocCodeKeywordSpan">hasEOL</span
>(lastNode.content)) {
      return true;
    }
    return false;
  }
  return null;
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.sass-lint.helpers.isCamelCase" id="apidoc.element.sass-lint.helpers.isCamelCase">
        function <span class="apidocSignatureSpan">sass-lint.helpers.</span>isCamelCase
        <span class="apidocSignatureSpan">(str)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isCamelCase = function (str) {
  return /^[a-z][a-zA-Z0-9]*$/.test(str);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
switch (parser.options.convention) {
case &#x27;hyphenatedlowercase&#x27;:
  if (!helpers.isHyphenatedLowercase(strippedName)) {
    violationMessage = &#x27;Class \&#x27;.&#x27; + name + &#x27;\&#x27; should be written in lowercase with hyphens&#x27;;
  }
  break;
case &#x27;camelcase&#x27;:
  if (!helpers.<span class="apidocCodeKeywordSpan">isCamelCase</span>(strippedName)) {
    violationMessage = &#x27;Class \&#x27;.&#x27; + name + &#x27;\&#x27; should be written in camelCase&#x27;;
  }
  break;
case &#x27;pascalcase&#x27;:
  if (!helpers.isPascalCase(strippedName)) {
    violationMessage = &#x27;Class \&#x27;.&#x27; + name + &#x27;\&#x27; should be written in PascalCase&#x27;;
  }
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.sass-lint.helpers.isEmptyLine" id="apidoc.element.sass-lint.helpers.isEmptyLine">
        function <span class="apidocSignatureSpan">sass-lint.helpers.</span>isEmptyLine
        <span class="apidocSignatureSpan">(str)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isEmptyLine = function (str) {
  return /(\r\n|\n){2}/.test(str);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

if (i &#x3e;= 2) {
  doublePrevious = parent.content[i - 2];

  // First check to see that the previous line is not a new line as if it is
  // we don&#x27;t want to recursively run the function again

  if (!helpers.<span class="apidocCodeKeywordSpan">isEmptyLine</span>(previous.content)) {
    if (doublePrevious.type.indexOf(&#x27;Comment&#x27;) !== -1) {
      return findNearestReturnSCSS(parent, i - 1);
    }
  }
}

if (i &#x3e;= 1) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.sass-lint.helpers.isEqual" id="apidoc.element.sass-lint.helpers.isEqual">
        function <span class="apidocSignatureSpan">sass-lint.helpers.</span>isEqual
        <span class="apidocSignatureSpan">(a, b)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isEqual = function (a, b) {
  var startLine = a.start.line === b.start.line ? true : false,
      endLine = a.end.line === b.end.line ? true : false,
      type = a.type === b.type ? true : false,
      length = a.content.length === b.content.length ? true : false;

  if (startLine &#x26;&#x26; endLine &#x26;&#x26; type &#x26;&#x26; length) {
    return true;
  }
  else {
    return false;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    empty = false;

if (block.content.length === 0) {
  empty = true;
}
else {
  block.traverse(function (item) {
    if (!helpers.<span class="apidocCodeKeywordSpan">isEqual</span>(block, item)) {
      if (item.type !== &#x27;space&#x27;) {
        nonSpaceCount++;
      }
    }
  });
  if (nonSpaceCount === 0) {
    empty = true;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.sass-lint.helpers.isHyphenatedBEM" id="apidoc.element.sass-lint.helpers.isHyphenatedBEM">
        function <span class="apidocSignatureSpan">sass-lint.helpers.</span>isHyphenatedBEM
        <span class="apidocSignatureSpan">(str)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isHyphenatedBEM = function (str) {
  return !(/[A-Z]|-{3}|_{3}|[^_]_[^_]/.test(str));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  break;
case &#x27;strictbem&#x27;:
  if (!helpers.isStrictBEM(strippedName)) {
    violationMessage = &#x27;Class \&#x27;.&#x27; + name + &#x27;\&#x27; should be written in BEM (Block Element Modifier) format
&#x27;;
  }
  break;
case &#x27;hyphenatedbem&#x27;:
  if (!helpers.<span class="apidocCodeKeywordSpan">isHyphenatedBEM</span>(strippedName)) {
    violationMessage = &#x27;Class \&#x27;.&#x27; + name + &#x27;\&#x27; should be written in hyphenated BEM (Block Element Modifier
) format&#x27;;
  }
  break;
default:
  if (!(new RegExp(parser.options.convention).test(strippedName))) {
    violationMessage = &#x27;Class \&#x27;.&#x27; + name + &#x27;\&#x27; should match regular expression /&#x27; + parser.options
.convention + &#x27;/&#x27;;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.sass-lint.helpers.isHyphenatedLowercase" id="apidoc.element.sass-lint.helpers.isHyphenatedLowercase">
        function <span class="apidocSignatureSpan">sass-lint.helpers.</span>isHyphenatedLowercase
        <span class="apidocSignatureSpan">(str)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isHyphenatedLowercase = function (str) {
  return !(/[^\-a-z0-9]/.test(str));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

if (parser.options[&#x27;allow-leading-underscore&#x27;] &#x26;&#x26; name[0] === &#x27;_&#x27;) {
  strippedName = name.slice(1);
}

switch (parser.options.convention) {
case &#x27;hyphenatedlowercase&#x27;:
  if (!helpers.<span class="apidocCodeKeywordSpan">isHyphenatedLowercase</span>(strippedName)) {
    violationMessage = &#x27;Class \&#x27;.&#x27; + name + &#x27;\&#x27; should be written in lowercase with hyphens&#x27;;
  }
  break;
case &#x27;camelcase&#x27;:
  if (!helpers.isCamelCase(strippedName)) {
    violationMessage = &#x27;Class \&#x27;.&#x27; + name + &#x27;\&#x27; should be written in camelCase&#x27;;
  }
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.sass-lint.helpers.isLowerCase" id="apidoc.element.sass-lint.helpers.isLowerCase">
        function <span class="apidocSignatureSpan">sass-lint.helpers.</span>isLowerCase
        <span class="apidocSignatureSpan">(str)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isLowerCase = function (str) {
  var pieces = str.split(&#x27;&#x27;),
      i,
      result = 0;

  for (i = 0; i &#x3c; pieces.length; i++) {
    if (!helpers.isNumber(pieces[i])) {
      if (pieces[i] === pieces[i].toLowerCase() &#x26;&#x26; pieces[i] !== pieces[i].toUpperCase()) {
        result++;
      }
      else {
        return false;
      }
    }
  }
  if (result) {
    return true;
  }
  return false;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  },
  &#x27;detect&#x27;: function (ast, parser) {
var result = [];

ast.traverseByType(&#x27;color&#x27;, function (value) {
  if (value.content.match(/[a-z]/i)) {
    if (parser.options.style === &#x27;lowercase&#x27;) {
      if (!helpers.<span class="apidocCodeKeywordSpan">isLowerCase</span>(value.content)) {
        result = helpers.addUnique(result, {
          &#x27;ruleId&#x27;: parser.rule.name,
          &#x27;line&#x27;: value.start.line,
          &#x27;column&#x27;: value.start.column,
          &#x27;message&#x27;: &#x27;Hex notation should all be lower case&#x27;,
          &#x27;severity&#x27;: parser.severity
        });
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.sass-lint.helpers.isNestable" id="apidoc.element.sass-lint.helpers.isNestable">
        function <span class="apidocSignatureSpan">sass-lint.helpers.</span>isNestable
        <span class="apidocSignatureSpan">(currentVal, previousVal, elements, nestable)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isNestable = function (currentVal, previousVal, elements, nestable) {
  // check if they are nestable by checking the previous element against one
  // of the user specified selector types
  if (elements.indexOf(previousVal) !== -1 &#x26;&#x26; nestable.indexOf(currentVal) !== -1) {
    return true;
  }

  return false;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

    ast.traverseByType(&#x27;ruleset&#x27;, function (ruleset) {

ruleset.forEach(&#x27;selector&#x27;, function (selector) {
  var previousVal;
  selector.forEach(function (item) {
    if (previousVal) {
      if (helpers.<span class="apidocCodeKeywordSpan">isNestable</span>(item.type, previousVal.type, elements, nestableAttributes
)) {
        helpers.addUnique(result, {
          &#x27;ruleId&#x27;: parser.rule.name,
          &#x27;line&#x27;: selector.start.line,
          &#x27;column&#x27;: selector.start.column,
          &#x27;message&#x27;: formatOutput(item.type) + &#x27; should be nested within its parent &#x27; + formatOutput(previousVal
.type),
          &#x27;severity&#x27;: parser.severity
        });
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.sass-lint.helpers.isNewLine" id="apidoc.element.sass-lint.helpers.isNewLine">
        function <span class="apidocSignatureSpan">sass-lint.helpers.</span>isNewLine
        <span class="apidocSignatureSpan">(node)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isNewLine = function (node) {
  // using type === instead of is just in case node happens to be a string
  return !!(node &#x26;&#x26; node.type === &#x27;space&#x27; &#x26;&#x26; node.content.match(&#x27;\n&#x27;));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
      plural = level &#x3e; 1 ? &#x27;s&#x27; : &#x27;&#x27;;
      reportNode = nextNode;
      reportCondition = i !== node.length - 1;
    }
  }
}
else if (n.syntax === &#x27;sass&#x27;) {
  if (n.is(&#x27;declarationDelimiter&#x27;) || (helpers.<span class="apidocCodeKeywordSpan">isNewLine</span>(n))) {
    // Due to the way gonzales handles line endings in Sass we don&#x27;t care if it&#x27;s CRLF or just LF
    if (nextNode &#x26;&#x26; nextNode.is(&#x27;space&#x27;) &#x26;&#x26; nextNode.content.indexOf(&#x27;\n&#x27;) === -1) {
      spaceLength = nextNode.content.length;
      spaceCount = nextNode.content.match(/ /g);
      tabCount = nextNode.content.match(/\t/g);
      plural = level &#x3e; 1 ? &#x27;s&#x27; : &#x27;&#x27;;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.sass-lint.helpers.isNumber" id="apidoc.element.sass-lint.helpers.isNumber">
        function <span class="apidocSignatureSpan">sass-lint.helpers.</span>isNumber
        <span class="apidocSignatureSpan">(val)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isNumber = function (val) {
  if (isNaN(parseInt(val, 10))) {
    return false;
  }
  return true;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

helpers.isUpperCase = function (str) {
var pieces = str.split(&#x27;&#x27;),
    i,
    result = 0;

for (i = 0; i &#x3c; pieces.length; i++) {
  if (!helpers.<span class="apidocCodeKeywordSpan">isNumber</span>(pieces[i])) {
    if (pieces[i] === pieces[i].toUpperCase() &#x26;&#x26; pieces[i] !== pieces[i].toLowerCase()) {
      result++;
    }
    else {
      return false;
    }
  }
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.sass-lint.helpers.isPartialStringMatch" id="apidoc.element.sass-lint.helpers.isPartialStringMatch">
        function <span class="apidocSignatureSpan">sass-lint.helpers.</span>isPartialStringMatch
        <span class="apidocSignatureSpan">(needle, haystack)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isPartialStringMatch = function (needle, haystack) {
  for (var i = 0; i &#x3c; haystack.length; i++) {
    if (haystack[i].indexOf(needle) &#x3e;= 0) {
      return true;
    }
  }

  return false;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var curProperty = node.first().content,
    propertyList = getCombinedList(properties, parser.options[&#x27;extra-properties&#x27;]);

if (curProperty.charAt(0) === &#x27;-&#x27;) {
  curProperty = helpers.stripPrefix(curProperty);
}

if (helpers.<span class="apidocCodeKeywordSpan">isPartialStringMatch</span>(curProperty, propertyList)) {
  return false;
}

if (curProperty.length &#x3e; 0) {
  result = helpers.addUnique(result, {
    &#x27;ruleId&#x27;: parser.rule.name,
    &#x27;line&#x27;: node.start.line,
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.sass-lint.helpers.isPascalCase" id="apidoc.element.sass-lint.helpers.isPascalCase">
        function <span class="apidocSignatureSpan">sass-lint.helpers.</span>isPascalCase
        <span class="apidocSignatureSpan">(str)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isPascalCase = function (str) {
  return /^[A-Z][a-zA-Z0-9]*$/.test(str);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  break;
case &#x27;camelcase&#x27;:
  if (!helpers.isCamelCase(strippedName)) {
    violationMessage = &#x27;Class \&#x27;.&#x27; + name + &#x27;\&#x27; should be written in camelCase&#x27;;
  }
  break;
case &#x27;pascalcase&#x27;:
  if (!helpers.<span class="apidocCodeKeywordSpan">isPascalCase</span>(strippedName)) {
    violationMessage = &#x27;Class \&#x27;.&#x27; + name + &#x27;\&#x27; should be written in PascalCase&#x27;;
  }
  break;
case &#x27;snakecase&#x27;:
  if (!helpers.isSnakeCase(strippedName)) {
    violationMessage = &#x27;Class \&#x27;.&#x27; + name + &#x27;\&#x27; should be written in snake_case&#x27;;
  }
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.sass-lint.helpers.isSnakeCase" id="apidoc.element.sass-lint.helpers.isSnakeCase">
        function <span class="apidocSignatureSpan">sass-lint.helpers.</span>isSnakeCase
        <span class="apidocSignatureSpan">(str)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isSnakeCase = function (str) {
  return !(/[^_a-z0-9]/.test(str));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  break;
case &#x27;pascalcase&#x27;:
  if (!helpers.isPascalCase(strippedName)) {
    violationMessage = &#x27;Class \&#x27;.&#x27; + name + &#x27;\&#x27; should be written in PascalCase&#x27;;
  }
  break;
case &#x27;snakecase&#x27;:
  if (!helpers.<span class="apidocCodeKeywordSpan">isSnakeCase</span>(strippedName)) {
    violationMessage = &#x27;Class \&#x27;.&#x27; + name + &#x27;\&#x27; should be written in snake_case&#x27;;
  }
  break;
case &#x27;strictbem&#x27;:
  if (!helpers.isStrictBEM(strippedName)) {
    violationMessage = &#x27;Class \&#x27;.&#x27; + name + &#x27;\&#x27; should be written in BEM (Block Element Modifier) format
&#x27;;
  }
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.sass-lint.helpers.isSpace" id="apidoc.element.sass-lint.helpers.isSpace">
        function <span class="apidocSignatureSpan">sass-lint.helpers.</span>isSpace
        <span class="apidocSignatureSpan">(node)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isSpace = function (node) {
  return !!(node &#x26;&#x26; node.type === &#x27;space&#x27; &#x26;&#x26; !node.content.match(&#x27;\n&#x27;));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    }

    reportNode = sassNextNode;
    reportCondition = true;
  }
}
// Check all the spaces in Sass that aren&#x27;t newlines
else if (helpers.<span class="apidocCodeKeywordSpan">isSpace</span>(n)) {
  // This is a special condition for the first property in a block with Sass as it usually
  // doesn&#x27;t have a previous node before the space appears so we need to check this is
  // valid and then we can rely on the declarationDelimiter check above.
  if (inBlock &#x26;&#x26; (!prevNode || prevNode.is(&#x27;space&#x27;))) {
    inBlock = false;
    spaceLength = n.content.length;
    spaceCount = n.content.match(/ /g);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.sass-lint.helpers.isStrictBEM" id="apidoc.element.sass-lint.helpers.isStrictBEM">
        function <span class="apidocSignatureSpan">sass-lint.helpers.</span>isStrictBEM
        <span class="apidocSignatureSpan">(str)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isStrictBEM = function (str) {
  return /^[a-z](\-?[a-z0-9]+)*(__[a-z0-9](\-?[a-z0-9]+)*)?((_[a-z0-9](\-?[a-z0-9]+)*){0,2})?$/.test(str);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  break;
case &#x27;snakecase&#x27;:
  if (!helpers.isSnakeCase(strippedName)) {
    violationMessage = &#x27;Class \&#x27;.&#x27; + name + &#x27;\&#x27; should be written in snake_case&#x27;;
  }
  break;
case &#x27;strictbem&#x27;:
  if (!helpers.<span class="apidocCodeKeywordSpan">isStrictBEM</span>(strippedName)) {
    violationMessage = &#x27;Class \&#x27;.&#x27; + name + &#x27;\&#x27; should be written in BEM (Block Element Modifier) format
&#x27;;
  }
  break;
case &#x27;hyphenatedbem&#x27;:
  if (!helpers.isHyphenatedBEM(strippedName)) {
    violationMessage = &#x27;Class \&#x27;.&#x27; + name + &#x27;\&#x27; should be written in hyphenated BEM (Block Element Modifier
) format&#x27;;
  }
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.sass-lint.helpers.isUnique" id="apidoc.element.sass-lint.helpers.isUnique">
        function <span class="apidocSignatureSpan">sass-lint.helpers.</span>isUnique
        <span class="apidocSignatureSpan">(results, item)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isUnique = function (results, item) {
  var search = this.propertySearch(results, item.line, &#x27;line&#x27;);

  if (search === -1) {
    return true;
  }
  else if (results[search].column === item.column &#x26;&#x26; results[search].message === item.message) {
    return false;
  }
  else {
    return true;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
}
else {
  return true;
}
};

helpers.addUnique = function (results, item) {
if (this.<span class="apidocCodeKeywordSpan">isUnique</span>(results, item)) {
  results.push(item);
}
return results;
};

helpers.sortDetects = function (a, b) {
if (a.line &#x3c; b.line) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.sass-lint.helpers.isUpperCase" id="apidoc.element.sass-lint.helpers.isUpperCase">
        function <span class="apidocSignatureSpan">sass-lint.helpers.</span>isUpperCase
        <span class="apidocSignatureSpan">(str)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isUpperCase = function (str) {
  var pieces = str.split(&#x27;&#x27;),
      i,
      result = 0;

  for (i = 0; i &#x3c; pieces.length; i++) {
    if (!helpers.isNumber(pieces[i])) {
      if (pieces[i] === pieces[i].toUpperCase() &#x26;&#x26; pieces[i] !== pieces[i].toLowerCase()) {
        result++;
      }
      else {
        return false;
      }
    }
  }
  if (result) {
    return true;
  }
  return false;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
      &#x27;column&#x27;: value.start.column,
      &#x27;message&#x27;: &#x27;Hex notation should all be lower case&#x27;,
      &#x27;severity&#x27;: parser.severity
    });
  }
}
else if (parser.options.style === &#x27;uppercase&#x27;) {
  if (!helpers.<span class="apidocCodeKeywordSpan">isUpperCase</span>(value.content)) {
    result = helpers.addUnique(result, {
      &#x27;ruleId&#x27;: parser.rule.name,
      &#x27;line&#x27;: value.start.line,
      &#x27;column&#x27;: value.start.column,
      &#x27;message&#x27;: &#x27;Hex notation should all be upper case&#x27;,
      &#x27;severity&#x27;: parser.severity
    });
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.sass-lint.helpers.isValidHex" id="apidoc.element.sass-lint.helpers.isValidHex">
        function <span class="apidocSignatureSpan">sass-lint.helpers.</span>isValidHex
        <span class="apidocSignatureSpan">(str)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isValidHex = function (str) {
  if (str.match(/^([A-Fa-f0-9]{6}|[A-Fa-f0-9]{3})$/)) {
    return true;
  }
  return false;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* Check if the value is a color literal
*
* @param {Object} node - The node we&#x27;re checking
* @param {Array} validColorFunctions - The array of valid color function types to check against
* @returns {boolean} Whether the node matches the specified types
*/
var checkIsLiteral = function (node, validColorFunctions) {
 return cssColors.indexOf(node.content) !== -1 || helpers.<span class="apidocCodeKeywordSpan">isValidHex</span>(node.content) ||
validColorFunctions.indexOf(node.content) !== -1;
};

/**
* Checks the see if the node type is a hex value if so return the correct prefix
*
* @param {String} nodeType - The node type identifier
* @returns {String} Either a &#x27;#&#x27; or an empty string
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.sass-lint.helpers.loadConfigFile" id="apidoc.element.sass-lint.helpers.loadConfigFile">
        function <span class="apidocSignatureSpan">sass-lint.helpers.</span>loadConfigFile
        <span class="apidocSignatureSpan">(configPath)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">loadConfigFile = function (configPath) {
  var fileDir = path.dirname(configPath),
      fileName = path.basename(configPath),
      fileExtension = path.extname(fileName),
      filePath = path.join(__dirname, &#x27;config&#x27;, fileDir, fileName),
      file = fs.readFileSync(filePath, &#x27;utf8&#x27;) || false;

  if (file) {
    if (fileExtension === &#x27;.yml&#x27;) {
      return yaml.safeLoad(file);
    }
  }

  return file;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  &#x27;concentric&#x27;: &#x27;concentric.yml&#x27;
};

var getOrderConfig = function (order) {
  if (typeof order === &#x27;string&#x27;) {
    if (orderPresets.hasOwnProperty(order)) {
      var filename = orderPresets[order],
          orderConfig = helpers.<span class="apidocCodeKeywordSpan">loadConfigFile</span>(&#x27;property-sort-orders/&#x27; + filename
);

      return orderConfig.order;
    }
  }

  return false;
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.sass-lint.helpers.log" id="apidoc.element.sass-lint.helpers.log">
        function <span class="apidocSignatureSpan">sass-lint.helpers.</span>log
        <span class="apidocSignatureSpan">(input)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function log(input) {
  console.log(util.inspect(input, false, null));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  if (this.resultCount(results)) {

var formatted = this.format(results, options, configPath);

if (config.options[&#x27;output-file&#x27;]) {
  try {
    fs.outputFileSync(path.resolve(process.cwd(), config.options[&#x27;output-file&#x27;]), formatted);
    console.<span class="apidocCodeKeywordSpan">log</span>(&#x27;Output successfully written to &#x27; + path.resolve(process.cwd
(), config.options[&#x27;output-file&#x27;]));
  }
  catch (e) {
    console.log(&#x27;Error: Output was unable to be written to &#x27; + path.resolve(process.cwd(), config.options[&#x27;output
-file&#x27;]));
  }
}
else {
  console.log(formatted);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.sass-lint.helpers.propertySearch" id="apidoc.element.sass-lint.helpers.propertySearch">
        function <span class="apidocSignatureSpan">sass-lint.helpers.</span>propertySearch
        <span class="apidocSignatureSpan">(haystack, needle, property)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">propertySearch = function (haystack, needle, property) {
  var length = haystack.length,
      i;

  for (i = 0; i &#x3c; length; i++) {
    if (haystack[i][property] === needle) {
      return i;
    }
  }
  return -1;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
}
else {
  return false;
}
};

helpers.isUnique = function (results, item) {
var search = this.<span class="apidocCodeKeywordSpan">propertySearch</span>(results, item.line, &#x27;line&#x27;);

if (search === -1) {
  return true;
}
else if (results[search].column === item.column &#x26;&#x26; results[search].message === item.message) {
  return false;
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.sass-lint.helpers.sortDetects" id="apidoc.element.sass-lint.helpers.sortDetects">
        function <span class="apidocSignatureSpan">sass-lint.helpers.</span>sortDetects
        <span class="apidocSignatureSpan">(a, b)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">sortDetects = function (a, b) {
  if (a.line &#x3c; b.line) {
    return -1;
  }
  if (a.line &#x3e; b.line) {
    return 1;
  }
  if (a.line === b.line) {
    if (a.column &#x3c; b.column) {
      return -1;
    }
    if (a.column &#x3e; b.column) {
      return 1;
    }
    return 0;
  }
  return 0;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.sass-lint.helpers.stripBom" id="apidoc.element.sass-lint.helpers.stripBom">
        function <span class="apidocSignatureSpan">sass-lint.helpers.</span>stripBom
        <span class="apidocSignatureSpan">(str)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">stripBom = function (str) {
  if (typeof str !== &#x27;string&#x27;) {
    throw new TypeError(&#x27;Expected a string, got &#x27; + typeof str);
  }

  if (str.charCodeAt(0) === 0xFEFF) {
    return str.slice(1);
  }

  return str;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var fm = require(&#x27;front-matter&#x27;);
var helpers = require(&#x27;./helpers&#x27;);

module.exports = function (text, syntax, filename) {
var tree;

// Run `.toString()` to allow Buffers to be passed in
text = helpers.<span class="apidocCodeKeywordSpan">stripBom</span>(text.toString());

// if we&#x27;re skipping front matter do it here, fall back to just our text in case it fails
if (fm.test(text)) {
  text = fm(text).body || text;
}

try {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.sass-lint.helpers.stripLastSpace" id="apidoc.element.sass-lint.helpers.stripLastSpace">
        function <span class="apidocSignatureSpan">sass-lint.helpers.</span>stripLastSpace
        <span class="apidocSignatureSpan">(selector)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">stripLastSpace = function (selector) {

  if (selector.charAt(selector.length - 1) === &#x27; &#x27;) {
    return selector.substr(0, selector.length - 1);

  }

  return selector;

}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * @param {string} line - The line that the ruleset starts
 * @param {string} col - The column that the ruleset starts
 * @returns {undefined}
 */
var updateList = function (ruleSet, isAtRule, line, col) {
  parentSelector[curLevel] = ruleSet;
  curSelector = {
    selector: helpers.<span class="apidocCodeKeywordSpan">stripLastSpace</span>(parentSelector.join(&#x27;&#x27;)),
    line: line,
    column: col
  };
  if (!isAtRule) {
    selectorList.push(curSelector);
  }
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.sass-lint.helpers.stripPrefix" id="apidoc.element.sass-lint.helpers.stripPrefix">
        function <span class="apidocSignatureSpan">sass-lint.helpers.</span>stripPrefix
        <span class="apidocSignatureSpan">(str)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">stripPrefix = function (str) {
  var modPropertyArr = str.split(&#x27;-&#x27;),
      modProperty = &#x27;&#x27;,
      prefLength = modPropertyArr[2] === &#x27;osx&#x27; ? 2 : 1;

  modPropertyArr.splice(1, prefLength);

  modPropertyArr.forEach(function (item, index) {
    modProperty = modProperty + item;
    if (index &#x3e; 0 &#x26;&#x26; index &#x3c; modPropertyArr.length - 1) {
      modProperty = modProperty + &#x27;-&#x27;;
    }
  });

  return modProperty;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

    ast.traverseByType(&#x27;property&#x27;, function (node) {
      if (node.first().is(&#x27;ident&#x27;)) {
var curProperty = node.first().content,
    propertyList = getCombinedList(properties, parser.options[&#x27;extra-properties&#x27;]);

if (curProperty.charAt(0) === &#x27;-&#x27;) {
  curProperty = helpers.<span class="apidocCodeKeywordSpan">stripPrefix</span>(curProperty);
}

if (helpers.isPartialStringMatch(curProperty, propertyList)) {
  return false;
}

if (curProperty.length &#x3e; 0) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.sass-lint.helpers.stripQuotes" id="apidoc.element.sass-lint.helpers.stripQuotes">
        function <span class="apidocSignatureSpan">sass-lint.helpers.</span>stripQuotes
        <span class="apidocSignatureSpan">(str)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">stripQuotes = function (str) {
  return str.substring(1, str.length - 1);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

var getImportPath = function (parent, syntax) {
  if (parent.first(&#x27;uri&#x27;)) {
return parent.first(&#x27;uri&#x27;);
  }

  if (parent.first(&#x27;string&#x27;)) {
return helpers.<span class="apidocCodeKeywordSpan">stripQuotes</span>(parent.first(&#x27;string&#x27;).content);
  }

  if (parent.first(&#x27;ident&#x27;)) {

if (syntax === &#x27;sass&#x27;) {
  var output = &#x27;&#x27;,
      isFinished = false;
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.sass-lint.hex_length" id="apidoc.module.sass-lint.hex_length">module sass-lint.hex_length</a></h1>


    <h2>
        <a href="#apidoc.element.sass-lint.hex_length.detect" id="apidoc.element.sass-lint.hex_length.detect">
        function <span class="apidocSignatureSpan">sass-lint.hex_length.</span>detect
        <span class="apidocSignatureSpan">(ast, parser)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">detect = function (ast, parser) {
  var result = [];

  ast.traverseByType(&#x27;color&#x27;, function (value) {
    if (parser.options.style === &#x27;short&#x27; &#x26;&#x26; canShorten(value.content)) {
      result = helpers.addUnique(result, {
        &#x27;ruleId&#x27;: parser.rule.name,
        &#x27;line&#x27;: value.start.line,
        &#x27;column&#x27;: value.start.column,
        &#x27;message&#x27;: &#x27;Hex values should use the shorthand format - 3 characters where possible&#x27;,
        &#x27;severity&#x27;: parser.severity
      });
    }
    else if (parser.options.style === &#x27;long&#x27;) {
      if (value.content.length !== lengths.long) {
        result = helpers.addUnique(result, {
          &#x27;ruleId&#x27;: parser.rule.name,
          &#x27;line&#x27;: value.start.line,
          &#x27;column&#x27;: value.start.column,
          &#x27;message&#x27;: &#x27;Hex values should use the long-form format - 6 characters&#x27;,
          &#x27;severity&#x27;: parser.severity
        });
      }
    }
  });

  return result;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  }

  if (ast.content &#x26;&#x26; ast.content.length &#x3e; 0) {
ruleToggles = getToggledRules(ast);
isEnabledFilter = isResultEnabled(ruleToggles);

rules.forEach(function (rule) {
  detects = rule.rule.<span class="apidocCodeKeywordSpan">detect</span>(ast, rule)
    .filter(isEnabledFilter);
  results = results.concat(detects);
  if (detects.length) {
    if (rule.severity === 1) {
      warnings += detects.length;
    }
    else if (rule.severity === 2) {
...</pre></li>
    </ul>






</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.sass-lint.hex_notation" id="apidoc.module.sass-lint.hex_notation">module sass-lint.hex_notation</a></h1>


    <h2>
        <a href="#apidoc.element.sass-lint.hex_notation.detect" id="apidoc.element.sass-lint.hex_notation.detect">
        function <span class="apidocSignatureSpan">sass-lint.hex_notation.</span>detect
        <span class="apidocSignatureSpan">(ast, parser)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">detect = function (ast, parser) {
  var result = [];

  ast.traverseByType(&#x27;color&#x27;, function (value) {
    if (value.content.match(/[a-z]/i)) {
      if (parser.options.style === &#x27;lowercase&#x27;) {
        if (!helpers.isLowerCase(value.content)) {
          result = helpers.addUnique(result, {
            &#x27;ruleId&#x27;: parser.rule.name,
            &#x27;line&#x27;: value.start.line,
            &#x27;column&#x27;: value.start.column,
            &#x27;message&#x27;: &#x27;Hex notation should all be lower case&#x27;,
            &#x27;severity&#x27;: parser.severity
          });
        }
      }
      else if (parser.options.style === &#x27;uppercase&#x27;) {
        if (!helpers.isUpperCase(value.content)) {
          result = helpers.addUnique(result, {
            &#x27;ruleId&#x27;: parser.rule.name,
            &#x27;line&#x27;: value.start.line,
            &#x27;column&#x27;: value.start.column,
            &#x27;message&#x27;: &#x27;Hex notation should all be upper case&#x27;,
            &#x27;severity&#x27;: parser.severity
          });
        }
      }
    }
  });

  return result;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  }

  if (ast.content &#x26;&#x26; ast.content.length &#x3e; 0) {
ruleToggles = getToggledRules(ast);
isEnabledFilter = isResultEnabled(ruleToggles);

rules.forEach(function (rule) {
  detects = rule.rule.<span class="apidocCodeKeywordSpan">detect</span>(ast, rule)
    .filter(isEnabledFilter);
  results = results.concat(detects);
  if (detects.length) {
    if (rule.severity === 1) {
      warnings += detects.length;
    }
    else if (rule.severity === 2) {
...</pre></li>
    </ul>






</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.sass-lint.id_name_format" id="apidoc.module.sass-lint.id_name_format">module sass-lint.id_name_format</a></h1>


    <h2>
        <a href="#apidoc.element.sass-lint.id_name_format.detect" id="apidoc.element.sass-lint.id_name_format.detect">
        function <span class="apidocSignatureSpan">sass-lint.id_name_format.</span>detect
        <span class="apidocSignatureSpan">(ast, parser)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">detect = function (ast, parser) {
  var result = [];

  ast.traverseByType(&#x27;ruleset&#x27;, function (ruleset) {
    var selectorAndExtensions = helpers.collectSuffixExtensions(ruleset, &#x27;id&#x27;);

    selectorAndExtensions.forEach(function (node) {
      var name = node.content,
          strippedName,
          violationMessage = false;

      if (parser.options.ignore.indexOf(name) !== -1) {
        return;
      }

      strippedName = name;

      if (parser.options[&#x27;allow-leading-underscore&#x27;] &#x26;&#x26; name[0] === &#x27;_&#x27;) {
        strippedName = name.slice(1);
      }

      switch (parser.options.convention) {
      case &#x27;hyphenatedlowercase&#x27;:
        if (!helpers.isHyphenatedLowercase(strippedName)) {
          violationMessage = &#x27;ID \&#x27;#&#x27; + name + &#x27;\&#x27; should be written in lowercase with hyphens&#x27;;
        }
        break;
      case &#x27;camelcase&#x27;:
        if (!helpers.isCamelCase(strippedName)) {
          violationMessage = &#x27;ID \&#x27;#&#x27; + name + &#x27;\&#x27; should be written in camelCase&#x27;;
        }
        break;
      case &#x27;pascalcase&#x27;:
        if (!helpers.isPascalCase(strippedName)) {
          violationMessage = &#x27;ID \&#x27;#&#x27; + name + &#x27;\&#x27; should be written in PascalCase&#x27;;
        }
        break;
      case &#x27;snakecase&#x27;:
        if (!helpers.isSnakeCase(strippedName)) {
          violationMessage = &#x27;ID \&#x27;#&#x27; + name + &#x27;\&#x27; should be written in snake_case&#x27;;
        }
        break;
      default:
        if (!(new RegExp(parser.options.convention).test(strippedName))) {
          violationMessage = &#x27;ID \&#x27;#&#x27; + name + &#x27;\&#x27; should match regular expression /&#x27; + parser.options.convention + &#x27;/&#x27;;

          // convention-message overrides violationMessage
          if (parser.options[&#x27;convention-explanation&#x27;]) {
            violationMessage = parser.options[&#x27;convention-explanation&#x27;];
          }
        }
      }

      if (violationMessage) {
        result = helpers.addUnique(result, {
          &#x27;ruleId&#x27;: parser.rule.name,
          &#x27;line&#x27;: node.start.line,
          &#x27;column&#x27;: node.start.column,
          &#x27;message&#x27;: violationMessage,
          &#x27;severity&#x27;: parser.severity
        });
      }
    });
  });

  return result;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  }

  if (ast.content &#x26;&#x26; ast.content.length &#x3e; 0) {
ruleToggles = getToggledRules(ast);
isEnabledFilter = isResultEnabled(ruleToggles);

rules.forEach(function (rule) {
  detects = rule.rule.<span class="apidocCodeKeywordSpan">detect</span>(ast, rule)
    .filter(isEnabledFilter);
  results = results.concat(detects);
  if (detects.length) {
    if (rule.severity === 1) {
      warnings += detects.length;
    }
    else if (rule.severity === 2) {
...</pre></li>
    </ul>






</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.sass-lint.indentation" id="apidoc.module.sass-lint.indentation">module sass-lint.indentation</a></h1>


    <h2>
        <a href="#apidoc.element.sass-lint.indentation.detect" id="apidoc.element.sass-lint.indentation.detect">
        function <span class="apidocSignatureSpan">sass-lint.indentation.</span>detect
        <span class="apidocSignatureSpan">(ast, parser)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">detect = function (ast, parser) {
  var result = [],
      inAtRule = false,
      inProps = false,
      inBlock = false,
      lintSize = parser.options.size,
      lintType = &#x27;space&#x27;,
      plural = &#x27;&#x27;,
      detected = [lintType];

  // Prepare to check for mixed spaces or tabs depending on what the user has specified
  if (parser.options.size === &#x27;tab&#x27;) {
    lintSize = 1;
    lintType = &#x27;tab&#x27;;
    detected[0] = lintType;
  }

  var processNode = function (node, level) {
    var i,
        n,
        prevNode,
        nextNode,
        sassNextNode,
        reportNode,
        reportCondition,
        space,
        spaceLength,
        newlineLength,
        spaceCount,
        tabCount,
        mixedWarning;

    level = level || 0;

    if (node.is(&#x27;braces&#x27;)) {
      return;
    }

    for (i = 0; i &#x3c; node.length; i++) {
      n = node.get(i);
      prevNode = node.get(i - 1);
      nextNode = node.get(i + 1) || false;
      // Due to the Sass structure in gonzales we sometimes need to check 2 ahead
      sassNextNode = node.get(i + 2) || false;
      reportNode = null;

      if (!n) {
        continue;
      }

      if (n.syntax === &#x27;scss&#x27;) {
        if (n.type === &#x27;space&#x27;) {

          // Test for CRLF first, since it includes LF
          space = n.content.lastIndexOf(&#x27;\r\n&#x27;);
          newlineLength = 2;

          if (space === -1) {
            // Test for LF
            space = n.content.lastIndexOf(&#x27;\n&#x27;);
            newlineLength = 1;
          }

          if (space &#x3e;= 0) {
            // Check how many spaces or tabs we have and set our plural character if necessary for
            // our lint reporting message
            spaceLength = n.content.slice(space + newlineLength).length;
            spaceCount = n.content.slice(space + newlineLength).match(/ /g);
            tabCount = n.content.slice(space + newlineLength).match(/\t/g);
            plural = level &#x3e; 1 ? &#x27;s&#x27; : &#x27;&#x27;;
            reportNode = nextNode;
            reportCondition = i !== node.length - 1;
          }
        }
      }
      else if (n.syntax === &#x27;sass&#x27;) {
        if (n.is(&#x27;declarationDelimiter&#x27;) || (helpers.isNewLine(n))) {
          // Due to the way gonzales handles line endings in Sass we don&#x27;t care if it&#x27;s CRLF or just LF
          if (nextNode &#x26;&#x26; nextNode.is(&#x27;space&#x27;) &#x26;&#x26; nextNode.content.indexOf(&#x27;\n&#x27;) === -1) {
            spaceLength = nextNode.content.length;
            spaceCount = nextNode.content.match(/ /g);
            tabCount = nextNode.content.match(/\t/g);
            plural = level &#x3e; 1 ? &#x27;s&#x27; : &#x27;&#x27;;

            // if we&#x27;re at the end of a block we want to drop the level here for Sass
            if (!node.get(i + 2)) {
              level--;
            }

            reportNode = sassNextNode;
            reportCondition = true;
          }
        }
        // Check all the spaces in Sass that aren&#x27;t newlines
        else if (helpers.isSpace(n)) {
          // This is a special condition for the first property in a block with Sass as it usually
          // doesn&#x27;t have a previous node before the space appears so we need to check this is
          // valid and then we can rely on the declarationDelimiter check above.
          if (inBlock &#x26;&#x26; (!prevNode || prevNode.is(&#x27;space&#x27;))) {
            inBlock = false;
            spaceLength = n.content.length;
            spaceCount = n.content.match(/ /g);
            tabCount = n.content.match(/\t/g);
            plural = level &#x3e; 1 ? &#x27;s&#x27; : &#x27;&#x27;;
            reportNode = nextNode;
            reportCondition = true;
          }
          // A extra check for tabs when using spaces as single tab characters aren&#x27;t highlighted
          // as mixed spaces and tabs without this. Spaces on the other hand are fine. Gonzales
          // reports them a little differently.
          else if (n.type === &#x27;space&#x27; &#x26;&#x26; lintType === &#x27;space&#x27;) {
            tabCount = n.content.match(/\t/g);
            reportNode = nextNode;
            // we dont want to check the lint levels here as it could be a tab between a prop and
            // value, totally unrealistic I know but we still want to repo ...</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  }

  if (ast.content &#x26;&#x26; ast.content.length &#x3e; 0) {
ruleToggles = getToggledRules(ast);
isEnabledFilter = isResultEnabled(ruleToggles);

rules.forEach(function (rule) {
  detects = rule.rule.<span class="apidocCodeKeywordSpan">detect</span>(ast, rule)
    .filter(isEnabledFilter);
  results = results.concat(detects);
  if (detects.length) {
    if (rule.severity === 1) {
      warnings += detects.length;
    }
    else if (rule.severity === 2) {
...</pre></li>
    </ul>






</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.sass-lint.leading_zero" id="apidoc.module.sass-lint.leading_zero">module sass-lint.leading_zero</a></h1>


    <h2>
        <a href="#apidoc.element.sass-lint.leading_zero.detect" id="apidoc.element.sass-lint.leading_zero.detect">
        function <span class="apidocSignatureSpan">sass-lint.leading_zero.</span>detect
        <span class="apidocSignatureSpan">(ast, parser)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">detect = function (ast, parser) {
  var result = [];

  ast.traverseByType(&#x27;number&#x27;, function (num) {
    if (num.content.match(/^-?(0?\.\d+)/)) {
      if (num.content.match(leadingZeroRegex)) {
        if (!parser.options.include) {
          result = helpers.addUnique(result, {
            &#x27;ruleId&#x27;: parser.rule.name,
            &#x27;line&#x27;: num.start.line,
            &#x27;column&#x27;: num.start.column,
            &#x27;message&#x27;: &#x27;Don\&#x27;t include leading zeros on numbers&#x27;,
            &#x27;severity&#x27;: parser.severity
          });
        }
      }
      if (num.content.match(noLeadingZeroRegex)) {
        if (parser.options.include) {
          result = helpers.addUnique(result, {
            &#x27;ruleId&#x27;: parser.rule.name,
            &#x27;line&#x27;: num.start.line,
            &#x27;column&#x27;: num.start.column - 1,
            &#x27;message&#x27;: &#x27;Include leading zeros on numbers&#x27;,
            &#x27;severity&#x27;: parser.severity
          });
        }
      }
    }
  });

  return result;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  }

  if (ast.content &#x26;&#x26; ast.content.length &#x3e; 0) {
ruleToggles = getToggledRules(ast);
isEnabledFilter = isResultEnabled(ruleToggles);

rules.forEach(function (rule) {
  detects = rule.rule.<span class="apidocCodeKeywordSpan">detect</span>(ast, rule)
    .filter(isEnabledFilter);
  results = results.concat(detects);
  if (detects.length) {
    if (rule.severity === 1) {
      warnings += detects.length;
    }
    else if (rule.severity === 2) {
...</pre></li>
    </ul>






</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.sass-lint.max_file_line_count" id="apidoc.module.sass-lint.max_file_line_count">module sass-lint.max_file_line_count</a></h1>


    <h2>
        <a href="#apidoc.element.sass-lint.max_file_line_count.detect" id="apidoc.element.sass-lint.max_file_line_count.detect">
        function <span class="apidocSignatureSpan">sass-lint.max_file_line_count.</span>detect
        <span class="apidocSignatureSpan">(ast, parser)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">detect = function (ast, parser) {
  var result = [];

  if (ast.end.line &#x3e; parser.options.length) {
    result = helpers.addUnique(result, {
      &#x27;ruleId&#x27;: parser.rule.name,
      &#x27;line&#x27;: ast.end.line,
      &#x27;column&#x27;: 0,
      &#x27;message&#x27;: &#x27;This file has &#x27; + ast.end.line + &#x27; lines, which exceeds the maximum of &#x27; + parser.options.length + &#x27; lines allowed
.&#x27;,
      &#x27;severity&#x27;: parser.severity
    });
  }

  return result;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  }

  if (ast.content &#x26;&#x26; ast.content.length &#x3e; 0) {
ruleToggles = getToggledRules(ast);
isEnabledFilter = isResultEnabled(ruleToggles);

rules.forEach(function (rule) {
  detects = rule.rule.<span class="apidocCodeKeywordSpan">detect</span>(ast, rule)
    .filter(isEnabledFilter);
  results = results.concat(detects);
  if (detects.length) {
    if (rule.severity === 1) {
      warnings += detects.length;
    }
    else if (rule.severity === 2) {
...</pre></li>
    </ul>






</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.sass-lint.max_line_length" id="apidoc.module.sass-lint.max_line_length">module sass-lint.max_line_length</a></h1>


    <h2>
        <a href="#apidoc.element.sass-lint.max_line_length.detect" id="apidoc.element.sass-lint.max_line_length.detect">
        function <span class="apidocSignatureSpan">sass-lint.max_line_length.</span>detect
        <span class="apidocSignatureSpan">(ast, parser)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">detect = function (ast, parser) {
  var result = [];

  ast.traverseByType(&#x27;space&#x27;, function (space) {
    var lineLength = 0;
    if (helpers.hasEOL(space.content)) {
      lineLength = space.start.column - 1;
    }

    if (lineLength &#x3e; parser.options.length) {
      result = helpers.addUnique(result, {
        &#x27;ruleId&#x27;: parser.rule.name,
        &#x27;severity&#x27;: parser.severity,
        &#x27;line&#x27;: space.start.line,
        &#x27;column&#x27;: 0,
        &#x27;message&#x27;: &#x27;line &#x27; + space.start.line + &#x27; exceeds the maximum line length of &#x27; + parser.options.length
      });
    }
  });

  return result;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  }

  if (ast.content &#x26;&#x26; ast.content.length &#x3e; 0) {
ruleToggles = getToggledRules(ast);
isEnabledFilter = isResultEnabled(ruleToggles);

rules.forEach(function (rule) {
  detects = rule.rule.<span class="apidocCodeKeywordSpan">detect</span>(ast, rule)
    .filter(isEnabledFilter);
  results = results.concat(detects);
  if (detects.length) {
    if (rule.severity === 1) {
      warnings += detects.length;
    }
    else if (rule.severity === 2) {
...</pre></li>
    </ul>






</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.sass-lint.mixin_name_format" id="apidoc.module.sass-lint.mixin_name_format">module sass-lint.mixin_name_format</a></h1>


    <h2>
        <a href="#apidoc.element.sass-lint.mixin_name_format.detect" id="apidoc.element.sass-lint.mixin_name_format.detect">
        function <span class="apidocSignatureSpan">sass-lint.mixin_name_format.</span>detect
        <span class="apidocSignatureSpan">(ast, parser)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">detect = function (ast, parser) {
  var result = [];

  ast.traverseByTypes([&#x27;mixin&#x27;, &#x27;include&#x27;], function (node) {
    var name,
        strippedName,
        violationMessage = false;

    if (node.is(&#x27;mixin&#x27;)) {
      if (node.contains(&#x27;ident&#x27;)) {
        name = node.first(&#x27;ident&#x27;).content;
      }
    }
    else {
      // We&#x27;re not linting extends here
      if (node.contains(&#x27;atkeyword&#x27;)) {
        if (node.first(&#x27;atkeyword&#x27;).contains(&#x27;ident&#x27;)) {
          if (node.first(&#x27;atkeyword&#x27;).first(&#x27;ident&#x27;).content === &#x27;extend&#x27;) {
            return false;
          }
        }
      }

      if (node.contains(&#x27;ident&#x27;)) {
        name = node.first(&#x27;ident&#x27;).content;
      }
    }

    if (name) {
      strippedName = name;

      if (parser.options[&#x27;allow-leading-underscore&#x27;] &#x26;&#x26; name[0] === &#x27;_&#x27;) {
        strippedName = name.slice(1);
      }

      switch (parser.options.convention) {
      case &#x27;hyphenatedlowercase&#x27;:
        if (!helpers.isHyphenatedLowercase(strippedName)) {
          violationMessage = &#x27;Mixin \&#x27;&#x27; + name + &#x27;\&#x27; should be written in lowercase with hyphens&#x27;;
        }
        break;
      case &#x27;camelcase&#x27;:
        if (!helpers.isCamelCase(strippedName)) {
          violationMessage = &#x27;Mixin \&#x27;&#x27; + name + &#x27;\&#x27; should be written in camelCase&#x27;;
        }
        break;
      case &#x27;pascalcase&#x27;:
        if (!helpers.isPascalCase(strippedName)) {
          violationMessage = &#x27;Mixin \&#x27;&#x27; + name + &#x27;\&#x27; should be written in PascalCase&#x27;;
        }
        break;
      case &#x27;snakecase&#x27;:
        if (!helpers.isSnakeCase(strippedName)) {
          violationMessage = &#x27;Mixin \&#x27;&#x27; + name + &#x27;\&#x27; should be written in snake_case&#x27;;
        }
        break;
      case &#x27;strictbem&#x27;:
        if (!helpers.isStrictBEM(strippedName)) {
          violationMessage = &#x27;Mixin \&#x27;&#x27; + name + &#x27;\&#x27; should be written in BEM (Block Element Modifier) format&#x27;;
        }
        break;
      case &#x27;hyphenatedbem&#x27;:
        if (!helpers.isHyphenatedBEM(strippedName)) {
          violationMessage = &#x27;Mixin \&#x27;&#x27; + name + &#x27;\&#x27; should be written in hyphenated BEM (Block Element Modifier) format&#x27;;
        }
        break;
      default:
        if (!(new RegExp(parser.options.convention).test(strippedName))) {
          violationMessage = &#x27;Mixin \&#x27;&#x27; + name + &#x27;\&#x27; should match regular expression /&#x27; + parser.options.convention + &#x27;/&#x27;;

          // convention-message overrides violationMessage
          if (parser.options[&#x27;convention-explanation&#x27;]) {
            violationMessage = parser.options[&#x27;convention-explanation&#x27;];
          }
        }
      }

      if (violationMessage) {
        result = helpers.addUnique(result, {
          &#x27;ruleId&#x27;: parser.rule.name,
          &#x27;line&#x27;: node.start.line,
          &#x27;column&#x27;: node.start.column,
          &#x27;message&#x27;: violationMessage,
          &#x27;severity&#x27;: parser.severity
        });
      }
    }
    return true;
  });

  return result;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  }

  if (ast.content &#x26;&#x26; ast.content.length &#x3e; 0) {
ruleToggles = getToggledRules(ast);
isEnabledFilter = isResultEnabled(ruleToggles);

rules.forEach(function (rule) {
  detects = rule.rule.<span class="apidocCodeKeywordSpan">detect</span>(ast, rule)
    .filter(isEnabledFilter);
  results = results.concat(detects);
  if (detects.length) {
    if (rule.severity === 1) {
      warnings += detects.length;
    }
    else if (rule.severity === 2) {
...</pre></li>
    </ul>






</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.sass-lint.mixins_before_declarations" id="apidoc.module.sass-lint.mixins_before_declarations">module sass-lint.mixins_before_declarations</a></h1>


    <h2>
        <a href="#apidoc.element.sass-lint.mixins_before_declarations.detect" id="apidoc.element.sass-lint.mixins_before_declarations.detect">
        function <span class="apidocSignatureSpan">sass-lint.mixins_before_declarations.</span>detect
        <span class="apidocSignatureSpan">(ast, parser)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">detect = function (ast, parser) {
  var result = [],
      error;

  ast.traverseByType(&#x27;include&#x27;, function (node, i, parent) {
    var depth = 0,
        declarationCount = [depth];

    parent.forEach(function (item) {
      if (item.is(&#x27;ruleset&#x27;)) {
        depth++;
        declarationCount[depth] = 0;
      }
      else if (item.is(&#x27;declaration&#x27;)) {
        if (item.first().is(&#x27;property&#x27;)) {
          var prop = item.first();

          if (prop.first().is(&#x27;ident&#x27;)) {
            declarationCount[depth]++;
          }
        }
      }
      else if (item.is(&#x27;include&#x27;)) {
        item.forEach(&#x27;ident&#x27;, function (name) {
          if (parser.options.exclude.indexOf(name.content) === -1 &#x26;&#x26; declarationCount[depth] &#x3e; 0) {
            error = {
              &#x27;ruleId&#x27;: parser.rule.name,
              &#x27;line&#x27;: item.start.line,
              &#x27;column&#x27;: item.start.column,
              &#x27;message&#x27;: &#x27;Mixins should come before declarations&#x27;,
              &#x27;severity&#x27;: parser.severity
            };
            result = helpers.addUnique(result, error);
          }
        });
      }
    });
  });
  return result;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  }

  if (ast.content &#x26;&#x26; ast.content.length &#x3e; 0) {
ruleToggles = getToggledRules(ast);
isEnabledFilter = isResultEnabled(ruleToggles);

rules.forEach(function (rule) {
  detects = rule.rule.<span class="apidocCodeKeywordSpan">detect</span>(ast, rule)
    .filter(isEnabledFilter);
  results = results.concat(detects);
  if (detects.length) {
    if (rule.severity === 1) {
      warnings += detects.length;
    }
    else if (rule.severity === 2) {
...</pre></li>
    </ul>






</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.sass-lint.nesting_depth" id="apidoc.module.sass-lint.nesting_depth">module sass-lint.nesting_depth</a></h1>


    <h2>
        <a href="#apidoc.element.sass-lint.nesting_depth.detect" id="apidoc.element.sass-lint.nesting_depth.detect">
        function <span class="apidocSignatureSpan">sass-lint.nesting_depth.</span>detect
        <span class="apidocSignatureSpan">(ast, parser)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">detect = function (ast, parser) {
  var result = [],
      nodes = {},
      depth = 0;

  var recursiveSearch = function (node) {
    if (node.contains(&#x27;block&#x27;)) {
      node.forEach(&#x27;block&#x27;, function (block) {
        if (block.contains(&#x27;ruleset&#x27;)) {
          depth++;
          block.forEach(&#x27;ruleset&#x27;, function (ruleset) {
            var selector = ruleset.first(&#x27;selector&#x27;);

            if (depth &#x3e; parser.options[&#x27;max-depth&#x27;]) {
              var nodeLineColumn = selector.start.line + &#x27;:&#x27; + selector.start.column;

              if (nodes[nodeLineColumn]) {
                if (depth &#x3e; nodes[nodeLineColumn].depth) {
                  nodes[nodeLineColumn].depth = depth;
                }
              }
              else {
                nodes[nodeLineColumn] = {
                  &#x27;line&#x27;: selector.start.line,
                  &#x27;column&#x27;: selector.start.column,
                  &#x27;depth&#x27;: depth
                };
              }
            }
            else {
              recursiveSearch(ruleset);
            }
          });
        }
      });
    }
    depth--;
  };

  ast.traverseByType(&#x27;selector&#x27;, function (selector, i, parent) {
    recursiveSearch(parent);
    depth = 0;
  });

  Object.keys(nodes).forEach(function (node) {
    node = nodes[node];
    result = helpers.addUnique(result, {
      &#x27;ruleId&#x27;: parser.rule.name,
      &#x27;line&#x27;: node.line,
      &#x27;column&#x27;: node.column,
      &#x27;message&#x27;: &#x27;Nesting depth &#x27; + node.depth + &#x27; greater than max of &#x27; + parser.options[&#x27;max-depth&#x27;],
      &#x27;severity&#x27;: parser.severity
    });
  });


  return result;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  }

  if (ast.content &#x26;&#x26; ast.content.length &#x3e; 0) {
ruleToggles = getToggledRules(ast);
isEnabledFilter = isResultEnabled(ruleToggles);

rules.forEach(function (rule) {
  detects = rule.rule.<span class="apidocCodeKeywordSpan">detect</span>(ast, rule)
    .filter(isEnabledFilter);
  results = results.concat(detects);
  if (detects.length) {
    if (rule.severity === 1) {
      warnings += detects.length;
    }
    else if (rule.severity === 2) {
...</pre></li>
    </ul>






</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.sass-lint.no_attribute_selectors" id="apidoc.module.sass-lint.no_attribute_selectors">module sass-lint.no_attribute_selectors</a></h1>


    <h2>
        <a href="#apidoc.element.sass-lint.no_attribute_selectors.detect" id="apidoc.element.sass-lint.no_attribute_selectors.detect">
        function <span class="apidocSignatureSpan">sass-lint.no_attribute_selectors.</span>detect
        <span class="apidocSignatureSpan">(ast, parser)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">detect = function (ast, parser) {
  var result = [];

  ast.traverseByType(&#x27;attributeSelector&#x27;, function (item) {
    result = helpers.addUnique(result, {
      &#x27;ruleId&#x27;: parser.rule.name,
      &#x27;line&#x27;: item.start.line,
      &#x27;column&#x27;: item.start.column,
      &#x27;message&#x27;: &#x27;Attribute selectors are not allowed&#x27;,
      &#x27;severity&#x27;: parser.severity
    });
  });

  return result;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  }

  if (ast.content &#x26;&#x26; ast.content.length &#x3e; 0) {
ruleToggles = getToggledRules(ast);
isEnabledFilter = isResultEnabled(ruleToggles);

rules.forEach(function (rule) {
  detects = rule.rule.<span class="apidocCodeKeywordSpan">detect</span>(ast, rule)
    .filter(isEnabledFilter);
  results = results.concat(detects);
  if (detects.length) {
    if (rule.severity === 1) {
      warnings += detects.length;
    }
    else if (rule.severity === 2) {
...</pre></li>
    </ul>






</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.sass-lint.no_color_hex" id="apidoc.module.sass-lint.no_color_hex">module sass-lint.no_color_hex</a></h1>


    <h2>
        <a href="#apidoc.element.sass-lint.no_color_hex.detect" id="apidoc.element.sass-lint.no_color_hex.detect">
        function <span class="apidocSignatureSpan">sass-lint.no_color_hex.</span>detect
        <span class="apidocSignatureSpan">(ast, parser)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">detect = function (ast, parser) {
  var result = [];

  ast.traverseByType(&#x27;color&#x27;, function (value) {
    result = helpers.addUnique(result, {
      &#x27;ruleId&#x27;: parser.rule.name,
      &#x27;line&#x27;: value.start.line,
      &#x27;column&#x27;: value.start.column,
      &#x27;message&#x27;: &#x27;Hexadecimal colors should not be used&#x27;,
      &#x27;severity&#x27;: parser.severity
    });
  });
  return result;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  }

  if (ast.content &#x26;&#x26; ast.content.length &#x3e; 0) {
ruleToggles = getToggledRules(ast);
isEnabledFilter = isResultEnabled(ruleToggles);

rules.forEach(function (rule) {
  detects = rule.rule.<span class="apidocCodeKeywordSpan">detect</span>(ast, rule)
    .filter(isEnabledFilter);
  results = results.concat(detects);
  if (detects.length) {
    if (rule.severity === 1) {
      warnings += detects.length;
    }
    else if (rule.severity === 2) {
...</pre></li>
    </ul>






</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.sass-lint.no_color_keywords" id="apidoc.module.sass-lint.no_color_keywords">module sass-lint.no_color_keywords</a></h1>


    <h2>
        <a href="#apidoc.element.sass-lint.no_color_keywords.detect" id="apidoc.element.sass-lint.no_color_keywords.detect">
        function <span class="apidocSignatureSpan">sass-lint.no_color_keywords.</span>detect
        <span class="apidocSignatureSpan">(ast, parser)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">detect = function (ast, parser) {
  var result = [];

  ast.traverseByType(&#x27;value&#x27;, function (node) {
    node.traverse(function (elem, i, parent) {
      if (elem.type === &#x27;ident&#x27; &#x26;&#x26; !checkValidParentType(parent)) {
        var index = cssColors.indexOf(elem.content.toLowerCase());

        if (index !== -1) {
          result = helpers.addUnique(result, {
            &#x27;ruleId&#x27;: parser.rule.name,
            &#x27;line&#x27;: elem.start.line,
            &#x27;column&#x27;: elem.start.column,
            &#x27;message&#x27;: &#x27;Color \&#x27;&#x27; + elem.content + &#x27;\&#x27; should be written in its hexadecimal form #&#x27; + cssColors[index + 1],
            &#x27;severity&#x27;: parser.severity
          });
        }
      }
    });

  });
  return result;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  }

  if (ast.content &#x26;&#x26; ast.content.length &#x3e; 0) {
ruleToggles = getToggledRules(ast);
isEnabledFilter = isResultEnabled(ruleToggles);

rules.forEach(function (rule) {
  detects = rule.rule.<span class="apidocCodeKeywordSpan">detect</span>(ast, rule)
    .filter(isEnabledFilter);
  results = results.concat(detects);
  if (detects.length) {
    if (rule.severity === 1) {
      warnings += detects.length;
    }
    else if (rule.severity === 2) {
...</pre></li>
    </ul>






</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.sass-lint.no_color_literals" id="apidoc.module.sass-lint.no_color_literals">module sass-lint.no_color_literals</a></h1>


    <h2>
        <a href="#apidoc.element.sass-lint.no_color_literals.detect" id="apidoc.element.sass-lint.no_color_literals.detect">
        function <span class="apidocSignatureSpan">sass-lint.no_color_literals.</span>detect
        <span class="apidocSignatureSpan">(ast, parser)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">detect = function (ast, parser) {
  var result = [],
      validColorFunctions = getColorFunctionsCopy(colorFunctions);

  if (parser.options[&#x27;allow-rgba&#x27;] &#x26;&#x26; validColorFunctions.indexOf(&#x27;rgba&#x27;) !== -1) {
    validColorFunctions.splice(validColorFunctions.indexOf(&#x27;rgba&#x27;), 1);
  }

  ast.traverseByTypes([&#x27;value&#x27;, &#x27;variable&#x27;], function (node, i, parent) {

    // If we don&#x27;t literals as variable names then check each variable name
    if (node.is(&#x27;variable&#x27;) &#x26;&#x26; !parser.options[&#x27;allow-variable-identifiers&#x27;]) {
      if (cssColors.indexOf(node.content[0].content) !== -1) {
        result = helpers.addUnique(result, {
          &#x27;ruleId&#x27;: parser.rule.name,
          &#x27;line&#x27;: node.start.line,
          &#x27;column&#x27;: node.start.column,
          &#x27;message&#x27;: &#x27;Color literals should not be used as variable names&#x27;,
          &#x27;severity&#x27;: parser.severity
        });
      }
    }
    // check the value nodes
    else if (node.is(&#x27;value&#x27;)) {
      node.forEach(function (valElem) {
        var declarationType = parent.content[0].content[0].type;
        // check type is color, content isn&#x27;t a css color literal
        if (valElem.type === &#x27;color&#x27; || cssColors.indexOf(valElem.content) !== -1) {
          if (declarationType === &#x27;ident&#x27;) {
            result = helpers.addUnique(result, {
              &#x27;ruleId&#x27;: parser.rule.name,
              &#x27;line&#x27;: valElem.start.line,
              &#x27;column&#x27;: valElem.start.column,
              &#x27;message&#x27;: &#x27;Color literals such as \&#x27;&#x27; + checkHexPrefix(valElem.type) + valElem.content + &#x27;\&#x27; should only be used
in variable declarations&#x27;,
              &#x27;severity&#x27;: parser.severity
            });
          }
        }

        // if not a color value or a variable then check if it&#x27;s a function
        else if (valElem.type === &#x27;function&#x27;) {
          var funcType = valElem.content[0].content;

          // check it&#x27;s not a blacklisted color function and even if it is that it&#x27;s not assigned to a variable
          if (validColorFunctions.indexOf(funcType) !== -1 &#x26;&#x26; declarationType !== &#x27;variable&#x27;) {
            result = helpers.addUnique(result, {
              &#x27;ruleId&#x27;: parser.rule.name,
              &#x27;line&#x27;: valElem.start.line,
              &#x27;column&#x27;: valElem.start.column,
              &#x27;message&#x27;: &#x27;Color functions such as \&#x27;&#x27; + funcType + &#x27;\&#x27; should only be used in variable declarations&#x27;,
              &#x27;severity&#x27;: parser.severity
            });
          }

          // if rgba usage is allowed we need to make sure only variables are being passed to it.
          else if (
            parser.options[&#x27;allow-rgba&#x27;] &#x26;&#x26;
            funcType === &#x27;rgba&#x27; &#x26;&#x26;
            valElem.content[1].content[0].type !== &#x27;variable&#x27; &#x26;&#x26;
            declarationType !== &#x27;variable&#x27;
          ) {
            result = helpers.addUnique(result, {
              &#x27;ruleId&#x27;: parser.rule.name,
              &#x27;line&#x27;: valElem.start.line,
              &#x27;column&#x27;: valElem.start.column,
              &#x27;message&#x27;: &#x27;A color in variable form must be passed to rgba, literals are restricted&#x27;,
              &#x27;severity&#x27;: parser.severity
            });
          }

          // if a non color function we should check its arguments
          else {
            valElem.content.forEach( function (funcContent) {
              if (funcContent.type === &#x27;arguments&#x27;) {
                funcContent.forEach(function (funcArgs) {
                  // if the arguments are not functions themselves
                  if (funcArgs.type !== &#x27;function&#x27;) {
                    // check if the argument types are therefore color literals
                    if ((funcArgs.type === &#x27;color&#x27; || funcArgs.type === &#x27;ident&#x27;) &#x26;&#x26; (cssColors.indexOf(funcArgs.content) !== -1 ||
helpers.isValidHex(funcArgs.content))) {
                      result = helpers.addUnique(result, {
                        &#x27;ruleId&#x27;: parser.rule.name,
                        &#x27;line&#x27;: funcArgs.start.line,
                        &#x27;column&#x27;: funcArgs.start.column,
                        &#x27;message&#x27;: &#x27;Color literals such as \&#x27;&#x27; + checkHexPrefix(funcArgs.type) + funcArgs.content + &#x27;\&#x27; should not
 be passed to functions, use variables&#x27;, ...</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  }

  if (ast.content &#x26;&#x26; ast.content.length &#x3e; 0) {
ruleToggles = getToggledRules(ast);
isEnabledFilter = isResultEnabled(ruleToggles);

rules.forEach(function (rule) {
  detects = rule.rule.<span class="apidocCodeKeywordSpan">detect</span>(ast, rule)
    .filter(isEnabledFilter);
  results = results.concat(detects);
  if (detects.length) {
    if (rule.severity === 1) {
      warnings += detects.length;
    }
    else if (rule.severity === 2) {
...</pre></li>
    </ul>






</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.sass-lint.no_combinators" id="apidoc.module.sass-lint.no_combinators">module sass-lint.no_combinators</a></h1>


    <h2>
        <a href="#apidoc.element.sass-lint.no_combinators.detect" id="apidoc.element.sass-lint.no_combinators.detect">
        function <span class="apidocSignatureSpan">sass-lint.no_combinators.</span>detect
        <span class="apidocSignatureSpan">(ast, parser)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">detect = function (ast, parser) {
  var result = [];

  ast.traverseByType(&#x27;selector&#x27;, function (selector) {
    selector.forEach(function (item, i) {
      var previous = selector.content[i - 1] || false,
          next = selector.content[i + 1] || false;

      if (isException(item, next, previous)) {
        return false;
      }

      if (item.is(&#x27;combinator&#x27;) || item.is(&#x27;space&#x27;)) {
        result = helpers.addUnique(result, {
          &#x27;ruleId&#x27;: parser.rule.name,
          &#x27;line&#x27;: item.start.line,
          &#x27;column&#x27;: item.start.column,
          &#x27;message&#x27;: &#x27;Combinators are not allowed&#x27;,
          &#x27;severity&#x27;: parser.severity
        });
      }
      return false;
    });
  });

  return result;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  }

  if (ast.content &#x26;&#x26; ast.content.length &#x3e; 0) {
ruleToggles = getToggledRules(ast);
isEnabledFilter = isResultEnabled(ruleToggles);

rules.forEach(function (rule) {
  detects = rule.rule.<span class="apidocCodeKeywordSpan">detect</span>(ast, rule)
    .filter(isEnabledFilter);
  results = results.concat(detects);
  if (detects.length) {
    if (rule.severity === 1) {
      warnings += detects.length;
    }
    else if (rule.severity === 2) {
...</pre></li>
    </ul>






</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.sass-lint.no_css_comments" id="apidoc.module.sass-lint.no_css_comments">module sass-lint.no_css_comments</a></h1>


    <h2>
        <a href="#apidoc.element.sass-lint.no_css_comments.detect" id="apidoc.element.sass-lint.no_css_comments.detect">
        function <span class="apidocSignatureSpan">sass-lint.no_css_comments.</span>detect
        <span class="apidocSignatureSpan">(ast, parser)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">detect = function (ast, parser) {
  var result = [];

  ast.traverseByType(&#x27;multilineComment&#x27;, function (node) {
    if (node.content.charAt(0) !== &#x27;!&#x27;) {
      result = helpers.addUnique(result, {
        &#x27;ruleId&#x27;: parser.rule.name,
        &#x27;line&#x27;: node.start.line,
        &#x27;column&#x27;: node.start.column,
        &#x27;message&#x27;: &#x27;Multiline style comments should not be used&#x27;,
        &#x27;severity&#x27;: parser.severity
      });
    }
  });
  return result;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  }

  if (ast.content &#x26;&#x26; ast.content.length &#x3e; 0) {
ruleToggles = getToggledRules(ast);
isEnabledFilter = isResultEnabled(ruleToggles);

rules.forEach(function (rule) {
  detects = rule.rule.<span class="apidocCodeKeywordSpan">detect</span>(ast, rule)
    .filter(isEnabledFilter);
  results = results.concat(detects);
  if (detects.length) {
    if (rule.severity === 1) {
      warnings += detects.length;
    }
    else if (rule.severity === 2) {
...</pre></li>
    </ul>






</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.sass-lint.no_debug" id="apidoc.module.sass-lint.no_debug">module sass-lint.no_debug</a></h1>


    <h2>
        <a href="#apidoc.element.sass-lint.no_debug.detect" id="apidoc.element.sass-lint.no_debug.detect">
        function <span class="apidocSignatureSpan">sass-lint.no_debug.</span>detect
        <span class="apidocSignatureSpan">(ast, parser)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">detect = function (ast, parser) {
  var result = [];

  ast.traverseByType(&#x27;atkeyword&#x27;, function (keyword) {
    keyword.traverse(function (item) {
      if (item.content === &#x27;debug&#x27;) {
        result = helpers.addUnique(result, {
          &#x27;ruleId&#x27;: parser.rule.name,
          &#x27;line&#x27;: item.start.line,
          &#x27;column&#x27;: item.start.column,
          &#x27;message&#x27;: &#x27;@debug not allowed&#x27;,
          &#x27;severity&#x27;: parser.severity
        });
      }
    });
  });

  return result;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  }

  if (ast.content &#x26;&#x26; ast.content.length &#x3e; 0) {
ruleToggles = getToggledRules(ast);
isEnabledFilter = isResultEnabled(ruleToggles);

rules.forEach(function (rule) {
  detects = rule.rule.<span class="apidocCodeKeywordSpan">detect</span>(ast, rule)
    .filter(isEnabledFilter);
  results = results.concat(detects);
  if (detects.length) {
    if (rule.severity === 1) {
      warnings += detects.length;
    }
    else if (rule.severity === 2) {
...</pre></li>
    </ul>






</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.sass-lint.no_disallowed_properties" id="apidoc.module.sass-lint.no_disallowed_properties">module sass-lint.no_disallowed_properties</a></h1>


    <h2>
        <a href="#apidoc.element.sass-lint.no_disallowed_properties.detect" id="apidoc.element.sass-lint.no_disallowed_properties.detect">
        function <span class="apidocSignatureSpan">sass-lint.no_disallowed_properties.</span>detect
        <span class="apidocSignatureSpan">(ast, parser)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">detect = function (ast, parser) {
  var result = [];

  ast.traverseByType(&#x27;property&#x27;, function (node) {
    var first = node.first();
    if (!first.is(&#x27;ident&#x27;) || parser.options.properties.indexOf(first.content) === -1) {
      return;
    }
    result = helpers.addUnique(result, {
      &#x27;ruleId&#x27;: parser.rule.name,
      &#x27;line&#x27;: node.start.line,
      &#x27;column&#x27;: node.start.column,
      &#x27;message&#x27;: &#x27;Property `&#x27; + first.content + &#x27;` should not be used&#x27;,
      &#x27;severity&#x27;: parser.severity
    });
  });
  return result;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  }

  if (ast.content &#x26;&#x26; ast.content.length &#x3e; 0) {
ruleToggles = getToggledRules(ast);
isEnabledFilter = isResultEnabled(ruleToggles);

rules.forEach(function (rule) {
  detects = rule.rule.<span class="apidocCodeKeywordSpan">detect</span>(ast, rule)
    .filter(isEnabledFilter);
  results = results.concat(detects);
  if (detects.length) {
    if (rule.severity === 1) {
      warnings += detects.length;
    }
    else if (rule.severity === 2) {
...</pre></li>
    </ul>






</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.sass-lint.no_duplicate_properties" id="apidoc.module.sass-lint.no_duplicate_properties">module sass-lint.no_duplicate_properties</a></h1>


    <h2>
        <a href="#apidoc.element.sass-lint.no_duplicate_properties.detect" id="apidoc.element.sass-lint.no_duplicate_properties.detect">
        function <span class="apidocSignatureSpan">sass-lint.no_duplicate_properties.</span>detect
        <span class="apidocSignatureSpan">(ast, parser)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">detect = function (ast, parser) {
  var result = [];

  ast.traverseByType(&#x27;block&#x27;, function (block) {
    var properties = [],
        items = [],
        warnMessage = false;

    block.eachFor(&#x27;declaration&#x27;, function (declaration) {
      items.push(declaration);
    });

    items.reverse();

    items.forEach(function (declaration) {
      warnMessage = false;

      declaration.eachFor(&#x27;property&#x27;, function (item) {
        var property = &#x27;&#x27;;

        // Check if declaration is actually a variable declaration
        if (item.content[0] &#x26;&#x26; item.content[0].is(&#x27;variable&#x27;)) {
          return;
        }

        item.forEach(function (subItem) {
          // Although not a selector the method here helps us construct the proper property name
          // taking into account any interpolation etc
          property += selectorHelpers.constructSelector(subItem);
        });

        if (properties.indexOf(property) !== -1 &#x26;&#x26; properties.length &#x3e;= 1) {
          if (parser.options.exclude.indexOf(property) !== -1 &#x26;&#x26; properties[properties.length - 1] !== property) {
            warnMessage = &#x27;Excluded duplicate properties must directly follow each other.&#x27;;
          }
          else if (parser.options.exclude.indexOf(property) === -1) {
            warnMessage = &#x27;Duplicate properties are not allowed within a block&#x27;;
          }
        }

        properties.push(property);

        if (warnMessage) {
          result = helpers.addUnique(result, {
            &#x27;ruleId&#x27;: parser.rule.name,
            &#x27;line&#x27;: item.start.line,
            &#x27;column&#x27;: item.start.column,
            &#x27;message&#x27;: warnMessage,
            &#x27;severity&#x27;: parser.severity
          });
        }
      });
    });
  });

  return result;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  }

  if (ast.content &#x26;&#x26; ast.content.length &#x3e; 0) {
ruleToggles = getToggledRules(ast);
isEnabledFilter = isResultEnabled(ruleToggles);

rules.forEach(function (rule) {
  detects = rule.rule.<span class="apidocCodeKeywordSpan">detect</span>(ast, rule)
    .filter(isEnabledFilter);
  results = results.concat(detects);
  if (detects.length) {
    if (rule.severity === 1) {
      warnings += detects.length;
    }
    else if (rule.severity === 2) {
...</pre></li>
    </ul>






</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.sass-lint.no_empty_rulesets" id="apidoc.module.sass-lint.no_empty_rulesets">module sass-lint.no_empty_rulesets</a></h1>


    <h2>
        <a href="#apidoc.element.sass-lint.no_empty_rulesets.detect" id="apidoc.element.sass-lint.no_empty_rulesets.detect">
        function <span class="apidocSignatureSpan">sass-lint.no_empty_rulesets.</span>detect
        <span class="apidocSignatureSpan">(ast, parser)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">detect = function (ast, parser) {
  var result = [];

  ast.traverseByType(&#x27;block&#x27;, function (block) {
    var nonSpaceCount = 0,
        empty = false;

    if (block.content.length === 0) {
      empty = true;
    }
    else {
      block.traverse(function (item) {
        if (!helpers.isEqual(block, item)) {
          if (item.type !== &#x27;space&#x27;) {
            nonSpaceCount++;
          }
        }
      });
      if (nonSpaceCount === 0) {
        empty = true;
      }
    }

    if (empty) {
      result = helpers.addUnique(result, {
        &#x27;ruleId&#x27;: parser.rule.name,
        &#x27;severity&#x27;: parser.severity,
        &#x27;line&#x27;: block.start.line,
        &#x27;column&#x27;: block.start.column,
        &#x27;message&#x27;: &#x27;No empty blocks allowed&#x27;
      });
    }
  });


  return result;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  }

  if (ast.content &#x26;&#x26; ast.content.length &#x3e; 0) {
ruleToggles = getToggledRules(ast);
isEnabledFilter = isResultEnabled(ruleToggles);

rules.forEach(function (rule) {
  detects = rule.rule.<span class="apidocCodeKeywordSpan">detect</span>(ast, rule)
    .filter(isEnabledFilter);
  results = results.concat(detects);
  if (detects.length) {
    if (rule.severity === 1) {
      warnings += detects.length;
    }
    else if (rule.severity === 2) {
...</pre></li>
    </ul>






</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.sass-lint.no_extends" id="apidoc.module.sass-lint.no_extends">module sass-lint.no_extends</a></h1>


    <h2>
        <a href="#apidoc.element.sass-lint.no_extends.detect" id="apidoc.element.sass-lint.no_extends.detect">
        function <span class="apidocSignatureSpan">sass-lint.no_extends.</span>detect
        <span class="apidocSignatureSpan">(ast, parser)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">detect = function (ast, parser) {
  var result = [];

  ast.traverseByType(&#x27;atkeyword&#x27;, function (keyword) {
    keyword.traverse(function (item) {
      if (item.content === &#x27;extend&#x27;) {
        result = helpers.addUnique(result, {
          &#x27;ruleId&#x27;: parser.rule.name,
          &#x27;line&#x27;: item.start.line,
          &#x27;column&#x27;: item.start.column,
          &#x27;message&#x27;: &#x27;@extend not allowed&#x27;,
          &#x27;severity&#x27;: parser.severity
        });
      }
    });
  });

  return result;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  }

  if (ast.content &#x26;&#x26; ast.content.length &#x3e; 0) {
ruleToggles = getToggledRules(ast);
isEnabledFilter = isResultEnabled(ruleToggles);

rules.forEach(function (rule) {
  detects = rule.rule.<span class="apidocCodeKeywordSpan">detect</span>(ast, rule)
    .filter(isEnabledFilter);
  results = results.concat(detects);
  if (detects.length) {
    if (rule.severity === 1) {
      warnings += detects.length;
    }
    else if (rule.severity === 2) {
...</pre></li>
    </ul>






</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.sass-lint.no_ids" id="apidoc.module.sass-lint.no_ids">module sass-lint.no_ids</a></h1>


    <h2>
        <a href="#apidoc.element.sass-lint.no_ids.detect" id="apidoc.element.sass-lint.no_ids.detect">
        function <span class="apidocSignatureSpan">sass-lint.no_ids.</span>detect
        <span class="apidocSignatureSpan">(ast, parser)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">detect = function (ast, parser) {
  var result = [];

  ast.traverseByType(&#x27;id&#x27;, function (id) {
    result = helpers.addUnique(result, {
      &#x27;ruleId&#x27;: parser.rule.name,
      &#x27;line&#x27;: id.start.line,
      &#x27;column&#x27;: id.start.column,
      &#x27;message&#x27;: &#x27;ID selectors not allowed&#x27;,
      &#x27;severity&#x27;: parser.severity
    });
  });

  return result;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  }

  if (ast.content &#x26;&#x26; ast.content.length &#x3e; 0) {
ruleToggles = getToggledRules(ast);
isEnabledFilter = isResultEnabled(ruleToggles);

rules.forEach(function (rule) {
  detects = rule.rule.<span class="apidocCodeKeywordSpan">detect</span>(ast, rule)
    .filter(isEnabledFilter);
  results = results.concat(detects);
  if (detects.length) {
    if (rule.severity === 1) {
      warnings += detects.length;
    }
    else if (rule.severity === 2) {
...</pre></li>
    </ul>






</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.sass-lint.no_important" id="apidoc.module.sass-lint.no_important">module sass-lint.no_important</a></h1>


    <h2>
        <a href="#apidoc.element.sass-lint.no_important.detect" id="apidoc.element.sass-lint.no_important.detect">
        function <span class="apidocSignatureSpan">sass-lint.no_important.</span>detect
        <span class="apidocSignatureSpan">(ast, parser)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">detect = function (ast, parser) {
  var result = [];

  ast.traverseByType(&#x27;important&#x27;, function (item) {
    result = helpers.addUnique(result, {
      &#x27;ruleId&#x27;: parser.rule.name,
      &#x27;line&#x27;: item.start.line,
      &#x27;column&#x27;: item.start.column,
      &#x27;message&#x27;: &#x27;!important not allowed&#x27;,
      &#x27;severity&#x27;: parser.severity
    });
  });

  return result;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  }

  if (ast.content &#x26;&#x26; ast.content.length &#x3e; 0) {
ruleToggles = getToggledRules(ast);
isEnabledFilter = isResultEnabled(ruleToggles);

rules.forEach(function (rule) {
  detects = rule.rule.<span class="apidocCodeKeywordSpan">detect</span>(ast, rule)
    .filter(isEnabledFilter);
  results = results.concat(detects);
  if (detects.length) {
    if (rule.severity === 1) {
      warnings += detects.length;
    }
    else if (rule.severity === 2) {
...</pre></li>
    </ul>






</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.sass-lint.no_invalid_hex" id="apidoc.module.sass-lint.no_invalid_hex">module sass-lint.no_invalid_hex</a></h1>


    <h2>
        <a href="#apidoc.element.sass-lint.no_invalid_hex.detect" id="apidoc.element.sass-lint.no_invalid_hex.detect">
        function <span class="apidocSignatureSpan">sass-lint.no_invalid_hex.</span>detect
        <span class="apidocSignatureSpan">(ast, parser)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">detect = function (ast, parser) {
  var result = [];

  ast.traverseByType(&#x27;color&#x27;, function (value) {
    if (!helpers.isValidHex(value.content)) {
      result = helpers.addUnique(result, {
        &#x27;ruleId&#x27;: parser.rule.name,
        &#x27;line&#x27;: value.start.line,
        &#x27;column&#x27;: value.start.column,
        &#x27;message&#x27;: &#x27;Hexadecimal values must be a valid format&#x27;,
        &#x27;severity&#x27;: parser.severity
      });
    }
  });
  return result;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  }

  if (ast.content &#x26;&#x26; ast.content.length &#x3e; 0) {
ruleToggles = getToggledRules(ast);
isEnabledFilter = isResultEnabled(ruleToggles);

rules.forEach(function (rule) {
  detects = rule.rule.<span class="apidocCodeKeywordSpan">detect</span>(ast, rule)
    .filter(isEnabledFilter);
  results = results.concat(detects);
  if (detects.length) {
    if (rule.severity === 1) {
      warnings += detects.length;
    }
    else if (rule.severity === 2) {
...</pre></li>
    </ul>






</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.sass-lint.no_mergeable_selectors" id="apidoc.module.sass-lint.no_mergeable_selectors">module sass-lint.no_mergeable_selectors</a></h1>


    <h2>
        <a href="#apidoc.element.sass-lint.no_mergeable_selectors.detect" id="apidoc.element.sass-lint.no_mergeable_selectors.detect">
        function <span class="apidocSignatureSpan">sass-lint.no_mergeable_selectors.</span>detect
        <span class="apidocSignatureSpan">(ast, parser)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">detect = function (ast, parser) {
  curLevel = 0;
  curSelector = [];
  parentSelector = [];
  selectorList = [];
  syntax = ast.syntax;
  ast.traverseByType(&#x27;stylesheet&#x27;, function (styleSheet) {
    traverseBlock(styleSheet, traverseNode);
  });
  return checkMergeable(parser);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  }

  if (ast.content &#x26;&#x26; ast.content.length &#x3e; 0) {
ruleToggles = getToggledRules(ast);
isEnabledFilter = isResultEnabled(ruleToggles);

rules.forEach(function (rule) {
  detects = rule.rule.<span class="apidocCodeKeywordSpan">detect</span>(ast, rule)
    .filter(isEnabledFilter);
  results = results.concat(detects);
  if (detects.length) {
    if (rule.severity === 1) {
      warnings += detects.length;
    }
    else if (rule.severity === 2) {
...</pre></li>
    </ul>






</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.sass-lint.no_misspelled_properties" id="apidoc.module.sass-lint.no_misspelled_properties">module sass-lint.no_misspelled_properties</a></h1>


    <h2>
        <a href="#apidoc.element.sass-lint.no_misspelled_properties.detect" id="apidoc.element.sass-lint.no_misspelled_properties.detect">
        function <span class="apidocSignatureSpan">sass-lint.no_misspelled_properties.</span>detect
        <span class="apidocSignatureSpan">(ast, parser)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">detect = function (ast, parser) {
  var result = [];

  ast.traverseByType(&#x27;property&#x27;, function (node) {
    if (node.first().is(&#x27;ident&#x27;)) {
      var curProperty = node.first().content,
          propertyList = getCombinedList(properties, parser.options[&#x27;extra-properties&#x27;]);

      if (curProperty.charAt(0) === &#x27;-&#x27;) {
        curProperty = helpers.stripPrefix(curProperty);
      }

      if (helpers.isPartialStringMatch(curProperty, propertyList)) {
        return false;
      }

      if (curProperty.length &#x3e; 0) {
        result = helpers.addUnique(result, {
          &#x27;ruleId&#x27;: parser.rule.name,
          &#x27;line&#x27;: node.start.line,
          &#x27;column&#x27;: node.start.column,
          &#x27;message&#x27;: &#x27;Property `&#x27; + curProperty + &#x27;` appears to be spelled incorrectly&#x27;,
          &#x27;severity&#x27;: parser.severity
        });
      }
    }

    return false;
  });

  return result;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  }

  if (ast.content &#x26;&#x26; ast.content.length &#x3e; 0) {
ruleToggles = getToggledRules(ast);
isEnabledFilter = isResultEnabled(ruleToggles);

rules.forEach(function (rule) {
  detects = rule.rule.<span class="apidocCodeKeywordSpan">detect</span>(ast, rule)
    .filter(isEnabledFilter);
  results = results.concat(detects);
  if (detects.length) {
    if (rule.severity === 1) {
      warnings += detects.length;
    }
    else if (rule.severity === 2) {
...</pre></li>
    </ul>






</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.sass-lint.no_qualifying_elements" id="apidoc.module.sass-lint.no_qualifying_elements">module sass-lint.no_qualifying_elements</a></h1>


    <h2>
        <a href="#apidoc.element.sass-lint.no_qualifying_elements.detect" id="apidoc.element.sass-lint.no_qualifying_elements.detect">
        function <span class="apidocSignatureSpan">sass-lint.no_qualifying_elements.</span>detect
        <span class="apidocSignatureSpan">(ast, parser)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">detect = function (ast, parser) {
  var result = [];

  ast.traverseByType(&#x27;selector&#x27;, function (selector) {
    selector.forEach(function (item, i) {
      if (item.is(&#x27;attributeSelector&#x27;) || item.is(&#x27;class&#x27;) || item.is(&#x27;id&#x27;)) {
        var previous = selector.content[i - 1] || false;

        if (previous &#x26;&#x26; previous.is(&#x27;typeSelector&#x27;)) {
          if (previous.contains(&#x27;ident&#x27;)) {
            var type = null;

            if (item.is(&#x27;attributeSelector&#x27;)) {
              type = &#x27;attribute&#x27;;
            }

            if (item.is(&#x27;class&#x27;)) {
              type = &#x27;class&#x27;;
            }

            if (item.is(&#x27;id&#x27;)) {
              type = &#x27;id&#x27;;
            }

            if (type &#x26;&#x26; !parser.options[&#x27;allow-element-with-&#x27; + type]) {
              result = helpers.addUnique(result, {
                &#x27;ruleId&#x27;: parser.rule.name,
                &#x27;line&#x27;: item.start.line,
                &#x27;column&#x27;: item.start.column,
                &#x27;message&#x27;: &#x27;Qualifying elements are not allowed for &#x27; + type + &#x27; selectors&#x27;,
                &#x27;severity&#x27;: parser.severity
              });
            }
          }
        }
      }
    });
  });

  return result;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  }

  if (ast.content &#x26;&#x26; ast.content.length &#x3e; 0) {
ruleToggles = getToggledRules(ast);
isEnabledFilter = isResultEnabled(ruleToggles);

rules.forEach(function (rule) {
  detects = rule.rule.<span class="apidocCodeKeywordSpan">detect</span>(ast, rule)
    .filter(isEnabledFilter);
  results = results.concat(detects);
  if (detects.length) {
    if (rule.severity === 1) {
      warnings += detects.length;
    }
    else if (rule.severity === 2) {
...</pre></li>
    </ul>






</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.sass-lint.no_trailing_whitespace" id="apidoc.module.sass-lint.no_trailing_whitespace">module sass-lint.no_trailing_whitespace</a></h1>


    <h2>
        <a href="#apidoc.element.sass-lint.no_trailing_whitespace.detect" id="apidoc.element.sass-lint.no_trailing_whitespace.detect">
        function <span class="apidocSignatureSpan">sass-lint.no_trailing_whitespace.</span>detect
        <span class="apidocSignatureSpan">(ast, parser)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">detect = function (ast, parser) {
  var result = [];
  var trailing = (/( |\t)+\n/);
  var trailingCRLF = (/( |\t)+\r\n/);

  ast.traverseByType(&#x27;space&#x27;, function (space, i, parent) {
    var content = space.content;
    var nextIndex = i + 1;
    var next = parent.content[nextIndex];

    while (next &#x26;&#x26; (next.is(&#x27;space&#x27;) || next.is(&#x27;declarationDelimiter&#x27;))) {
      content += next.content;
      nextIndex++;
      next = parent.content[nextIndex];
    }

    if (trailing.test(content) || trailingCRLF.test(content)) {
      result = helpers.addUnique(result, {
        &#x27;ruleId&#x27;: parser.rule.name,
        &#x27;severity&#x27;: parser.severity,
        &#x27;line&#x27;: space.start.line,
        &#x27;column&#x27;: space.start.column,
        &#x27;message&#x27;: &#x27;No trailing whitespace allowed&#x27;
      });
    }
  });

  return result;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  }

  if (ast.content &#x26;&#x26; ast.content.length &#x3e; 0) {
ruleToggles = getToggledRules(ast);
isEnabledFilter = isResultEnabled(ruleToggles);

rules.forEach(function (rule) {
  detects = rule.rule.<span class="apidocCodeKeywordSpan">detect</span>(ast, rule)
    .filter(isEnabledFilter);
  results = results.concat(detects);
  if (detects.length) {
    if (rule.severity === 1) {
      warnings += detects.length;
    }
    else if (rule.severity === 2) {
...</pre></li>
    </ul>






</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.sass-lint.no_trailing_zero" id="apidoc.module.sass-lint.no_trailing_zero">module sass-lint.no_trailing_zero</a></h1>


    <h2>
        <a href="#apidoc.element.sass-lint.no_trailing_zero.detect" id="apidoc.element.sass-lint.no_trailing_zero.detect">
        function <span class="apidocSignatureSpan">sass-lint.no_trailing_zero.</span>detect
        <span class="apidocSignatureSpan">(ast, parser)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">detect = function (ast, parser) {
  var result = [];

  ast.traverseByType(&#x27;number&#x27;, function (num) {

    if (num.content.match(trailingZeroRegex)) {
      result = helpers.addUnique(result, {
        &#x27;ruleId&#x27;: parser.rule.name,
        &#x27;line&#x27;: num.start.line,
        &#x27;column&#x27;: num.start.column,
        &#x27;message&#x27;: &#x27;Don\&#x27;t include trailing zeros on numbers&#x27;,
        &#x27;severity&#x27;: parser.severity
      });
    }
  });

  return result;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  }

  if (ast.content &#x26;&#x26; ast.content.length &#x3e; 0) {
ruleToggles = getToggledRules(ast);
isEnabledFilter = isResultEnabled(ruleToggles);

rules.forEach(function (rule) {
  detects = rule.rule.<span class="apidocCodeKeywordSpan">detect</span>(ast, rule)
    .filter(isEnabledFilter);
  results = results.concat(detects);
  if (detects.length) {
    if (rule.severity === 1) {
      warnings += detects.length;
    }
    else if (rule.severity === 2) {
...</pre></li>
    </ul>






</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.sass-lint.no_transition_all" id="apidoc.module.sass-lint.no_transition_all">module sass-lint.no_transition_all</a></h1>


    <h2>
        <a href="#apidoc.element.sass-lint.no_transition_all.detect" id="apidoc.element.sass-lint.no_transition_all.detect">
        function <span class="apidocSignatureSpan">sass-lint.no_transition_all.</span>detect
        <span class="apidocSignatureSpan">(ast, parser)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">detect = function (ast, parser) {
  var result = [];

  ast.traverseByType(&#x27;declaration&#x27;, function (declaration) {

    if (declaration.first(&#x27;property&#x27;)) {
      if (declaration.first(&#x27;property&#x27;).first(&#x27;ident&#x27;)) {
        var propertyName = declaration.first(&#x27;property&#x27;).first(&#x27;ident&#x27;).content;

        if (propertyName.charAt(0) === &#x27;-&#x27;) {
          propertyName = helpers.stripPrefix(propertyName);
        }

        if (propertyName === &#x27;transition&#x27; || propertyName === &#x27;transition-property&#x27; ) {
          declaration.forEach(&#x27;value&#x27;, function (val) {
            val.forEach(&#x27;ident&#x27;, function (ident) {
              if (ident.content === &#x27;all&#x27;) {
                result = helpers.addUnique(result, {
                  &#x27;ruleId&#x27;: parser.rule.name,
                  &#x27;line&#x27;: declaration.start.line,
                  &#x27;column&#x27;: declaration.start.column,
                  &#x27;message&#x27;: &#x27;The keyword `all` should not be used with the property `&#x27; + propertyName + &#x27;`&#x27;,
                  &#x27;severity&#x27;: parser.severity
                });
              }
            });
          });
        }
      }
    }
  });
  return result;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  }

  if (ast.content &#x26;&#x26; ast.content.length &#x3e; 0) {
ruleToggles = getToggledRules(ast);
isEnabledFilter = isResultEnabled(ruleToggles);

rules.forEach(function (rule) {
  detects = rule.rule.<span class="apidocCodeKeywordSpan">detect</span>(ast, rule)
    .filter(isEnabledFilter);
  results = results.concat(detects);
  if (detects.length) {
    if (rule.severity === 1) {
      warnings += detects.length;
    }
    else if (rule.severity === 2) {
...</pre></li>
    </ul>






</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.sass-lint.no_universal_selectors" id="apidoc.module.sass-lint.no_universal_selectors">module sass-lint.no_universal_selectors</a></h1>


    <h2>
        <a href="#apidoc.element.sass-lint.no_universal_selectors.detect" id="apidoc.element.sass-lint.no_universal_selectors.detect">
        function <span class="apidocSignatureSpan">sass-lint.no_universal_selectors.</span>detect
        <span class="apidocSignatureSpan">(ast, parser)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">detect = function (ast, parser) {
  var result = [];

  ast.traverseByType(&#x27;typeSelector&#x27;, function (typeSelector) {
    typeSelector.traverse(function (item) {
      if (item.is(&#x27;ident&#x27;) &#x26;&#x26; item.content === &#x27;*&#x27;) {
        result = helpers.addUnique(result, {
          &#x27;ruleId&#x27;: parser.rule.name,
          &#x27;line&#x27;: item.start.line,
          &#x27;column&#x27;: item.start.column,
          &#x27;message&#x27;: &#x27;* (universal) selectors are not allowed&#x27;,
          &#x27;severity&#x27;: parser.severity
        });
      }
    });
  });

  return result;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  }

  if (ast.content &#x26;&#x26; ast.content.length &#x3e; 0) {
ruleToggles = getToggledRules(ast);
isEnabledFilter = isResultEnabled(ruleToggles);

rules.forEach(function (rule) {
  detects = rule.rule.<span class="apidocCodeKeywordSpan">detect</span>(ast, rule)
    .filter(isEnabledFilter);
  results = results.concat(detects);
  if (detects.length) {
    if (rule.severity === 1) {
      warnings += detects.length;
    }
    else if (rule.severity === 2) {
...</pre></li>
    </ul>






</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.sass-lint.no_url_domains" id="apidoc.module.sass-lint.no_url_domains">module sass-lint.no_url_domains</a></h1>


    <h2>
        <a href="#apidoc.element.sass-lint.no_url_domains.detect" id="apidoc.element.sass-lint.no_url_domains.detect">
        function <span class="apidocSignatureSpan">sass-lint.no_url_domains.</span>detect
        <span class="apidocSignatureSpan">(ast, parser)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">detect = function (ast, parser) {
  var result = [];

  ast.traverseByType(&#x27;uri&#x27;, function (uri) {
    uri.traverse(function (item) {
      if (item.is(&#x27;string&#x27;)) {
        var stripped = helpers.stripQuotes(item.content),
            parsedUrl = url.parse(stripped, false, true);

        if (parsedUrl.host &#x26;&#x26; parsedUrl.protocol !== &#x27;data:&#x27;) {
          result = helpers.addUnique(result, {
            &#x27;ruleId&#x27;: parser.rule.name,
            &#x27;severity&#x27;: parser.severity,
            &#x27;line&#x27;: item.end.line,
            &#x27;column&#x27;: item.end.column,
            &#x27;message&#x27;: &#x27;Domains in URLs are disallowed&#x27;
          });
        }
      }
    });
  });

  return result;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  }

  if (ast.content &#x26;&#x26; ast.content.length &#x3e; 0) {
ruleToggles = getToggledRules(ast);
isEnabledFilter = isResultEnabled(ruleToggles);

rules.forEach(function (rule) {
  detects = rule.rule.<span class="apidocCodeKeywordSpan">detect</span>(ast, rule)
    .filter(isEnabledFilter);
  results = results.concat(detects);
  if (detects.length) {
    if (rule.severity === 1) {
      warnings += detects.length;
    }
    else if (rule.severity === 2) {
...</pre></li>
    </ul>






</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.sass-lint.no_url_protocols" id="apidoc.module.sass-lint.no_url_protocols">module sass-lint.no_url_protocols</a></h1>


    <h2>
        <a href="#apidoc.element.sass-lint.no_url_protocols.detect" id="apidoc.element.sass-lint.no_url_protocols.detect">
        function <span class="apidocSignatureSpan">sass-lint.no_url_protocols.</span>detect
        <span class="apidocSignatureSpan">(ast, parser)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">detect = function (ast, parser) {
  var result = [];

  ast.traverseByType(&#x27;uri&#x27;, function (uri) {
    uri.traverse(function (item) {
      if (item.is(&#x27;string&#x27;)) {
        var stripped = helpers.stripQuotes(item.content),
            regexSelector = !parser.options[&#x27;allow-protocol-relative-urls&#x27;] ?
                isUrlRegex : protocolRelativeRegex,
            message = !parser.options[&#x27;allow-protocol-relative-urls&#x27;] ?
                &#x27;Protocols and domains in URLs are disallowed&#x27; :
                &#x27;Protocols in URLS are disallowed&#x27;;

        if (stripped.match(regexSelector)) {
          result = helpers.addUnique(result, {
            &#x27;ruleId&#x27;: parser.rule.name,
            &#x27;severity&#x27;: parser.severity,
            &#x27;line&#x27;: item.end.line,
            &#x27;column&#x27;: item.end.column,
            &#x27;message&#x27;: message
          });
        }
      }
    });
  });

  return result;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  }

  if (ast.content &#x26;&#x26; ast.content.length &#x3e; 0) {
ruleToggles = getToggledRules(ast);
isEnabledFilter = isResultEnabled(ruleToggles);

rules.forEach(function (rule) {
  detects = rule.rule.<span class="apidocCodeKeywordSpan">detect</span>(ast, rule)
    .filter(isEnabledFilter);
  results = results.concat(detects);
  if (detects.length) {
    if (rule.severity === 1) {
      warnings += detects.length;
    }
    else if (rule.severity === 2) {
...</pre></li>
    </ul>






</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.sass-lint.no_warn" id="apidoc.module.sass-lint.no_warn">module sass-lint.no_warn</a></h1>


    <h2>
        <a href="#apidoc.element.sass-lint.no_warn.detect" id="apidoc.element.sass-lint.no_warn.detect">
        function <span class="apidocSignatureSpan">sass-lint.no_warn.</span>detect
        <span class="apidocSignatureSpan">(ast, parser)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">detect = function (ast, parser) {
  var result = [];

  ast.traverseByType(&#x27;atkeyword&#x27;, function (keyword) {
    keyword.traverse(function (item) {
      if (item.content === &#x27;warn&#x27;) {
        result = helpers.addUnique(result, {
          &#x27;ruleId&#x27;: parser.rule.name,
          &#x27;line&#x27;: item.start.line,
          &#x27;column&#x27;: item.start.column,
          &#x27;message&#x27;: &#x27;@warn not allowed&#x27;,
          &#x27;severity&#x27;: parser.severity
        });
      }
    });
  });

  return result;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  }

  if (ast.content &#x26;&#x26; ast.content.length &#x3e; 0) {
ruleToggles = getToggledRules(ast);
isEnabledFilter = isResultEnabled(ruleToggles);

rules.forEach(function (rule) {
  detects = rule.rule.<span class="apidocCodeKeywordSpan">detect</span>(ast, rule)
    .filter(isEnabledFilter);
  results = results.concat(detects);
  if (detects.length) {
    if (rule.severity === 1) {
      warnings += detects.length;
    }
    else if (rule.severity === 2) {
...</pre></li>
    </ul>






</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.sass-lint.one_declaration_per_line" id="apidoc.module.sass-lint.one_declaration_per_line">module sass-lint.one_declaration_per_line</a></h1>


    <h2>
        <a href="#apidoc.element.sass-lint.one_declaration_per_line.detect" id="apidoc.element.sass-lint.one_declaration_per_line.detect">
        function <span class="apidocSignatureSpan">sass-lint.one_declaration_per_line.</span>detect
        <span class="apidocSignatureSpan">(ast, parser)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">detect = function (ast, parser) {
  var result = [],
      lastLine = {};

  ast.traverseByType(&#x27;declaration&#x27;, function (declaration, i, parent) {

    if (declaration.start.line === lastLine.start || declaration.start.line === lastLine.end) {
      if (parent.type !== &#x27;arguments&#x27;) {
        result = helpers.addUnique(result, {
          &#x27;ruleId&#x27;: parser.rule.name,
          &#x27;line&#x27;: declaration.start.line,
          &#x27;column&#x27;: declaration.start.column,
          &#x27;message&#x27;: &#x27;Only one declaration allowed per line&#x27;,
          &#x27;severity&#x27;: parser.severity
        });
      }
    }

    lastLine.start = declaration.start.line;
    lastLine.end = declaration.end.line;
  });

  return result;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  }

  if (ast.content &#x26;&#x26; ast.content.length &#x3e; 0) {
ruleToggles = getToggledRules(ast);
isEnabledFilter = isResultEnabled(ruleToggles);

rules.forEach(function (rule) {
  detects = rule.rule.<span class="apidocCodeKeywordSpan">detect</span>(ast, rule)
    .filter(isEnabledFilter);
  results = results.concat(detects);
  if (detects.length) {
    if (rule.severity === 1) {
      warnings += detects.length;
    }
    else if (rule.severity === 2) {
...</pre></li>
    </ul>






</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.sass-lint.placeholder_in_extend" id="apidoc.module.sass-lint.placeholder_in_extend">module sass-lint.placeholder_in_extend</a></h1>


    <h2>
        <a href="#apidoc.element.sass-lint.placeholder_in_extend.detect" id="apidoc.element.sass-lint.placeholder_in_extend.detect">
        function <span class="apidocSignatureSpan">sass-lint.placeholder_in_extend.</span>detect
        <span class="apidocSignatureSpan">(ast, parser)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">detect = function (ast, parser) {
  var result = [];

  ast.traverseByType(&#x27;atkeyword&#x27;, function (keyword, i, parent) {
    keyword.forEach(function (item) {
      if (item.content === &#x27;extend&#x27;) {

        parent.forEach(&#x27;selector&#x27;, function (selector) {
          var placeholder = false;

          selector.content.forEach(function (selectorPiece) {
            if (selectorPiece.type === &#x27;placeholder&#x27;) {
              placeholder = true;
            }
          });

          if (!placeholder) {
            result = helpers.addUnique(result, {
              &#x27;ruleId&#x27;: parser.rule.name,
              &#x27;line&#x27;: selector.start.line,
              &#x27;column&#x27;: selector.start.column,
              &#x27;message&#x27;: &#x27;@extend must be used with a %placeholder&#x27;,
              &#x27;severity&#x27;: parser.severity
            });
          }
        });
      }
    });
  });

  return result;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  }

  if (ast.content &#x26;&#x26; ast.content.length &#x3e; 0) {
ruleToggles = getToggledRules(ast);
isEnabledFilter = isResultEnabled(ruleToggles);

rules.forEach(function (rule) {
  detects = rule.rule.<span class="apidocCodeKeywordSpan">detect</span>(ast, rule)
    .filter(isEnabledFilter);
  results = results.concat(detects);
  if (detects.length) {
    if (rule.severity === 1) {
      warnings += detects.length;
    }
    else if (rule.severity === 2) {
...</pre></li>
    </ul>






</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.sass-lint.placeholder_name_format" id="apidoc.module.sass-lint.placeholder_name_format">module sass-lint.placeholder_name_format</a></h1>


    <h2>
        <a href="#apidoc.element.sass-lint.placeholder_name_format.detect" id="apidoc.element.sass-lint.placeholder_name_format.detect">
        function <span class="apidocSignatureSpan">sass-lint.placeholder_name_format.</span>detect
        <span class="apidocSignatureSpan">(ast, parser)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">detect = function (ast, parser) {
  var result = [];

  ast.traverseByType(&#x27;placeholder&#x27;, function (node) {
    var name = node.first().content,
        strippedName,
        violationMessage = false;

    if (node.first().is(&#x27;ident&#x27;)) {
      strippedName = name;
      if (parser.options[&#x27;allow-leading-underscore&#x27;] &#x26;&#x26; name[0] === &#x27;_&#x27;) {
        strippedName = name.slice(1);
      }

      switch (parser.options.convention) {
      case &#x27;hyphenatedlowercase&#x27;:
        if (!helpers.isHyphenatedLowercase(strippedName)) {
          violationMessage = &#x27;Placeholder \&#x27;%&#x27; + name + &#x27;\&#x27; should be written in lowercase with hyphens&#x27;;
        }
        break;
      case &#x27;camelcase&#x27;:
        if (!helpers.isCamelCase(strippedName)) {
          violationMessage = &#x27;Placeholder \&#x27;%&#x27; + name + &#x27;\&#x27; should be written in camelCase&#x27;;
        }
        break;
      case &#x27;pascalcase&#x27;:
        if (!helpers.isPascalCase(strippedName)) {
          violationMessage = &#x27;Placeholder \&#x27;%&#x27; + name + &#x27;\&#x27; should be written in PascalCase&#x27;;
        }
        break;
      case &#x27;snakecase&#x27;:
        if (!helpers.isSnakeCase(strippedName)) {
          violationMessage = &#x27;Placeholder \&#x27;%&#x27; + name + &#x27;\&#x27; should be written in snake_case&#x27;;
        }
        break;
      case &#x27;strictbem&#x27;:
        if (!helpers.isStrictBEM(strippedName)) {
          violationMessage = &#x27;Placeholder \&#x27;%&#x27; + name + &#x27;\&#x27; should be written in BEM (Block Element Modifier) format&#x27;;
        }
        break;
      case &#x27;hyphenatedbem&#x27;:
        if (!helpers.isHyphenatedBEM(strippedName)) {
          violationMessage = &#x27;Placeholder \&#x27;%&#x27; + name + &#x27;\&#x27; should be written in hyphenated BEM (Block Element Modifier) format&#x27;;
        }
        break;
      default:
        if (!(new RegExp(parser.options.convention).test(strippedName))) {
          violationMessage = &#x27;Placeholder \&#x27;%&#x27; + name + &#x27;\&#x27; should match regular expression /&#x27; + parser.options.convention + &#x27;/&#x27;;

          // convention-message overrides violationMessage
          if (parser.options[&#x27;convention-explanation&#x27;]) {
            violationMessage = parser.options[&#x27;convention-explanation&#x27;];
          }
        }
      }

      if (violationMessage) {
        result = helpers.addUnique(result, {
          &#x27;ruleId&#x27;: parser.rule.name,
          &#x27;line&#x27;: node.start.line,
          &#x27;column&#x27;: node.start.column,
          &#x27;message&#x27;: violationMessage,
          &#x27;severity&#x27;: parser.severity
        });
      }
    }
  });
  return result;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  }

  if (ast.content &#x26;&#x26; ast.content.length &#x3e; 0) {
ruleToggles = getToggledRules(ast);
isEnabledFilter = isResultEnabled(ruleToggles);

rules.forEach(function (rule) {
  detects = rule.rule.<span class="apidocCodeKeywordSpan">detect</span>(ast, rule)
    .filter(isEnabledFilter);
  results = results.concat(detects);
  if (detects.length) {
    if (rule.severity === 1) {
      warnings += detects.length;
    }
    else if (rule.severity === 2) {
...</pre></li>
    </ul>






</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.sass-lint.property_sort_order" id="apidoc.module.sass-lint.property_sort_order">module sass-lint.property_sort_order</a></h1>


    <h2>
        <a href="#apidoc.element.sass-lint.property_sort_order.detect" id="apidoc.element.sass-lint.property_sort_order.detect">
        function <span class="apidocSignatureSpan">sass-lint.property_sort_order.</span>detect
        <span class="apidocSignatureSpan">(ast, parser)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">detect = function (ast, parser) {
  var result = [],
      order = getOrderConfig(parser.options.order) || parser.options.order;

  ast.traverseByType(&#x27;block&#x27;, function (block) {
    var properties = {},
        sorted,
        pKeys,
        sKeys;

    if (block) {
      block.forEach(&#x27;declaration&#x27;, function (dec) {
        var prop = dec.first(&#x27;property&#x27;),
            name = prop.first(&#x27;ident&#x27;);

        if (name) {
          if (parser.options[&#x27;ignore-custom-properties&#x27;]) {
            if (propertyCheckList.indexOf(name.content) !== -1) {
              properties[name.content] = prop;
            }
          }
          else {
            properties[name.content] = prop;
          }
        }
      });

      sorted = sortProperties(properties, order);

      pKeys = Object.keys(properties);
      sKeys = Object.keys(sorted);

      sKeys.every(function (e, i) {
        var pKey = pKeys[i],
            prop = properties[pKey];

        if (e !== pKey) {
          result = helpers.addUnique(result, {
            &#x27;ruleId&#x27;: parser.rule.name,
            &#x27;line&#x27;: prop.start.line,
            &#x27;column&#x27;: prop.start.column,
            &#x27;message&#x27;: &#x27;Expected `&#x27; + e + &#x27;`, found `&#x27; + pKey + &#x27;`&#x27;,
            &#x27;severity&#x27;: parser.severity
          });
        }
        return true;
      });
    }
  });

  return result;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  }

  if (ast.content &#x26;&#x26; ast.content.length &#x3e; 0) {
ruleToggles = getToggledRules(ast);
isEnabledFilter = isResultEnabled(ruleToggles);

rules.forEach(function (rule) {
  detects = rule.rule.<span class="apidocCodeKeywordSpan">detect</span>(ast, rule)
    .filter(isEnabledFilter);
  results = results.concat(detects);
  if (detects.length) {
    if (rule.severity === 1) {
      warnings += detects.length;
    }
    else if (rule.severity === 2) {
...</pre></li>
    </ul>






</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.sass-lint.property_units" id="apidoc.module.sass-lint.property_units">module sass-lint.property_units</a></h1>


    <h2>
        <a href="#apidoc.element.sass-lint.property_units.detect" id="apidoc.element.sass-lint.property_units.detect">
        function <span class="apidocSignatureSpan">sass-lint.property_units.</span>detect
        <span class="apidocSignatureSpan">(ast, parser)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">detect = function (ast, parser) {
  var result = [],
      unitsAllowedGlobally = parser.options.global,
      unitsAllowedPerProperty = parser.options[&#x27;per-property&#x27;];

  ast.traverseByType(&#x27;declaration&#x27;, function (declaration) {
    var property = declaration.first(&#x27;property&#x27;),
        ident = property ? property.first(&#x27;ident&#x27;) : null,
        propertyName = ident ? ident.content : null,
        valueNode = declaration.first(&#x27;value&#x27;),
        hasDimension = valueNode ? !!valueNode.first(&#x27;dimension&#x27;) : null;
    if (propertyName &#x26;&#x26; hasDimension) {
      // properties such as box-shadow may have multiple dimensions defined so enumerate through them
      valueNode.forEach(&#x27;dimension&#x27;, function (dimension) {
        var dimensionIdent = dimension ? dimension.first(&#x27;ident&#x27;) : null,
            unitType = dimensionIdent ? dimensionIdent.content : null,
            unitsAllowed = unitsAllowedPerProperty[propertyName];
        // If a property is defined in unitsAllowed, then it will only validate those unit types
        if (unitType &#x26;&#x26; unitsAllowed) {
          if (unitsAllowed.indexOf(unitType) === -1) {
            result = helpers.addUnique(result, {
              &#x27;ruleId&#x27;: parser.rule.name,
              &#x27;severity&#x27;: parser.severity,
              &#x27;line&#x27;: dimension.start.line,
              &#x27;column&#x27;: dimension.start.column,
              &#x27;message&#x27;: &#x27;Values for property \&#x27;&#x27; + propertyName + &#x27;\&#x27; may not use &#x27; + unitType + &#x27; units&#x27;
            });
          }
        }
        // If no units are defined in unitsAllowedGlobally, then allow all of them
        // Otherwise, verify the given unit is in the unitsAllowedGlobally list.
        else if (unitType &#x26;&#x26; unitsAllowedGlobally.length &#x26;&#x26; unitsAllowedGlobally.indexOf(unitType) === -1) {
          result = helpers.addUnique(result, {
            &#x27;ruleId&#x27;: parser.rule.name,
            &#x27;severity&#x27;: parser.severity,
            &#x27;line&#x27;: dimension.start.line,
            &#x27;column&#x27;: dimension.start.column,
            &#x27;message&#x27;: &#x27;Values for property \&#x27;&#x27; + propertyName + &#x27;\&#x27; may not use &#x27; + unitType + &#x27; units&#x27;
          });
        }
      });
    }
  });
  return result;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  }

  if (ast.content &#x26;&#x26; ast.content.length &#x3e; 0) {
ruleToggles = getToggledRules(ast);
isEnabledFilter = isResultEnabled(ruleToggles);

rules.forEach(function (rule) {
  detects = rule.rule.<span class="apidocCodeKeywordSpan">detect</span>(ast, rule)
    .filter(isEnabledFilter);
  results = results.concat(detects);
  if (detects.length) {
    if (rule.severity === 1) {
      warnings += detects.length;
    }
    else if (rule.severity === 2) {
...</pre></li>
    </ul>






</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.sass-lint.pseudo_element" id="apidoc.module.sass-lint.pseudo_element">module sass-lint.pseudo_element</a></h1>


    <h2>
        <a href="#apidoc.element.sass-lint.pseudo_element.detect" id="apidoc.element.sass-lint.pseudo_element.detect">
        function <span class="apidocSignatureSpan">sass-lint.pseudo_element.</span>detect
        <span class="apidocSignatureSpan">(ast, parser)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">detect = function (ast, parser) {
  var result = [];

  ast.traverseByType(&#x27;pseudoClass&#x27;, function (node) {
    if (isPseudoElement(node.content[0].content)) {
      result = helpers.addUnique(result, {
        &#x27;ruleId&#x27;: parser.rule.name,
        &#x27;line&#x27;: node.start.line,
        &#x27;column&#x27;: node.start.column,
        &#x27;message&#x27;: &#x27;Pseudo-elements must start with double colons&#x27;,
        &#x27;severity&#x27;: parser.severity
      });
    }
  });

  ast.traverseByType(&#x27;pseudoElement&#x27;, function (node) {
    if (isPseudoClass(node.content[0].content)) {
      result = helpers.addUnique(result, {
        &#x27;ruleId&#x27;: parser.rule.name,
        &#x27;line&#x27;: node.start.line,
        &#x27;column&#x27;: node.start.column,
        &#x27;message&#x27;: &#x27;Pseudo-classes must start with a single colon&#x27;,
        &#x27;severity&#x27;: parser.severity
      });
    }
  });

  return result;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  }

  if (ast.content &#x26;&#x26; ast.content.length &#x3e; 0) {
ruleToggles = getToggledRules(ast);
isEnabledFilter = isResultEnabled(ruleToggles);

rules.forEach(function (rule) {
  detects = rule.rule.<span class="apidocCodeKeywordSpan">detect</span>(ast, rule)
    .filter(isEnabledFilter);
  results = results.concat(detects);
  if (detects.length) {
    if (rule.severity === 1) {
      warnings += detects.length;
    }
    else if (rule.severity === 2) {
...</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.sass-lint.quotes" id="apidoc.module.sass-lint.quotes">module sass-lint.quotes</a></h1>


    <h2>
        <a href="#apidoc.element.sass-lint.quotes.detect" id="apidoc.element.sass-lint.quotes.detect">
        function <span class="apidocSignatureSpan">sass-lint.quotes.</span>detect
        <span class="apidocSignatureSpan">(ast, parser)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">detect = function (ast, parser) {
  var result = [];

  ast.traverseByType(&#x27;string&#x27;, function (node) {
    var firstQuote = node.content.charAt(0),
        lastQuote = node.content.charAt(node.content.length - 1);

    if (firstQuote !== lastQuote) {
      result = helpers.addUnique(result, {
        &#x27;ruleId&#x27;: parser.rule.name,
        &#x27;line&#x27;: node.start.line,
        &#x27;column&#x27;: node.start.column,
        &#x27;message&#x27;: &#x27;Mixed quote styles&#x27;,
        &#x27;severity&#x27;: parser.severity
      });
    }

    if (parser.options.style === &#x27;single&#x27; &#x26;&#x26; firstQuote !== &#x27;\&#x27;&#x27;) {
      result = helpers.addUnique(result, {
        &#x27;ruleId&#x27;: parser.rule.name,
        &#x27;line&#x27;: node.start.line,
        &#x27;column&#x27;: node.start.column,
        &#x27;message&#x27;: &#x27;Strings must use single quotes&#x27;,
        &#x27;severity&#x27;: parser.severity
      });
    }
    else if (parser.options.style === &#x27;double&#x27; &#x26;&#x26; firstQuote !== &#x27;&#x22;&#x27;) {
      result = helpers.addUnique(result, {
        &#x27;ruleId&#x27;: parser.rule.name,
        &#x27;line&#x27;: node.start.line,
        &#x27;column&#x27;: node.start.column,
        &#x27;message&#x27;: &#x27;Strings must use double quotes&#x27;,
        &#x27;severity&#x27;: parser.severity
      });
    }
  });

  return result;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  }

  if (ast.content &#x26;&#x26; ast.content.length &#x3e; 0) {
ruleToggles = getToggledRules(ast);
isEnabledFilter = isResultEnabled(ruleToggles);

rules.forEach(function (rule) {
  detects = rule.rule.<span class="apidocCodeKeywordSpan">detect</span>(ast, rule)
    .filter(isEnabledFilter);
  results = results.concat(detects);
  if (detects.length) {
    if (rule.severity === 1) {
      warnings += detects.length;
    }
    else if (rule.severity === 2) {
...</pre></li>
    </ul>






</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.sass-lint.ruleToggler" id="apidoc.module.sass-lint.ruleToggler">module sass-lint.ruleToggler</a></h1>


    <h2>
        <a href="#apidoc.element.sass-lint.ruleToggler.getToggledRules" id="apidoc.element.sass-lint.ruleToggler.getToggledRules">
        function <span class="apidocSignatureSpan">sass-lint.ruleToggler.</span>getToggledRules
        <span class="apidocSignatureSpan">(ast)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getToggledRules = function (ast) {
  var toggledRules = {
    ruleEnable: {
      // Format in here is [isEnabled, line, column]
    },
    globalEnable: []
  };
  if (!ast.traverseByTypes) {
    return toggledRules;
  }
  ast.traverseByTypes([&#x27;multilineComment&#x27;, &#x27;singlelineComment&#x27;], function (comment, i, parent) {
    var content = comment.content;
    if (!content) {
      return;
    }
    var tokens = content.split(/[\s,]+/)
      .filter(function (s) {
        return s.trim().length &#x3e; 0;
      });
    if (!tokens.length) {
      return;
    }
    var first = tokens[0],
        rules = tokens.slice(1);
    switch (first) {
    case &#x27;sass-lint:disable&#x27;:
      addDisable(toggledRules, rules, comment.start.line, comment.start.column);
      break;
    case &#x27;sass-lint:enable&#x27;:
      addEnable(toggledRules, rules, comment.start.line, comment.start.column);
      break;
    case &#x27;sass-lint:disable-block&#x27;:
      // future ref: not sure what the appropriate behavior is if there is no parent block; currently NPEs
      addDisableBlock(toggledRules, rules, parent);
      break;
    case &#x27;sass-lint:disable-all&#x27;:
      addDisableAll(toggledRules, comment.start.line, comment.start.column);
      break;
    case &#x27;sass-lint:enable-all&#x27;:
      addEnableAll(toggledRules, comment.start.line, comment.start.column);
      break;
    case &#x27;sass-lint:disable-line&#x27;:
      addDisableLine(toggledRules, rules, comment.start.line);
      break;
    default:
      return;
    }
  });
  // Sort these toggle stacks so reading them is easier (algorithmically).
  // Usually already sorted but since it&#x27;s not guaranteed by the contract with gonzales-pe, ensuring it is.
  toggledRules.globalEnable.sort(sortRange);
  Object.keys(toggledRules.ruleEnable).map(function (ruleId) {
    toggledRules.ruleEnable[ruleId].sort(sortRange);
  });
  return toggledRules;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.sass-lint.ruleToggler.isResultEnabled" id="apidoc.element.sass-lint.ruleToggler.isResultEnabled">
        function <span class="apidocSignatureSpan">sass-lint.ruleToggler.</span>isResultEnabled
        <span class="apidocSignatureSpan">(toggledRules)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isResultEnabled = function (toggledRules) {
  return function (ruleResult) {
    var ruleId = ruleResult.ruleId;
    // Convention: if no column or line, assume rule is targetting 1.
    var line = ruleResult.line || 1;
    var column = ruleResult.column || 1;
    var isGloballyEnabled = toggledRules.globalEnable
      .reduce(function (acc, toggleRange) {
        return isBeforeOrSame(line, column, toggleRange[1], toggleRange[2])
          ? acc
          : toggleRange[0];
      }, true);
    if (!isGloballyEnabled) {
      return false;
    }
    if (!toggledRules.ruleEnable[ruleId]) {
      return true;
    }
    var isRuleEnabled = toggledRules.ruleEnable[ruleId]
      .reduce(function (acc, toggleRange) {
        return isBeforeOrSame(line, column, toggleRange[1], toggleRange[2])
          ? acc
          : toggleRange[0];
      }, true);
    if (!isRuleEnabled) {
      return false;
    }
    return true;
  };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.sass-lint.selector_helpers" id="apidoc.module.sass-lint.selector_helpers">module sass-lint.selector_helpers</a></h1>


    <h2>
        <a href="#apidoc.element.sass-lint.selector_helpers.constructSelector" id="apidoc.element.sass-lint.selector_helpers.constructSelector">
        function <span class="apidocSignatureSpan">sass-lint.selector_helpers.</span>constructSelector
        <span class="apidocSignatureSpan">(val)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">constructSelector = function (val) {
  var content = null;

  if (val.is(&#x27;arguments&#x27;)) {
    content = constructSubSelector(val, &#x27;(&#x27;, &#x27;)&#x27;, constructSelector);
  }

  else if (val.is(&#x27;atkeyword&#x27;)) {
    content = constructSubSelector(val, &#x27;@&#x27;, &#x27;&#x27;, constructSelector);
  }

  else if (val.is(&#x27;attributeSelector&#x27;)) {
    content = constructSubSelector(val, &#x27;[&#x27;, &#x27;]&#x27;, constructSelector);
  }

  else if (val.is(&#x27;class&#x27;)) {
    content = addGrammar(val, &#x27;.&#x27;, &#x27;&#x27;);
  }

  else if (val.is(&#x27;id&#x27;)) {
    content = addGrammar(val, &#x27;#&#x27;, &#x27;&#x27;);
  }

  else if (val.is(&#x27;interpolation&#x27;)) {
    content = constructSubSelector(val, &#x27;#{&#x27;, &#x27;}&#x27;, constructSelector);
  }

  else if (val.is(&#x27;nth&#x27;)) {
    content = addGrammar(val, &#x27;(&#x27;, &#x27;)&#x27;);
  }

  else if (val.is(&#x27;nthSelector&#x27;)) {
    content = constructSubSelector(val, &#x27;:&#x27;, &#x27;&#x27;, constructSelector);
  }

  else if (val.is(&#x27;parentheses&#x27;)) {
    content = constructSubSelector(val, &#x27;(&#x27;, &#x27;)&#x27;, constructSelector);
  }

  else if (val.is(&#x27;placeholder&#x27;)) {
    content = constructSubSelector(val, &#x27;%&#x27;, &#x27;&#x27;, constructSelector);
  }

  else if (val.is(&#x27;pseudoClass&#x27;)) {
    content = constructSubSelector(val, &#x27;:&#x27;, &#x27;&#x27;, constructSelector);
  }

  else if (val.is(&#x27;pseudoElement&#x27;)) {
    content = addGrammar(val, &#x27;::&#x27;, &#x27;&#x27;);
  }

  else if (val.is(&#x27;space&#x27;)) {
    content = &#x27; &#x27;;
  }

  else if (val.is(&#x27;variable&#x27;)) {
    content = constructSubSelector(val, &#x27;$&#x27;, &#x27;&#x27;, constructSelector);
  }

  else if (simpleIdents.indexOf(val.type) !== -1) {
    content = val.content;
  }

  else if (subSelectors.indexOf(val.type) !== -1) {
    content = constructSubSelector(val, &#x27;&#x27;, &#x27;&#x27;, constructSelector);
  }

  return content;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    ast.traverseByTypes([&#x27;ruleset&#x27;, &#x27;placeholder&#x27;], function (node) {
var name,
    depth,
    selectorAndExtensions,
    maxDepth = parser.options[&#x27;max-depth&#x27;];

if (node.is(&#x27;placeholder&#x27;)) {
  name = selectorHelpers.<span class="apidocCodeKeywordSpan">constructSelector</span>(node);
  if (name) {
    depth = bemDepth(name);
    if (depth &#x3e; maxDepth) {
      result = helpers.addUnique(result, {
        &#x27;ruleId&#x27;: parser.rule.name,
        &#x27;line&#x27;: node.start.line,
        &#x27;column&#x27;: node.start.column,
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.sass-lint.shorthand_values" id="apidoc.module.sass-lint.shorthand_values">module sass-lint.shorthand_values</a></h1>


    <h2>
        <a href="#apidoc.element.sass-lint.shorthand_values.detect" id="apidoc.element.sass-lint.shorthand_values.detect">
        function <span class="apidocSignatureSpan">sass-lint.shorthand_values.</span>detect
        <span class="apidocSignatureSpan">(ast, parser)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">detect = function (ast, parser) {
  var result = [];

  ast.traverseByType(&#x27;declaration&#x27;, function (declaration) {
    var isShorthandProperty = false,
        property;

    declaration.traverse(function (item) {

      if (item.is(&#x27;property&#x27;)) {
        item.traverse(function (child) {
          // check if the property is a possible shorthand property
          if (shortVals.indexOf(child.content) !== -1) {
            isShorthandProperty = true;

            // store a reference to the property for our error
            property = shortVals[shortVals.indexOf(child.content)];
          }
        });
      }

      if (isShorthandProperty) {
        var value = [];

        if (item.is(&#x27;value&#x27;)) {
          var node = item.content;

          // Build each value into an array of strings with value and type
          value = scanValue(node);

          if (value.length &#x3c;= 4 &#x26;&#x26; value.length &#x3e;= 1) {
            var output = [];

            // check which values can condense
            if (condenseToOne(value, parser.options[&#x27;allowed-shorthands&#x27;])) {
              output = [value[0]];
            }
            else if (condenseToTwo(value, parser.options[&#x27;allowed-shorthands&#x27;])) {
              output = [value[0], value[1]];
            }
            else if (condenseToThree(value, parser.options[&#x27;allowed-shorthands&#x27;])) {
              output = [value[0], value[1], value[2]];
            }

            if (output.length) {
              result = helpers.addUnique(result, {
                &#x27;ruleId&#x27;: parser.rule.name,
                &#x27;line&#x27;: item.start.line,
                &#x27;column&#x27;: item.start.column,
                &#x27;message&#x27;: &#x27;Property `&#x27; + property + &#x27;` should be written more concisely as `&#x27; + output.join(&#x27; &#x27;) + &#x27;` instead of
 `&#x27; + value.join(&#x27; &#x27;) + &#x27;`&#x27;,
                &#x27;severity&#x27;: parser.severity
              });
            }
          }
        }
      }
    });
  });
  return result;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  }

  if (ast.content &#x26;&#x26; ast.content.length &#x3e; 0) {
ruleToggles = getToggledRules(ast);
isEnabledFilter = isResultEnabled(ruleToggles);

rules.forEach(function (rule) {
  detects = rule.rule.<span class="apidocCodeKeywordSpan">detect</span>(ast, rule)
    .filter(isEnabledFilter);
  results = results.concat(detects);
  if (detects.length) {
    if (rule.severity === 1) {
      warnings += detects.length;
    }
    else if (rule.severity === 2) {
...</pre></li>
    </ul>






</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.sass-lint.single_line_per_selector" id="apidoc.module.sass-lint.single_line_per_selector">module sass-lint.single_line_per_selector</a></h1>


    <h2>
        <a href="#apidoc.element.sass-lint.single_line_per_selector.detect" id="apidoc.element.sass-lint.single_line_per_selector.detect">
        function <span class="apidocSignatureSpan">sass-lint.single_line_per_selector.</span>detect
        <span class="apidocSignatureSpan">(ast, parser)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">detect = function (ast, parser) {
  var result = [];

  ast.traverseByType(&#x27;ruleset&#x27;, function (ruleset) {
    ruleset.forEach(&#x27;delimiter&#x27;, function (delimiter, j) {
      var next = checkLineForSelector(ruleset, j);

      if (next) {
        result = helpers.addUnique(result, {
          &#x27;ruleId&#x27;: parser.rule.name,
          &#x27;line&#x27;: next.start.line,
          &#x27;column&#x27;: next.start.column,
          &#x27;message&#x27;: &#x27;Selectors must be placed on new lines&#x27;,
          &#x27;severity&#x27;: parser.severity
        });
      }
    });
  });

  return result;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  }

  if (ast.content &#x26;&#x26; ast.content.length &#x3e; 0) {
ruleToggles = getToggledRules(ast);
isEnabledFilter = isResultEnabled(ruleToggles);

rules.forEach(function (rule) {
  detects = rule.rule.<span class="apidocCodeKeywordSpan">detect</span>(ast, rule)
    .filter(isEnabledFilter);
  results = results.concat(detects);
  if (detects.length) {
    if (rule.severity === 1) {
      warnings += detects.length;
    }
    else if (rule.severity === 2) {
...</pre></li>
    </ul>






</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.sass-lint.space_after_bang" id="apidoc.module.sass-lint.space_after_bang">module sass-lint.space_after_bang</a></h1>


    <h2>
        <a href="#apidoc.element.sass-lint.space_after_bang.detect" id="apidoc.element.sass-lint.space_after_bang.detect">
        function <span class="apidocSignatureSpan">sass-lint.space_after_bang.</span>detect
        <span class="apidocSignatureSpan">(ast, parser)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">detect = function (ast, parser) {
  var result = [],
      regex = /!\s/;

  ast.traverseByTypes([&#x27;important&#x27;, &#x27;default&#x27;, &#x27;global&#x27;, &#x27;optional&#x27;], function (block) {
    if (block.content.match(regex) !== null) {
      if (parser.options.include) {
        result = helpers.addUnique(result, {
          &#x27;ruleId&#x27;: parser.rule.name,
          &#x27;line&#x27;: block.start.line,
          &#x27;column&#x27;: block.start.column + 1,
          &#x27;message&#x27;: &#x27;Bangs (!) should be followed by a space&#x27;,
          &#x27;severity&#x27;: parser.severity
        });
      }
      else {
        result = helpers.addUnique(result, {
          &#x27;ruleId&#x27;: parser.rule.name,
          &#x27;line&#x27;: block.start.line,
          &#x27;column&#x27;: block.start.column,
          &#x27;message&#x27;: &#x27;Bangs (!) should not be followed by a space&#x27;,
          &#x27;severity&#x27;: parser.severity
        });
      }
    }
  });

  return result;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  }

  if (ast.content &#x26;&#x26; ast.content.length &#x3e; 0) {
ruleToggles = getToggledRules(ast);
isEnabledFilter = isResultEnabled(ruleToggles);

rules.forEach(function (rule) {
  detects = rule.rule.<span class="apidocCodeKeywordSpan">detect</span>(ast, rule)
    .filter(isEnabledFilter);
  results = results.concat(detects);
  if (detects.length) {
    if (rule.severity === 1) {
      warnings += detects.length;
    }
    else if (rule.severity === 2) {
...</pre></li>
    </ul>






</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.sass-lint.space_after_colon" id="apidoc.module.sass-lint.space_after_colon">module sass-lint.space_after_colon</a></h1>


    <h2>
        <a href="#apidoc.element.sass-lint.space_after_colon.detect" id="apidoc.element.sass-lint.space_after_colon.detect">
        function <span class="apidocSignatureSpan">sass-lint.space_after_colon.</span>detect
        <span class="apidocSignatureSpan">(ast, parser)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">detect = function (ast, parser) {
  var result = [];

  ast.traverseByTypes([&#x27;propertyDelimiter&#x27;, &#x27;operator&#x27;], function (delimiter, i, parent) {
    if (delimiter.content === &#x27;:&#x27;) {
      var next = parent.content[i + 1];

      if (next &#x26;&#x26; next.is(&#x27;space&#x27;)) {
        if (!parser.options.include) {
          result = helpers.addUnique(result, {
            &#x27;ruleId&#x27;: parser.rule.name,
            &#x27;line&#x27;: next.start.line,
            &#x27;column&#x27;: next.start.column,
            &#x27;message&#x27;: &#x27;No space allowed after `:`&#x27;,
            &#x27;severity&#x27;: parser.severity
          });
        }
      }
      else {
        if (parser.options.include) {
          result = helpers.addUnique(result, {
            &#x27;ruleId&#x27;: parser.rule.name,
            &#x27;line&#x27;: delimiter.start.line,
            &#x27;column&#x27;: delimiter.start.column,
            &#x27;message&#x27;: &#x27;Space expected after `:`&#x27;,
            &#x27;severity&#x27;: parser.severity
          });
        }
      }
    }
  });

  return result;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  }

  if (ast.content &#x26;&#x26; ast.content.length &#x3e; 0) {
ruleToggles = getToggledRules(ast);
isEnabledFilter = isResultEnabled(ruleToggles);

rules.forEach(function (rule) {
  detects = rule.rule.<span class="apidocCodeKeywordSpan">detect</span>(ast, rule)
    .filter(isEnabledFilter);
  results = results.concat(detects);
  if (detects.length) {
    if (rule.severity === 1) {
      warnings += detects.length;
    }
    else if (rule.severity === 2) {
...</pre></li>
    </ul>






</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.sass-lint.space_after_comma" id="apidoc.module.sass-lint.space_after_comma">module sass-lint.space_after_comma</a></h1>


    <h2>
        <a href="#apidoc.element.sass-lint.space_after_comma.detect" id="apidoc.element.sass-lint.space_after_comma.detect">
        function <span class="apidocSignatureSpan">sass-lint.space_after_comma.</span>detect
        <span class="apidocSignatureSpan">(ast, parser)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">detect = function (ast, parser) {
  var result = [];

  ast.traverseByTypes([&#x27;operator&#x27;, &#x27;delimiter&#x27;], function (operator, i, parent) {
    var next,
        doubleNext;

    if (operator.content === &#x27;,&#x27;) {
      next = parent.content[i + 1] || false;
      doubleNext = parent.content[i + 2] || false;

      if (next) {
        if (operator.is(&#x27;delimiter&#x27;)) {
          if (next.is(&#x27;selector&#x27;)) {
            next = next.content[0];
          }
        }

        if ((next.is(&#x27;space&#x27;) &#x26;&#x26; !helpers.hasEOL(next.content)) &#x26;&#x26; !parser.options.include) {
          if (doubleNext &#x26;&#x26; doubleNext.is(&#x27;singlelineComment&#x27;)) {
            return false;
          }

          result = helpers.addUnique(result, {
            &#x27;ruleId&#x27;: parser.rule.name,
            &#x27;line&#x27;: next.start.line,
            &#x27;column&#x27;: next.start.column,
            &#x27;message&#x27;: &#x27;Commas should not be followed by a space&#x27;,
            &#x27;severity&#x27;: parser.severity
          });
        }

        if (!next.is(&#x27;space&#x27;) &#x26;&#x26; parser.options.include) {
          result = helpers.addUnique(result, {
            &#x27;ruleId&#x27;: parser.rule.name,
            &#x27;line&#x27;: operator.start.line,
            &#x27;column&#x27;: operator.start.column,
            &#x27;message&#x27;: &#x27;Commas should be followed by a space&#x27;,
            &#x27;severity&#x27;: parser.severity
          });
        }
      }
    }
    return true;
  });

  return result;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  }

  if (ast.content &#x26;&#x26; ast.content.length &#x3e; 0) {
ruleToggles = getToggledRules(ast);
isEnabledFilter = isResultEnabled(ruleToggles);

rules.forEach(function (rule) {
  detects = rule.rule.<span class="apidocCodeKeywordSpan">detect</span>(ast, rule)
    .filter(isEnabledFilter);
  results = results.concat(detects);
  if (detects.length) {
    if (rule.severity === 1) {
      warnings += detects.length;
    }
    else if (rule.severity === 2) {
...</pre></li>
    </ul>






</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.sass-lint.space_around_operator" id="apidoc.module.sass-lint.space_around_operator">module sass-lint.space_around_operator</a></h1>


    <h2>
        <a href="#apidoc.element.sass-lint.space_around_operator.detect" id="apidoc.element.sass-lint.space_around_operator.detect">
        function <span class="apidocSignatureSpan">sass-lint.space_around_operator.</span>detect
        <span class="apidocSignatureSpan">(ast, parser)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">detect = function (ast, parser) {
  var result = [];

  ast.traverseByTypes([&#x27;condition&#x27;, &#x27;atrule&#x27;, &#x27;value&#x27;], function (node) {
    node.forEach(function (item, i, parent) {
      // Perform another loop of the children if we come across a parenthesis
      // parent node
      if (item.is(&#x27;parentheses&#x27;)) {
        item.forEach(function (child, j, childParent) {
          // Do the spacing checks
          checkSpacing(child, j, childParent, parser, result);
        });
      }
      else {
        // Do the spacing checks
        checkSpacing(item, i, parent, parser, result);
      }
    });
  });

  return result;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  }

  if (ast.content &#x26;&#x26; ast.content.length &#x3e; 0) {
ruleToggles = getToggledRules(ast);
isEnabledFilter = isResultEnabled(ruleToggles);

rules.forEach(function (rule) {
  detects = rule.rule.<span class="apidocCodeKeywordSpan">detect</span>(ast, rule)
    .filter(isEnabledFilter);
  results = results.concat(detects);
  if (detects.length) {
    if (rule.severity === 1) {
      warnings += detects.length;
    }
    else if (rule.severity === 2) {
...</pre></li>
    </ul>






</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.sass-lint.space_before_bang" id="apidoc.module.sass-lint.space_before_bang">module sass-lint.space_before_bang</a></h1>


    <h2>
        <a href="#apidoc.element.sass-lint.space_before_bang.detect" id="apidoc.element.sass-lint.space_before_bang.detect">
        function <span class="apidocSignatureSpan">sass-lint.space_before_bang.</span>detect
        <span class="apidocSignatureSpan">(ast, parser)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">detect = function (ast, parser) {
  var result = [];

  ast.traverseByTypes([&#x27;important&#x27;, &#x27;default&#x27;], function (block, i, parent) {
    var previous = parent.content[i - 1];

    if (!previous.is(&#x27;space&#x27;)) {
      if (parser.options.include) {
        result = helpers.addUnique(result, {
          &#x27;ruleId&#x27;: parser.rule.name,
          &#x27;line&#x27;: block.start.line,
          &#x27;column&#x27;: block.start.column,
          &#x27;message&#x27;: &#x27;Whitespace required before !important&#x27;,
          &#x27;severity&#x27;: parser.severity
        });
      }
    }
    else {
      if (!parser.options.include) {
        result = helpers.addUnique(result, {
          &#x27;ruleId&#x27;: parser.rule.name,
          &#x27;line&#x27;: previous.start.line,
          &#x27;column&#x27;: previous.start.column,
          &#x27;message&#x27;: &#x27;Whitespace not allowed before !important&#x27;,
          &#x27;severity&#x27;: parser.severity
        });
      }
    }
  });

  return result;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  }

  if (ast.content &#x26;&#x26; ast.content.length &#x3e; 0) {
ruleToggles = getToggledRules(ast);
isEnabledFilter = isResultEnabled(ruleToggles);

rules.forEach(function (rule) {
  detects = rule.rule.<span class="apidocCodeKeywordSpan">detect</span>(ast, rule)
    .filter(isEnabledFilter);
  results = results.concat(detects);
  if (detects.length) {
    if (rule.severity === 1) {
      warnings += detects.length;
    }
    else if (rule.severity === 2) {
...</pre></li>
    </ul>






</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.sass-lint.space_before_brace" id="apidoc.module.sass-lint.space_before_brace">module sass-lint.space_before_brace</a></h1>


    <h2>
        <a href="#apidoc.element.sass-lint.space_before_brace.detect" id="apidoc.element.sass-lint.space_before_brace.detect">
        function <span class="apidocSignatureSpan">sass-lint.space_before_brace.</span>detect
        <span class="apidocSignatureSpan">(ast, parser)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">detect = function (ast, parser) {
  var result = [];
  if (ast.syntax === &#x27;scss&#x27;) {
    ast.traverseByTypes([&#x27;block&#x27;, &#x27;atrulers&#x27;, &#x27;declaration&#x27;], function (block, i, parent) {
      var previous = false,
          whitespace,
          warn = {};

      if ((block.is(&#x27;block&#x27;) || block.is(&#x27;atrulers&#x27;)) &#x26;&#x26; !parent.is(&#x27;value&#x27;)) {
        previous = parent.get(i - 1);
      }
      else if (block.is(&#x27;declaration&#x27;)) {
        if (block.contains(&#x27;value&#x27;)) {
          for (var j = 0; j &#x3c; block.content.length; j++) {
            if (block.content[j].is(&#x27;value&#x27;) &#x26;&#x26; block.content[j].content[0].is(&#x27;block&#x27;)) {
              previous = block.content[j - 1];
              warn.line = block.content[j].content[0].start.line;
              warn.col = block.content[j].content[0].start.column;
            }
          }
        }
      }
      whitespace = getLastWhitespace(previous);
      if (whitespace === false) {
        if (parser.options.include) {
          if (!warn.hasOwnProperty(&#x27;line&#x27;)) {
            warn.line = block.start.line;
            warn.col = block.start.column;
          }
          result = helpers.addUnique(result, {
            &#x27;ruleId&#x27;: parser.rule.name,
            &#x27;line&#x27;: warn.line,
            &#x27;column&#x27;: warn.col - 1,
            &#x27;message&#x27;: &#x27;Whitespace required before {&#x27;,
            &#x27;severity&#x27;: parser.severity
          });
        }
      }
      else {
        if (!parser.options.include &#x26;&#x26; whitespace !== null) {
          result = helpers.addUnique(result, {
            &#x27;ruleId&#x27;: parser.rule.name,
            &#x27;line&#x27;: whitespace.start.line,
            &#x27;column&#x27;: whitespace.start.column,
            &#x27;message&#x27;: &#x27;Whitespace not allowed before {&#x27;,
            &#x27;severity&#x27;: parser.severity
          });
        }
      }
    });
  }
  return result;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  }

  if (ast.content &#x26;&#x26; ast.content.length &#x3e; 0) {
ruleToggles = getToggledRules(ast);
isEnabledFilter = isResultEnabled(ruleToggles);

rules.forEach(function (rule) {
  detects = rule.rule.<span class="apidocCodeKeywordSpan">detect</span>(ast, rule)
    .filter(isEnabledFilter);
  results = results.concat(detects);
  if (detects.length) {
    if (rule.severity === 1) {
      warnings += detects.length;
    }
    else if (rule.severity === 2) {
...</pre></li>
    </ul>






</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.sass-lint.space_before_colon" id="apidoc.module.sass-lint.space_before_colon">module sass-lint.space_before_colon</a></h1>


    <h2>
        <a href="#apidoc.element.sass-lint.space_before_colon.detect" id="apidoc.element.sass-lint.space_before_colon.detect">
        function <span class="apidocSignatureSpan">sass-lint.space_before_colon.</span>detect
        <span class="apidocSignatureSpan">(ast, parser)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">detect = function (ast, parser) {
  var result = [];

  ast.traverseByTypes([&#x27;propertyDelimiter&#x27;, &#x27;operator&#x27;], function (delimiter, i, parent) {
    if (delimiter.content === &#x27;:&#x27;) {
      var previous = parent.content[i - 1];

      if (previous &#x26;&#x26; previous.is(&#x27;space&#x27;)) {
        if (!parser.options.include) {
          result = helpers.addUnique(result, {
            &#x27;ruleId&#x27;: parser.rule.name,
            &#x27;line&#x27;: previous.start.line,
            &#x27;column&#x27;: previous.start.column,
            &#x27;message&#x27;: &#x27;No space allowed before `:`&#x27;,
            &#x27;severity&#x27;: parser.severity
          });
        }
      }
      else {
        if (parser.options.include) {
          result = helpers.addUnique(result, {
            &#x27;ruleId&#x27;: parser.rule.name,
            &#x27;line&#x27;: delimiter.start.line,
            &#x27;column&#x27;: delimiter.start.column - 1,
            &#x27;message&#x27;: &#x27;Space expected before `:`&#x27;,
            &#x27;severity&#x27;: parser.severity
          });
        }
      }
    }
  });

  return result;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  }

  if (ast.content &#x26;&#x26; ast.content.length &#x3e; 0) {
ruleToggles = getToggledRules(ast);
isEnabledFilter = isResultEnabled(ruleToggles);

rules.forEach(function (rule) {
  detects = rule.rule.<span class="apidocCodeKeywordSpan">detect</span>(ast, rule)
    .filter(isEnabledFilter);
  results = results.concat(detects);
  if (detects.length) {
    if (rule.severity === 1) {
      warnings += detects.length;
    }
    else if (rule.severity === 2) {
...</pre></li>
    </ul>






</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.sass-lint.space_between_parens" id="apidoc.module.sass-lint.space_between_parens">module sass-lint.space_between_parens</a></h1>


    <h2>
        <a href="#apidoc.element.sass-lint.space_between_parens.detect" id="apidoc.element.sass-lint.space_between_parens.detect">
        function <span class="apidocSignatureSpan">sass-lint.space_between_parens.</span>detect
        <span class="apidocSignatureSpan">(ast, parser)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">detect = function (ast, parser) {
  var result = [];

  ast.traverseByType(&#x27;arguments&#x27;, function (args) {
    var first = args.first(),
        last = args.last();

    if (args.length === 0) {
      return;
    }

    if (parser.options.include) {
      if (!first.is(&#x27;space&#x27;)) {
        result = helpers.addUnique(result, {
          &#x27;ruleId&#x27;: parser.rule.name,
          &#x27;line&#x27;: first.start.line,
          &#x27;column&#x27;: first.start.column - 1,
          &#x27;message&#x27;: &#x27;Space expected at beginning of parenthesis&#x27;,
          &#x27;severity&#x27;: parser.severity
        });
      }
      if (!last.is(&#x27;space&#x27;)) {
        result = helpers.addUnique(result, {
          &#x27;ruleId&#x27;: parser.rule.name,
          &#x27;line&#x27;: last.end.line,
          &#x27;column&#x27;: last.end.column,
          &#x27;message&#x27;: &#x27;Space expected at end of parenthesis&#x27;,
          &#x27;severity&#x27;: parser.severity
        });
      }
    }
    else {
      // Ignore if arguments are multi-line
      if (first.is(&#x27;space&#x27;) &#x26;&#x26; !helpers.hasEOL(first.content)) {
        result = helpers.addUnique(result, {
          &#x27;ruleId&#x27;: parser.rule.name,
          &#x27;line&#x27;: first.start.line,
          &#x27;column&#x27;: first.start.column,
          &#x27;message&#x27;: &#x27;No space allowed at beginning of parenthesis&#x27;,
          &#x27;severity&#x27;: parser.severity
        });
      }
      if (last.is(&#x27;space&#x27;)) {
        // Proceed if arguments aren&#x27;t multi-line.
        // With Sass we have one extra check for nested nodes where we must
        // check doublePrevious as the last node will be the indentation
        if (
          (ast.syntax === &#x27;scss&#x27; &#x26;&#x26; !helpers.hasEOL(last.content))
          || (ast.syntax === &#x27;sass&#x27; &#x26;&#x26; !helpers.hasEOL(last.content) &#x26;&#x26; !helpers.hasEOL(args.content[args.content.length - 2].content
))
        ) {
          result = helpers.addUnique(result, {
            &#x27;ruleId&#x27;: parser.rule.name,
            &#x27;line&#x27;: last.start.line,
            &#x27;column&#x27;: last.start.column,
            &#x27;message&#x27;: &#x27;No space allowed at end of parenthesis&#x27;,
            &#x27;severity&#x27;: parser.severity
          });
        }
      }
    }
  });

  return result;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  }

  if (ast.content &#x26;&#x26; ast.content.length &#x3e; 0) {
ruleToggles = getToggledRules(ast);
isEnabledFilter = isResultEnabled(ruleToggles);

rules.forEach(function (rule) {
  detects = rule.rule.<span class="apidocCodeKeywordSpan">detect</span>(ast, rule)
    .filter(isEnabledFilter);
  results = results.concat(detects);
  if (detects.length) {
    if (rule.severity === 1) {
      warnings += detects.length;
    }
    else if (rule.severity === 2) {
...</pre></li>
    </ul>






</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.sass-lint.trailing_semicolon" id="apidoc.module.sass-lint.trailing_semicolon">module sass-lint.trailing_semicolon</a></h1>


    <h2>
        <a href="#apidoc.element.sass-lint.trailing_semicolon.detect" id="apidoc.element.sass-lint.trailing_semicolon.detect">
        function <span class="apidocSignatureSpan">sass-lint.trailing_semicolon.</span>detect
        <span class="apidocSignatureSpan">(ast, parser)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">detect = function (ast, parser) {
  var result = [];

  if (ast.syntax !== &#x27;sass&#x27;) {
    ast.traverseByType(&#x27;block&#x27;, function (block) {
      var last,
          next;

      try {
        last = block.last(&#x27;declaration&#x27;);
      }
      catch (e) {
        return;
      }

      block.forEach(&#x27;declaration&#x27;, function (item, i, parent) {
        if (item.contains(&#x27;value&#x27;)) {
          var valueNode = item.last(&#x27;value&#x27;).content[0];

          if (!valueNode.is(&#x27;block&#x27;)) {
            if (helpers.isEqual(last, item)) {
              if (parent.content[i + 1]) {
                next = parent.content[i + 1];

                if (next.is(&#x27;declarationDelimiter&#x27;)) {
                  if (!parser.options.include) {
                    result = helpers.addUnique(result, {
                      &#x27;ruleId&#x27;: parser.rule.name,
                      &#x27;severity&#x27;: parser.severity,
                      &#x27;line&#x27;: item.end.line,
                      &#x27;column&#x27;: item.end.column,
                      &#x27;message&#x27;: &#x27;No trailing semicolons allowed&#x27;
                    });
                  }
                }
                else {
                  if (parser.options.include) {
                    result = helpers.addUnique(result, {
                      &#x27;ruleId&#x27;: parser.rule.name,
                      &#x27;severity&#x27;: parser.severity,
                      &#x27;line&#x27;: item.last(&#x27;value&#x27;).start.line,
                      &#x27;column&#x27;: item.last(&#x27;value&#x27;).start.column,
                      &#x27;message&#x27;: &#x27;Trailing semicolons required&#x27;
                    });
                  }
                }
              }
            }
          }
        }
      });
    });
  }

  return result;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  }

  if (ast.content &#x26;&#x26; ast.content.length &#x3e; 0) {
ruleToggles = getToggledRules(ast);
isEnabledFilter = isResultEnabled(ruleToggles);

rules.forEach(function (rule) {
  detects = rule.rule.<span class="apidocCodeKeywordSpan">detect</span>(ast, rule)
    .filter(isEnabledFilter);
  results = results.concat(detects);
  if (detects.length) {
    if (rule.severity === 1) {
      warnings += detects.length;
    }
    else if (rule.severity === 2) {
...</pre></li>
    </ul>






</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.sass-lint.url_quotes" id="apidoc.module.sass-lint.url_quotes">module sass-lint.url_quotes</a></h1>


    <h2>
        <a href="#apidoc.element.sass-lint.url_quotes.detect" id="apidoc.element.sass-lint.url_quotes.detect">
        function <span class="apidocSignatureSpan">sass-lint.url_quotes.</span>detect
        <span class="apidocSignatureSpan">(ast, parser)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">detect = function (ast, parser) {
  var result = [];

  ast.traverseByType(&#x27;uri&#x27;, function (node) {
    node.traverse(function (item) {
      if (item.is(&#x27;raw&#x27;)) {
        if (!item.content.match(isVarRegex)) {
          result = helpers.addUnique(result, {
            &#x27;ruleId&#x27;: parser.rule.name,
            &#x27;severity&#x27;: parser.severity,
            &#x27;line&#x27;: item.start.line,
            &#x27;column&#x27;: item.start.column,
            &#x27;message&#x27;: &#x27;Quotes around URLs are required&#x27;
          });
        }
      }
    });
  });

  return result;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  }

  if (ast.content &#x26;&#x26; ast.content.length &#x3e; 0) {
ruleToggles = getToggledRules(ast);
isEnabledFilter = isResultEnabled(ruleToggles);

rules.forEach(function (rule) {
  detects = rule.rule.<span class="apidocCodeKeywordSpan">detect</span>(ast, rule)
    .filter(isEnabledFilter);
  results = results.concat(detects);
  if (detects.length) {
    if (rule.severity === 1) {
      warnings += detects.length;
    }
    else if (rule.severity === 2) {
...</pre></li>
    </ul>






</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.sass-lint.variable_for_property" id="apidoc.module.sass-lint.variable_for_property">module sass-lint.variable_for_property</a></h1>


    <h2>
        <a href="#apidoc.element.sass-lint.variable_for_property.detect" id="apidoc.element.sass-lint.variable_for_property.detect">
        function <span class="apidocSignatureSpan">sass-lint.variable_for_property.</span>detect
        <span class="apidocSignatureSpan">(ast, parser)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">detect = function (ast, parser) {
  var result = [];

  if (parser.options.properties.length) {
    ast.traverseByType(&#x27;value&#x27;, function (node, i, parent) {
      var declaration = parent.content[0].content[0],
          declarationType = declaration.type,
          declarationIdent = declaration.content;

      if (declarationType === &#x27;ident&#x27;) {
        if (parser.options.properties.indexOf(declarationIdent) !== -1) {
          node.forEach(function (valElem) {
            if (!isValidProperty(valElem) &#x26;&#x26; !isIgnoredType(valElem)) {
              result = helpers.addUnique(result, {
                &#x27;ruleId&#x27;: parser.rule.name,
                &#x27;line&#x27;: declaration.start.line,
                &#x27;column&#x27;: declaration.start.column,
                &#x27;message&#x27;: &#x27;Values for properties of type \&#x27;&#x27; + declarationIdent + &#x27;\&#x27; may only be variables&#x27;,
                &#x27;severity&#x27;: parser.severity
              });
            }
          });
        }
      }
    });
  }
  return result;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  }

  if (ast.content &#x26;&#x26; ast.content.length &#x3e; 0) {
ruleToggles = getToggledRules(ast);
isEnabledFilter = isResultEnabled(ruleToggles);

rules.forEach(function (rule) {
  detects = rule.rule.<span class="apidocCodeKeywordSpan">detect</span>(ast, rule)
    .filter(isEnabledFilter);
  results = results.concat(detects);
  if (detects.length) {
    if (rule.severity === 1) {
      warnings += detects.length;
    }
    else if (rule.severity === 2) {
...</pre></li>
    </ul>






</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.sass-lint.variable_name_format" id="apidoc.module.sass-lint.variable_name_format">module sass-lint.variable_name_format</a></h1>


    <h2>
        <a href="#apidoc.element.sass-lint.variable_name_format.detect" id="apidoc.element.sass-lint.variable_name_format.detect">
        function <span class="apidocSignatureSpan">sass-lint.variable_name_format.</span>detect
        <span class="apidocSignatureSpan">(ast, parser)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">detect = function (ast, parser) {
  var result = [];

  ast.traverseByType(&#x27;variable&#x27;, function (variable) {
    var strippedName,
        violationMessage = false,
        name = variable.first().content;


    strippedName = name;

    if (parser.options[&#x27;allow-leading-underscore&#x27;] &#x26;&#x26; name[0] === &#x27;_&#x27;) {
      strippedName = strippedName.slice(1);
    }

    switch (parser.options.convention) {
    case &#x27;hyphenatedlowercase&#x27;:
      if (!helpers.isHyphenatedLowercase(strippedName)) {
        violationMessage = &#x27;Variable \&#x27;&#x27; + name + &#x27;\&#x27; should be written in lowercase with hyphens&#x27;;
      }
      break;
    case &#x27;camelcase&#x27;:
      if (!helpers.isCamelCase(strippedName)) {
        violationMessage = &#x27;Variable \&#x27;&#x27; + name + &#x27;\&#x27; should be written in camelCase&#x27;;
      }
      break;
    case &#x27;pascalcase&#x27;:
      if (!helpers.isPascalCase(strippedName)) {
        violationMessage = &#x27;Variable \&#x27;&#x27; + name + &#x27;\&#x27; should be written in PascalCase&#x27;;
      }
      break;
    case &#x27;snakecase&#x27;:
      if (!helpers.isSnakeCase(strippedName)) {
        violationMessage = &#x27;Variable \&#x27;&#x27; + name + &#x27;\&#x27; should be written in snake_case&#x27;;
      }
      break;
    case &#x27;strictbem&#x27;:
      if (!helpers.isStrictBEM(strippedName)) {
        violationMessage = &#x27;Variable \&#x27;&#x27; + name + &#x27;\&#x27; should be written in BEM (Block Element Modifier) format&#x27;;
      }
      break;
    case &#x27;hyphenatedbem&#x27;:
      if (!helpers.isHyphenatedBEM(strippedName)) {
        violationMessage = &#x27;Variable \&#x27;&#x27; + name + &#x27;\&#x27; should be written in hyphenated BEM (Block Element Modifier) format&#x27;;
      }
      break;
    default:
      if (!(new RegExp(parser.options.convention).test(strippedName))) {
        violationMessage = &#x27;Variable \&#x27;&#x27; + name + &#x27;\&#x27; should match regular expression /&#x27; + parser.options.convention + &#x27;/&#x27;;

        // convention-message overrides violationMessage
        if (parser.options[&#x27;convention-explanation&#x27;]) {
          violationMessage = parser.options[&#x27;convention-explanation&#x27;];
        }
      }
    }

    if (violationMessage) {
      result = helpers.addUnique(result, {
        &#x27;ruleId&#x27;: parser.rule.name,
        &#x27;line&#x27;: variable.start.line,
        &#x27;column&#x27;: variable.start.column,
        &#x27;message&#x27;: violationMessage,
        &#x27;severity&#x27;: parser.severity
      });
    }
  });

  return result;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  }

  if (ast.content &#x26;&#x26; ast.content.length &#x3e; 0) {
ruleToggles = getToggledRules(ast);
isEnabledFilter = isResultEnabled(ruleToggles);

rules.forEach(function (rule) {
  detects = rule.rule.<span class="apidocCodeKeywordSpan">detect</span>(ast, rule)
    .filter(isEnabledFilter);
  results = results.concat(detects);
  if (detects.length) {
    if (rule.severity === 1) {
      warnings += detects.length;
    }
    else if (rule.severity === 2) {
...</pre></li>
    </ul>






</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.sass-lint.zero_unit" id="apidoc.module.sass-lint.zero_unit">module sass-lint.zero_unit</a></h1>


    <h2>
        <a href="#apidoc.element.sass-lint.zero_unit.detect" id="apidoc.element.sass-lint.zero_unit.detect">
        function <span class="apidocSignatureSpan">sass-lint.zero_unit.</span>detect
        <span class="apidocSignatureSpan">(ast, parser)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">detect = function (ast, parser) {
  var result = [];

  ast.traverseByType(&#x27;number&#x27;, function (item, i, parent) {

    if (item.content === &#x27;0&#x27;) {
      if (parent.type === &#x27;dimension&#x27;) {
        var next = parent.content[i + 1] || false;

        if (units.indexOf(next.content) !== -1) {
          if (!parser.options.include) {
            result = helpers.addUnique(result, {
              &#x27;ruleId&#x27;: parser.rule.name,
              &#x27;severity&#x27;: parser.severity,
              &#x27;line&#x27;: item.end.line,
              &#x27;column&#x27;: item.end.column,
              &#x27;message&#x27;: &#x27;No unit allowed for values of 0&#x27;
            });
          }
        }
      }
      else {
        if (parent.type === &#x27;value&#x27;) {
          if (parser.options.include) {
            result = helpers.addUnique(result, {
              &#x27;ruleId&#x27;: parser.rule.name,
              &#x27;severity&#x27;: parser.severity,
              &#x27;line&#x27;: item.end.line,
              &#x27;column&#x27;: item.end.column,
              &#x27;message&#x27;: &#x27;Unit required for values of 0&#x27;
            });
          }
        }
      }
    }
  });

  return result;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  }

  if (ast.content &#x26;&#x26; ast.content.length &#x3e; 0) {
ruleToggles = getToggledRules(ast);
isEnabledFilter = isResultEnabled(ruleToggles);

rules.forEach(function (rule) {
  detects = rule.rule.<span class="apidocCodeKeywordSpan">detect</span>(ast, rule)
    .filter(isEnabledFilter);
  results = results.concat(detects);
  if (detects.length) {
    if (rule.severity === 1) {
      warnings += detects.length;
    }
    else if (rule.severity === 2) {
...</pre></li>
    </ul>






</div>

<div class="apidocFooterDiv">
    [ this document was created with
    <a href="https://github.com/kaizhu256/node-utility2" target="_blank">utility2</a>
    ]
</div>
</div>
