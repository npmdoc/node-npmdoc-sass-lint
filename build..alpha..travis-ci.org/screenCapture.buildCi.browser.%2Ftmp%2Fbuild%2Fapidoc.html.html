<html><head></head><body><div class="apidocDiv">
<style>
/*csslint
*/
.apidocDiv {
    background: #fff;
    font-family: Arial, Helvetica, sans-serif;
}
.apidocDiv a[href] {
    color: #33f;
    font-weight: bold;
    text-decoration: none;
}
.apidocDiv a[href]:hover {
    text-decoration: underline;
}
.apidocCodeCommentSpan {
    background: #bbf;
    color: #000;
    display: block;
}
.apidocCodeKeywordSpan {
    color: #d00;
    font-weight: bold;
}
.apidocCodePre {
    background: #eef;
    border: 1px solid;
    color: #777;
    padding: 5px;
    white-space: pre-wrap;
}
.apidocFooterDiv {
    margin-top: 20px;
    text-align: center;
}
.apidocModuleLi {
    margin-top: 10px;
}
.apidocSectionDiv {
    border-top: 1px solid;
    margin-top: 20px;
}
.apidocSignatureSpan {
    color: #777;
    font-weight: bold;
}
</style>
<h1>api documentation for
    <a href="https://github.com/sasstools/sass-lint">sass-lint (v1.10.2)</a>
</h1>
<h4>All Node Sass linter!</h4>
<div class="apidocSectionDiv"><a href="#apidoc.tableOfContents" id="apidoc.tableOfContents"><h1>table of contents</h1></a><ol>

    <li class="apidocModuleLi"><a href="#apidoc.module.sass-lint">module sass-lint</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sass-lint.sass-lint">
            function <span class="apidocSignatureSpan"></span>sass-lint
            <span class="apidocSignatureSpan">(config)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sass-lint.errorCount">
            function <span class="apidocSignatureSpan">sass-lint.</span>errorCount
            <span class="apidocSignatureSpan">(results)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sass-lint.failOnError">
            function <span class="apidocSignatureSpan">sass-lint.</span>failOnError
            <span class="apidocSignatureSpan">(results, options, configPath)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sass-lint.format">
            function <span class="apidocSignatureSpan">sass-lint.</span>format
            <span class="apidocSignatureSpan">(results, options, configPath)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sass-lint.getConfig">
            function <span class="apidocSignatureSpan">sass-lint.</span>getConfig
            <span class="apidocSignatureSpan">(config, configPath)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sass-lint.lintFileText">
            function <span class="apidocSignatureSpan">sass-lint.</span>lintFileText
            <span class="apidocSignatureSpan">(file, options, configPath)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sass-lint.lintFiles">
            function <span class="apidocSignatureSpan">sass-lint.</span>lintFiles
            <span class="apidocSignatureSpan">(files, options, configPath)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sass-lint.lintText">
            function <span class="apidocSignatureSpan">sass-lint.</span>lintText
            <span class="apidocSignatureSpan">(file, options, configPath)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sass-lint.outputResults">
            function <span class="apidocSignatureSpan">sass-lint.</span>outputResults
            <span class="apidocSignatureSpan">(results, options, configPath)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sass-lint.resultCount">
            function <span class="apidocSignatureSpan">sass-lint.</span>resultCount
            <span class="apidocSignatureSpan">(results)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sass-lint.warningCount">
            function <span class="apidocSignatureSpan">sass-lint.</span>warningCount
            <span class="apidocSignatureSpan">(results)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">sass-lint.</span>attribute_quotes</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">sass-lint.</span>bem_depth</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">sass-lint.</span>border_zero</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">sass-lint.</span>brace_style</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">sass-lint.</span>class_name_format</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">sass-lint.</span>clean_import_paths</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">sass-lint.</span>config_helpers</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">sass-lint.</span>declarations_before_nesting</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">sass-lint.</span>empty_args</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">sass-lint.</span>empty_line_between_blocks</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">sass-lint.</span>exceptions</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">sass-lint.</span>extends_before_declarations</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">sass-lint.</span>extends_before_mixins</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">sass-lint.</span>final_newline</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">sass-lint.</span>force_attribute_nesting</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">sass-lint.</span>force_element_nesting</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">sass-lint.</span>force_pseudo_nesting</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">sass-lint.</span>function_name_format</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">sass-lint.</span>helpers</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">sass-lint.</span>hex_length</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">sass-lint.</span>hex_notation</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">sass-lint.</span>id_name_format</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">sass-lint.</span>indentation</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">sass-lint.</span>leading_zero</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">sass-lint.</span>max_file_line_count</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">sass-lint.</span>max_line_length</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">sass-lint.</span>mixin_name_format</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">sass-lint.</span>mixins_before_declarations</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">sass-lint.</span>nesting_depth</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">sass-lint.</span>no_attribute_selectors</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">sass-lint.</span>no_color_hex</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">sass-lint.</span>no_color_keywords</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">sass-lint.</span>no_color_literals</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">sass-lint.</span>no_combinators</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">sass-lint.</span>no_css_comments</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">sass-lint.</span>no_debug</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">sass-lint.</span>no_disallowed_properties</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">sass-lint.</span>no_duplicate_properties</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">sass-lint.</span>no_empty_rulesets</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">sass-lint.</span>no_extends</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">sass-lint.</span>no_ids</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">sass-lint.</span>no_important</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">sass-lint.</span>no_invalid_hex</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">sass-lint.</span>no_mergeable_selectors</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">sass-lint.</span>no_misspelled_properties</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">sass-lint.</span>no_qualifying_elements</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">sass-lint.</span>no_trailing_whitespace</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">sass-lint.</span>no_trailing_zero</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">sass-lint.</span>no_transition_all</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">sass-lint.</span>no_universal_selectors</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">sass-lint.</span>no_url_domains</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">sass-lint.</span>no_url_protocols</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">sass-lint.</span>no_warn</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">sass-lint.</span>one_declaration_per_line</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">sass-lint.</span>placeholder_in_extend</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">sass-lint.</span>placeholder_name_format</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">sass-lint.</span>property_sort_order</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">sass-lint.</span>property_units</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">sass-lint.</span>pseudo_element</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">sass-lint.</span>quotes</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">sass-lint.</span>ruleToggler</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">sass-lint.</span>selector_helpers</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">sass-lint.</span>shorthand_values</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">sass-lint.</span>single_line_per_selector</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">sass-lint.</span>space_after_bang</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">sass-lint.</span>space_after_colon</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">sass-lint.</span>space_after_comma</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">sass-lint.</span>space_around_operator</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">sass-lint.</span>space_before_bang</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">sass-lint.</span>space_before_brace</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">sass-lint.</span>space_before_colon</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">sass-lint.</span>space_between_parens</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">sass-lint.</span>trailing_semicolon</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">sass-lint.</span>url_quotes</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">sass-lint.</span>variable_for_property</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">sass-lint.</span>variable_name_format</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">sass-lint.</span>zero_unit</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.sass-lint.attribute_quotes">module sass-lint.attribute_quotes</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sass-lint.attribute_quotes.detect">
            function <span class="apidocSignatureSpan">sass-lint.attribute_quotes.</span>detect
            <span class="apidocSignatureSpan">(ast, parser)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">sass-lint.attribute_quotes.</span>defaults</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">sass-lint.attribute_quotes.</span>name</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.sass-lint.bem_depth">module sass-lint.bem_depth</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sass-lint.bem_depth.detect">
            function <span class="apidocSignatureSpan">sass-lint.bem_depth.</span>detect
            <span class="apidocSignatureSpan">(ast, parser)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">sass-lint.bem_depth.</span>defaults</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">sass-lint.bem_depth.</span>name</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.sass-lint.border_zero">module sass-lint.border_zero</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sass-lint.border_zero.detect">
            function <span class="apidocSignatureSpan">sass-lint.border_zero.</span>detect
            <span class="apidocSignatureSpan">(ast, parser)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">sass-lint.border_zero.</span>defaults</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">sass-lint.border_zero.</span>name</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.sass-lint.brace_style">module sass-lint.brace_style</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sass-lint.brace_style.detect">
            function <span class="apidocSignatureSpan">sass-lint.brace_style.</span>detect
            <span class="apidocSignatureSpan">(ast, parser)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">sass-lint.brace_style.</span>defaults</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">sass-lint.brace_style.</span>name</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.sass-lint.class_name_format">module sass-lint.class_name_format</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sass-lint.class_name_format.detect">
            function <span class="apidocSignatureSpan">sass-lint.class_name_format.</span>detect
            <span class="apidocSignatureSpan">(ast, parser)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">sass-lint.class_name_format.</span>defaults</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">sass-lint.class_name_format.</span>name</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.sass-lint.clean_import_paths">module sass-lint.clean_import_paths</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sass-lint.clean_import_paths.detect">
            function <span class="apidocSignatureSpan">sass-lint.clean_import_paths.</span>detect
            <span class="apidocSignatureSpan">(ast, parser)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">sass-lint.clean_import_paths.</span>defaults</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">sass-lint.clean_import_paths.</span>name</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.sass-lint.config_helpers">module sass-lint.config_helpers</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sass-lint.config_helpers.checkForConfigExtend">
            function <span class="apidocSignatureSpan">sass-lint.config_helpers.</span>checkForConfigExtend
            <span class="apidocSignatureSpan">(config, curConfPath)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sass-lint.config_helpers.findFile">
            function <span class="apidocSignatureSpan">sass-lint.config_helpers.</span>findFile
            <span class="apidocSignatureSpan">(configPath, filename)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sass-lint.config_helpers.loadConfig">
            function <span class="apidocSignatureSpan">sass-lint.config_helpers.</span>loadConfig
            <span class="apidocSignatureSpan">(cPath)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sass-lint.config_helpers.loadDefaults">
            function <span class="apidocSignatureSpan">sass-lint.config_helpers.</span>loadDefaults
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.sass-lint.declarations_before_nesting">module sass-lint.declarations_before_nesting</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sass-lint.declarations_before_nesting.detect">
            function <span class="apidocSignatureSpan">sass-lint.declarations_before_nesting.</span>detect
            <span class="apidocSignatureSpan">(ast, parser)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">sass-lint.declarations_before_nesting.</span>defaults</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">sass-lint.declarations_before_nesting.</span>name</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.sass-lint.empty_args">module sass-lint.empty_args</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sass-lint.empty_args.detect">
            function <span class="apidocSignatureSpan">sass-lint.empty_args.</span>detect
            <span class="apidocSignatureSpan">(ast, parser)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">sass-lint.empty_args.</span>defaults</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">sass-lint.empty_args.</span>name</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.sass-lint.empty_line_between_blocks">module sass-lint.empty_line_between_blocks</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sass-lint.empty_line_between_blocks.detect">
            function <span class="apidocSignatureSpan">sass-lint.empty_line_between_blocks.</span>detect
            <span class="apidocSignatureSpan">(ast, parser)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">sass-lint.empty_line_between_blocks.</span>defaults</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">sass-lint.empty_line_between_blocks.</span>name</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.sass-lint.exceptions">module sass-lint.exceptions</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sass-lint.exceptions.MaxWarningsExceededError">
            function <span class="apidocSignatureSpan">sass-lint.exceptions.</span>MaxWarningsExceededError
            <span class="apidocSignatureSpan">(message)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sass-lint.exceptions.SassLintFailureError">
            function <span class="apidocSignatureSpan">sass-lint.exceptions.</span>SassLintFailureError
            <span class="apidocSignatureSpan">(message)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.sass-lint.extends_before_declarations">module sass-lint.extends_before_declarations</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sass-lint.extends_before_declarations.detect">
            function <span class="apidocSignatureSpan">sass-lint.extends_before_declarations.</span>detect
            <span class="apidocSignatureSpan">(ast, parser)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">sass-lint.extends_before_declarations.</span>defaults</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">sass-lint.extends_before_declarations.</span>name</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.sass-lint.extends_before_mixins">module sass-lint.extends_before_mixins</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sass-lint.extends_before_mixins.detect">
            function <span class="apidocSignatureSpan">sass-lint.extends_before_mixins.</span>detect
            <span class="apidocSignatureSpan">(ast, parser)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">sass-lint.extends_before_mixins.</span>defaults</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">sass-lint.extends_before_mixins.</span>name</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.sass-lint.final_newline">module sass-lint.final_newline</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sass-lint.final_newline.detect">
            function <span class="apidocSignatureSpan">sass-lint.final_newline.</span>detect
            <span class="apidocSignatureSpan">(ast, parser)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">sass-lint.final_newline.</span>defaults</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">sass-lint.final_newline.</span>name</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.sass-lint.force_attribute_nesting">module sass-lint.force_attribute_nesting</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sass-lint.force_attribute_nesting.detect">
            function <span class="apidocSignatureSpan">sass-lint.force_attribute_nesting.</span>detect
            <span class="apidocSignatureSpan">(ast, parser)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">sass-lint.force_attribute_nesting.</span>defaults</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">sass-lint.force_attribute_nesting.</span>name</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.sass-lint.force_element_nesting">module sass-lint.force_element_nesting</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sass-lint.force_element_nesting.detect">
            function <span class="apidocSignatureSpan">sass-lint.force_element_nesting.</span>detect
            <span class="apidocSignatureSpan">(ast, parser)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">sass-lint.force_element_nesting.</span>defaults</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">sass-lint.force_element_nesting.</span>name</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.sass-lint.force_pseudo_nesting">module sass-lint.force_pseudo_nesting</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sass-lint.force_pseudo_nesting.detect">
            function <span class="apidocSignatureSpan">sass-lint.force_pseudo_nesting.</span>detect
            <span class="apidocSignatureSpan">(ast, parser)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">sass-lint.force_pseudo_nesting.</span>defaults</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">sass-lint.force_pseudo_nesting.</span>name</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.sass-lint.function_name_format">module sass-lint.function_name_format</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sass-lint.function_name_format.detect">
            function <span class="apidocSignatureSpan">sass-lint.function_name_format.</span>detect
            <span class="apidocSignatureSpan">(ast, parser)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">sass-lint.function_name_format.</span>defaults</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">sass-lint.function_name_format.</span>name</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.sass-lint.helpers">module sass-lint.helpers</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sass-lint.helpers.addUnique">
            function <span class="apidocSignatureSpan">sass-lint.helpers.</span>addUnique
            <span class="apidocSignatureSpan">(results, item)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sass-lint.helpers.attemptTraversal">
            function <span class="apidocSignatureSpan">sass-lint.helpers.</span>attemptTraversal
            <span class="apidocSignatureSpan">(node, traversalPath)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sass-lint.helpers.collectSuffixExtensions">
            function <span class="apidocSignatureSpan">sass-lint.helpers.</span>collectSuffixExtensions
            <span class="apidocSignatureSpan">(ruleset, selectorType)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sass-lint.helpers.hasEOL">
            function <span class="apidocSignatureSpan">sass-lint.helpers.</span>hasEOL
            <span class="apidocSignatureSpan">(str)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sass-lint.helpers.isCamelCase">
            function <span class="apidocSignatureSpan">sass-lint.helpers.</span>isCamelCase
            <span class="apidocSignatureSpan">(str)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sass-lint.helpers.isEmptyLine">
            function <span class="apidocSignatureSpan">sass-lint.helpers.</span>isEmptyLine
            <span class="apidocSignatureSpan">(str)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sass-lint.helpers.isEqual">
            function <span class="apidocSignatureSpan">sass-lint.helpers.</span>isEqual
            <span class="apidocSignatureSpan">(a, b)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sass-lint.helpers.isHyphenatedBEM">
            function <span class="apidocSignatureSpan">sass-lint.helpers.</span>isHyphenatedBEM
            <span class="apidocSignatureSpan">(str)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sass-lint.helpers.isHyphenatedLowercase">
            function <span class="apidocSignatureSpan">sass-lint.helpers.</span>isHyphenatedLowercase
            <span class="apidocSignatureSpan">(str)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sass-lint.helpers.isLowerCase">
            function <span class="apidocSignatureSpan">sass-lint.helpers.</span>isLowerCase
            <span class="apidocSignatureSpan">(str)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sass-lint.helpers.isNestable">
            function <span class="apidocSignatureSpan">sass-lint.helpers.</span>isNestable
            <span class="apidocSignatureSpan">(currentVal, previousVal, elements, nestable)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sass-lint.helpers.isNewLine">
            function <span class="apidocSignatureSpan">sass-lint.helpers.</span>isNewLine
            <span class="apidocSignatureSpan">(node)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sass-lint.helpers.isNumber">
            function <span class="apidocSignatureSpan">sass-lint.helpers.</span>isNumber
            <span class="apidocSignatureSpan">(val)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sass-lint.helpers.isPartialStringMatch">
            function <span class="apidocSignatureSpan">sass-lint.helpers.</span>isPartialStringMatch
            <span class="apidocSignatureSpan">(needle, haystack)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sass-lint.helpers.isPascalCase">
            function <span class="apidocSignatureSpan">sass-lint.helpers.</span>isPascalCase
            <span class="apidocSignatureSpan">(str)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sass-lint.helpers.isSnakeCase">
            function <span class="apidocSignatureSpan">sass-lint.helpers.</span>isSnakeCase
            <span class="apidocSignatureSpan">(str)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sass-lint.helpers.isSpace">
            function <span class="apidocSignatureSpan">sass-lint.helpers.</span>isSpace
            <span class="apidocSignatureSpan">(node)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sass-lint.helpers.isStrictBEM">
            function <span class="apidocSignatureSpan">sass-lint.helpers.</span>isStrictBEM
            <span class="apidocSignatureSpan">(str)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sass-lint.helpers.isUnique">
            function <span class="apidocSignatureSpan">sass-lint.helpers.</span>isUnique
            <span class="apidocSignatureSpan">(results, item)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sass-lint.helpers.isUpperCase">
            function <span class="apidocSignatureSpan">sass-lint.helpers.</span>isUpperCase
            <span class="apidocSignatureSpan">(str)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sass-lint.helpers.isValidHex">
            function <span class="apidocSignatureSpan">sass-lint.helpers.</span>isValidHex
            <span class="apidocSignatureSpan">(str)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sass-lint.helpers.loadConfigFile">
            function <span class="apidocSignatureSpan">sass-lint.helpers.</span>loadConfigFile
            <span class="apidocSignatureSpan">(configPath)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sass-lint.helpers.log">
            function <span class="apidocSignatureSpan">sass-lint.helpers.</span>log
            <span class="apidocSignatureSpan">(input)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sass-lint.helpers.propertySearch">
            function <span class="apidocSignatureSpan">sass-lint.helpers.</span>propertySearch
            <span class="apidocSignatureSpan">(haystack, needle, property)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sass-lint.helpers.sortDetects">
            function <span class="apidocSignatureSpan">sass-lint.helpers.</span>sortDetects
            <span class="apidocSignatureSpan">(a, b)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sass-lint.helpers.stripBom">
            function <span class="apidocSignatureSpan">sass-lint.helpers.</span>stripBom
            <span class="apidocSignatureSpan">(str)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sass-lint.helpers.stripLastSpace">
            function <span class="apidocSignatureSpan">sass-lint.helpers.</span>stripLastSpace
            <span class="apidocSignatureSpan">(selector)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sass-lint.helpers.stripPrefix">
            function <span class="apidocSignatureSpan">sass-lint.helpers.</span>stripPrefix
            <span class="apidocSignatureSpan">(str)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sass-lint.helpers.stripQuotes">
            function <span class="apidocSignatureSpan">sass-lint.helpers.</span>stripQuotes
            <span class="apidocSignatureSpan">(str)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.sass-lint.hex_length">module sass-lint.hex_length</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sass-lint.hex_length.detect">
            function <span class="apidocSignatureSpan">sass-lint.hex_length.</span>detect
            <span class="apidocSignatureSpan">(ast, parser)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">sass-lint.hex_length.</span>defaults</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">sass-lint.hex_length.</span>name</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.sass-lint.hex_notation">module sass-lint.hex_notation</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sass-lint.hex_notation.detect">
            function <span class="apidocSignatureSpan">sass-lint.hex_notation.</span>detect
            <span class="apidocSignatureSpan">(ast, parser)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">sass-lint.hex_notation.</span>defaults</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">sass-lint.hex_notation.</span>name</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.sass-lint.id_name_format">module sass-lint.id_name_format</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sass-lint.id_name_format.detect">
            function <span class="apidocSignatureSpan">sass-lint.id_name_format.</span>detect
            <span class="apidocSignatureSpan">(ast, parser)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">sass-lint.id_name_format.</span>defaults</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">sass-lint.id_name_format.</span>name</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.sass-lint.indentation">module sass-lint.indentation</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sass-lint.indentation.detect">
            function <span class="apidocSignatureSpan">sass-lint.indentation.</span>detect
            <span class="apidocSignatureSpan">(ast, parser)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">sass-lint.indentation.</span>defaults</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">sass-lint.indentation.</span>name</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.sass-lint.leading_zero">module sass-lint.leading_zero</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sass-lint.leading_zero.detect">
            function <span class="apidocSignatureSpan">sass-lint.leading_zero.</span>detect
            <span class="apidocSignatureSpan">(ast, parser)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">sass-lint.leading_zero.</span>defaults</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">sass-lint.leading_zero.</span>name</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.sass-lint.max_file_line_count">module sass-lint.max_file_line_count</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sass-lint.max_file_line_count.detect">
            function <span class="apidocSignatureSpan">sass-lint.max_file_line_count.</span>detect
            <span class="apidocSignatureSpan">(ast, parser)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">sass-lint.max_file_line_count.</span>defaults</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">sass-lint.max_file_line_count.</span>name</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.sass-lint.max_line_length">module sass-lint.max_line_length</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sass-lint.max_line_length.detect">
            function <span class="apidocSignatureSpan">sass-lint.max_line_length.</span>detect
            <span class="apidocSignatureSpan">(ast, parser)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">sass-lint.max_line_length.</span>defaults</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">sass-lint.max_line_length.</span>name</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.sass-lint.mixin_name_format">module sass-lint.mixin_name_format</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sass-lint.mixin_name_format.detect">
            function <span class="apidocSignatureSpan">sass-lint.mixin_name_format.</span>detect
            <span class="apidocSignatureSpan">(ast, parser)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">sass-lint.mixin_name_format.</span>defaults</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">sass-lint.mixin_name_format.</span>name</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.sass-lint.mixins_before_declarations">module sass-lint.mixins_before_declarations</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sass-lint.mixins_before_declarations.detect">
            function <span class="apidocSignatureSpan">sass-lint.mixins_before_declarations.</span>detect
            <span class="apidocSignatureSpan">(ast, parser)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">sass-lint.mixins_before_declarations.</span>defaults</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">sass-lint.mixins_before_declarations.</span>name</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.sass-lint.nesting_depth">module sass-lint.nesting_depth</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sass-lint.nesting_depth.detect">
            function <span class="apidocSignatureSpan">sass-lint.nesting_depth.</span>detect
            <span class="apidocSignatureSpan">(ast, parser)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">sass-lint.nesting_depth.</span>defaults</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">sass-lint.nesting_depth.</span>name</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.sass-lint.no_attribute_selectors">module sass-lint.no_attribute_selectors</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sass-lint.no_attribute_selectors.detect">
            function <span class="apidocSignatureSpan">sass-lint.no_attribute_selectors.</span>detect
            <span class="apidocSignatureSpan">(ast, parser)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">sass-lint.no_attribute_selectors.</span>defaults</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">sass-lint.no_attribute_selectors.</span>name</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.sass-lint.no_color_hex">module sass-lint.no_color_hex</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sass-lint.no_color_hex.detect">
            function <span class="apidocSignatureSpan">sass-lint.no_color_hex.</span>detect
            <span class="apidocSignatureSpan">(ast, parser)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">sass-lint.no_color_hex.</span>defaults</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">sass-lint.no_color_hex.</span>name</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.sass-lint.no_color_keywords">module sass-lint.no_color_keywords</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sass-lint.no_color_keywords.detect">
            function <span class="apidocSignatureSpan">sass-lint.no_color_keywords.</span>detect
            <span class="apidocSignatureSpan">(ast, parser)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">sass-lint.no_color_keywords.</span>defaults</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">sass-lint.no_color_keywords.</span>name</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.sass-lint.no_color_literals">module sass-lint.no_color_literals</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sass-lint.no_color_literals.detect">
            function <span class="apidocSignatureSpan">sass-lint.no_color_literals.</span>detect
            <span class="apidocSignatureSpan">(ast, parser)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">sass-lint.no_color_literals.</span>defaults</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">sass-lint.no_color_literals.</span>name</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.sass-lint.no_combinators">module sass-lint.no_combinators</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sass-lint.no_combinators.detect">
            function <span class="apidocSignatureSpan">sass-lint.no_combinators.</span>detect
            <span class="apidocSignatureSpan">(ast, parser)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">sass-lint.no_combinators.</span>defaults</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">sass-lint.no_combinators.</span>name</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.sass-lint.no_css_comments">module sass-lint.no_css_comments</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sass-lint.no_css_comments.detect">
            function <span class="apidocSignatureSpan">sass-lint.no_css_comments.</span>detect
            <span class="apidocSignatureSpan">(ast, parser)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">sass-lint.no_css_comments.</span>defaults</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">sass-lint.no_css_comments.</span>name</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.sass-lint.no_debug">module sass-lint.no_debug</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sass-lint.no_debug.detect">
            function <span class="apidocSignatureSpan">sass-lint.no_debug.</span>detect
            <span class="apidocSignatureSpan">(ast, parser)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">sass-lint.no_debug.</span>defaults</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">sass-lint.no_debug.</span>name</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.sass-lint.no_disallowed_properties">module sass-lint.no_disallowed_properties</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sass-lint.no_disallowed_properties.detect">
            function <span class="apidocSignatureSpan">sass-lint.no_disallowed_properties.</span>detect
            <span class="apidocSignatureSpan">(ast, parser)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">sass-lint.no_disallowed_properties.</span>defaults</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">sass-lint.no_disallowed_properties.</span>name</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.sass-lint.no_duplicate_properties">module sass-lint.no_duplicate_properties</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sass-lint.no_duplicate_properties.detect">
            function <span class="apidocSignatureSpan">sass-lint.no_duplicate_properties.</span>detect
            <span class="apidocSignatureSpan">(ast, parser)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">sass-lint.no_duplicate_properties.</span>defaults</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">sass-lint.no_duplicate_properties.</span>name</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.sass-lint.no_empty_rulesets">module sass-lint.no_empty_rulesets</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sass-lint.no_empty_rulesets.detect">
            function <span class="apidocSignatureSpan">sass-lint.no_empty_rulesets.</span>detect
            <span class="apidocSignatureSpan">(ast, parser)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">sass-lint.no_empty_rulesets.</span>defaults</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">sass-lint.no_empty_rulesets.</span>name</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.sass-lint.no_extends">module sass-lint.no_extends</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sass-lint.no_extends.detect">
            function <span class="apidocSignatureSpan">sass-lint.no_extends.</span>detect
            <span class="apidocSignatureSpan">(ast, parser)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">sass-lint.no_extends.</span>defaults</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">sass-lint.no_extends.</span>name</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.sass-lint.no_ids">module sass-lint.no_ids</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sass-lint.no_ids.detect">
            function <span class="apidocSignatureSpan">sass-lint.no_ids.</span>detect
            <span class="apidocSignatureSpan">(ast, parser)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">sass-lint.no_ids.</span>defaults</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">sass-lint.no_ids.</span>name</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.sass-lint.no_important">module sass-lint.no_important</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sass-lint.no_important.detect">
            function <span class="apidocSignatureSpan">sass-lint.no_important.</span>detect
            <span class="apidocSignatureSpan">(ast, parser)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">sass-lint.no_important.</span>defaults</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">sass-lint.no_important.</span>name</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.sass-lint.no_invalid_hex">module sass-lint.no_invalid_hex</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sass-lint.no_invalid_hex.detect">
            function <span class="apidocSignatureSpan">sass-lint.no_invalid_hex.</span>detect
            <span class="apidocSignatureSpan">(ast, parser)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">sass-lint.no_invalid_hex.</span>defaults</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">sass-lint.no_invalid_hex.</span>name</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.sass-lint.no_mergeable_selectors">module sass-lint.no_mergeable_selectors</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sass-lint.no_mergeable_selectors.detect">
            function <span class="apidocSignatureSpan">sass-lint.no_mergeable_selectors.</span>detect
            <span class="apidocSignatureSpan">(ast, parser)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">sass-lint.no_mergeable_selectors.</span>defaults</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">sass-lint.no_mergeable_selectors.</span>name</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.sass-lint.no_misspelled_properties">module sass-lint.no_misspelled_properties</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sass-lint.no_misspelled_properties.detect">
            function <span class="apidocSignatureSpan">sass-lint.no_misspelled_properties.</span>detect
            <span class="apidocSignatureSpan">(ast, parser)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">sass-lint.no_misspelled_properties.</span>defaults</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">sass-lint.no_misspelled_properties.</span>name</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.sass-lint.no_qualifying_elements">module sass-lint.no_qualifying_elements</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sass-lint.no_qualifying_elements.detect">
            function <span class="apidocSignatureSpan">sass-lint.no_qualifying_elements.</span>detect
            <span class="apidocSignatureSpan">(ast, parser)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">sass-lint.no_qualifying_elements.</span>defaults</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">sass-lint.no_qualifying_elements.</span>name</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.sass-lint.no_trailing_whitespace">module sass-lint.no_trailing_whitespace</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sass-lint.no_trailing_whitespace.detect">
            function <span class="apidocSignatureSpan">sass-lint.no_trailing_whitespace.</span>detect
            <span class="apidocSignatureSpan">(ast, parser)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">sass-lint.no_trailing_whitespace.</span>defaults</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">sass-lint.no_trailing_whitespace.</span>name</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.sass-lint.no_trailing_zero">module sass-lint.no_trailing_zero</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sass-lint.no_trailing_zero.detect">
            function <span class="apidocSignatureSpan">sass-lint.no_trailing_zero.</span>detect
            <span class="apidocSignatureSpan">(ast, parser)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">sass-lint.no_trailing_zero.</span>defaults</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">sass-lint.no_trailing_zero.</span>name</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.sass-lint.no_transition_all">module sass-lint.no_transition_all</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sass-lint.no_transition_all.detect">
            function <span class="apidocSignatureSpan">sass-lint.no_transition_all.</span>detect
            <span class="apidocSignatureSpan">(ast, parser)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">sass-lint.no_transition_all.</span>defaults</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">sass-lint.no_transition_all.</span>name</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.sass-lint.no_universal_selectors">module sass-lint.no_universal_selectors</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sass-lint.no_universal_selectors.detect">
            function <span class="apidocSignatureSpan">sass-lint.no_universal_selectors.</span>detect
            <span class="apidocSignatureSpan">(ast, parser)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">sass-lint.no_universal_selectors.</span>defaults</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">sass-lint.no_universal_selectors.</span>name</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.sass-lint.no_url_domains">module sass-lint.no_url_domains</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sass-lint.no_url_domains.detect">
            function <span class="apidocSignatureSpan">sass-lint.no_url_domains.</span>detect
            <span class="apidocSignatureSpan">(ast, parser)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">sass-lint.no_url_domains.</span>defaults</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">sass-lint.no_url_domains.</span>name</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.sass-lint.no_url_protocols">module sass-lint.no_url_protocols</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sass-lint.no_url_protocols.detect">
            function <span class="apidocSignatureSpan">sass-lint.no_url_protocols.</span>detect
            <span class="apidocSignatureSpan">(ast, parser)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">sass-lint.no_url_protocols.</span>defaults</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">sass-lint.no_url_protocols.</span>name</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.sass-lint.no_warn">module sass-lint.no_warn</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sass-lint.no_warn.detect">
            function <span class="apidocSignatureSpan">sass-lint.no_warn.</span>detect
            <span class="apidocSignatureSpan">(ast, parser)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">sass-lint.no_warn.</span>defaults</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">sass-lint.no_warn.</span>name</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.sass-lint.one_declaration_per_line">module sass-lint.one_declaration_per_line</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sass-lint.one_declaration_per_line.detect">
            function <span class="apidocSignatureSpan">sass-lint.one_declaration_per_line.</span>detect
            <span class="apidocSignatureSpan">(ast, parser)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">sass-lint.one_declaration_per_line.</span>defaults</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">sass-lint.one_declaration_per_line.</span>name</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.sass-lint.placeholder_in_extend">module sass-lint.placeholder_in_extend</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sass-lint.placeholder_in_extend.detect">
            function <span class="apidocSignatureSpan">sass-lint.placeholder_in_extend.</span>detect
            <span class="apidocSignatureSpan">(ast, parser)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">sass-lint.placeholder_in_extend.</span>defaults</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">sass-lint.placeholder_in_extend.</span>name</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.sass-lint.placeholder_name_format">module sass-lint.placeholder_name_format</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sass-lint.placeholder_name_format.detect">
            function <span class="apidocSignatureSpan">sass-lint.placeholder_name_format.</span>detect
            <span class="apidocSignatureSpan">(ast, parser)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">sass-lint.placeholder_name_format.</span>defaults</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">sass-lint.placeholder_name_format.</span>name</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.sass-lint.property_sort_order">module sass-lint.property_sort_order</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sass-lint.property_sort_order.detect">
            function <span class="apidocSignatureSpan">sass-lint.property_sort_order.</span>detect
            <span class="apidocSignatureSpan">(ast, parser)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">sass-lint.property_sort_order.</span>defaults</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">sass-lint.property_sort_order.</span>name</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.sass-lint.property_units">module sass-lint.property_units</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sass-lint.property_units.detect">
            function <span class="apidocSignatureSpan">sass-lint.property_units.</span>detect
            <span class="apidocSignatureSpan">(ast, parser)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">sass-lint.property_units.</span>defaults</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">sass-lint.property_units.</span>name</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.sass-lint.pseudo_element">module sass-lint.pseudo_element</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sass-lint.pseudo_element.detect">
            function <span class="apidocSignatureSpan">sass-lint.pseudo_element.</span>detect
            <span class="apidocSignatureSpan">(ast, parser)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">sass-lint.pseudo_element.</span>name</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.sass-lint.quotes">module sass-lint.quotes</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sass-lint.quotes.detect">
            function <span class="apidocSignatureSpan">sass-lint.quotes.</span>detect
            <span class="apidocSignatureSpan">(ast, parser)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">sass-lint.quotes.</span>defaults</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">sass-lint.quotes.</span>name</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.sass-lint.ruleToggler">module sass-lint.ruleToggler</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sass-lint.ruleToggler.getToggledRules">
            function <span class="apidocSignatureSpan">sass-lint.ruleToggler.</span>getToggledRules
            <span class="apidocSignatureSpan">(ast)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sass-lint.ruleToggler.isResultEnabled">
            function <span class="apidocSignatureSpan">sass-lint.ruleToggler.</span>isResultEnabled
            <span class="apidocSignatureSpan">(toggledRules)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.sass-lint.selector_helpers">module sass-lint.selector_helpers</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sass-lint.selector_helpers.constructSelector">
            function <span class="apidocSignatureSpan">sass-lint.selector_helpers.</span>constructSelector
            <span class="apidocSignatureSpan">(val)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.sass-lint.shorthand_values">module sass-lint.shorthand_values</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sass-lint.shorthand_values.detect">
            function <span class="apidocSignatureSpan">sass-lint.shorthand_values.</span>detect
            <span class="apidocSignatureSpan">(ast, parser)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">sass-lint.shorthand_values.</span>defaults</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">sass-lint.shorthand_values.</span>name</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.sass-lint.single_line_per_selector">module sass-lint.single_line_per_selector</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sass-lint.single_line_per_selector.detect">
            function <span class="apidocSignatureSpan">sass-lint.single_line_per_selector.</span>detect
            <span class="apidocSignatureSpan">(ast, parser)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">sass-lint.single_line_per_selector.</span>defaults</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">sass-lint.single_line_per_selector.</span>name</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.sass-lint.space_after_bang">module sass-lint.space_after_bang</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sass-lint.space_after_bang.detect">
            function <span class="apidocSignatureSpan">sass-lint.space_after_bang.</span>detect
            <span class="apidocSignatureSpan">(ast, parser)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">sass-lint.space_after_bang.</span>defaults</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">sass-lint.space_after_bang.</span>name</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.sass-lint.space_after_colon">module sass-lint.space_after_colon</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sass-lint.space_after_colon.detect">
            function <span class="apidocSignatureSpan">sass-lint.space_after_colon.</span>detect
            <span class="apidocSignatureSpan">(ast, parser)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">sass-lint.space_after_colon.</span>defaults</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">sass-lint.space_after_colon.</span>name</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.sass-lint.space_after_comma">module sass-lint.space_after_comma</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sass-lint.space_after_comma.detect">
            function <span class="apidocSignatureSpan">sass-lint.space_after_comma.</span>detect
            <span class="apidocSignatureSpan">(ast, parser)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">sass-lint.space_after_comma.</span>defaults</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">sass-lint.space_after_comma.</span>name</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.sass-lint.space_around_operator">module sass-lint.space_around_operator</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sass-lint.space_around_operator.detect">
            function <span class="apidocSignatureSpan">sass-lint.space_around_operator.</span>detect
            <span class="apidocSignatureSpan">(ast, parser)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">sass-lint.space_around_operator.</span>defaults</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">sass-lint.space_around_operator.</span>name</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.sass-lint.space_before_bang">module sass-lint.space_before_bang</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sass-lint.space_before_bang.detect">
            function <span class="apidocSignatureSpan">sass-lint.space_before_bang.</span>detect
            <span class="apidocSignatureSpan">(ast, parser)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">sass-lint.space_before_bang.</span>defaults</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">sass-lint.space_before_bang.</span>name</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.sass-lint.space_before_brace">module sass-lint.space_before_brace</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sass-lint.space_before_brace.detect">
            function <span class="apidocSignatureSpan">sass-lint.space_before_brace.</span>detect
            <span class="apidocSignatureSpan">(ast, parser)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">sass-lint.space_before_brace.</span>defaults</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">sass-lint.space_before_brace.</span>name</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.sass-lint.space_before_colon">module sass-lint.space_before_colon</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sass-lint.space_before_colon.detect">
            function <span class="apidocSignatureSpan">sass-lint.space_before_colon.</span>detect
            <span class="apidocSignatureSpan">(ast, parser)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">sass-lint.space_before_colon.</span>defaults</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">sass-lint.space_before_colon.</span>name</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.sass-lint.space_between_parens">module sass-lint.space_between_parens</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sass-lint.space_between_parens.detect">
            function <span class="apidocSignatureSpan">sass-lint.space_between_parens.</span>detect
            <span class="apidocSignatureSpan">(ast, parser)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">sass-lint.space_between_parens.</span>defaults</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">sass-lint.space_between_parens.</span>name</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.sass-lint.trailing_semicolon">module sass-lint.trailing_semicolon</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sass-lint.trailing_semicolon.detect">
            function <span class="apidocSignatureSpan">sass-lint.trailing_semicolon.</span>detect
            <span class="apidocSignatureSpan">(ast, parser)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">sass-lint.trailing_semicolon.</span>defaults</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">sass-lint.trailing_semicolon.</span>name</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.sass-lint.url_quotes">module sass-lint.url_quotes</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sass-lint.url_quotes.detect">
            function <span class="apidocSignatureSpan">sass-lint.url_quotes.</span>detect
            <span class="apidocSignatureSpan">(ast, parser)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">sass-lint.url_quotes.</span>defaults</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">sass-lint.url_quotes.</span>name</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.sass-lint.variable_for_property">module sass-lint.variable_for_property</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sass-lint.variable_for_property.detect">
            function <span class="apidocSignatureSpan">sass-lint.variable_for_property.</span>detect
            <span class="apidocSignatureSpan">(ast, parser)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">sass-lint.variable_for_property.</span>defaults</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">sass-lint.variable_for_property.</span>name</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.sass-lint.variable_name_format">module sass-lint.variable_name_format</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sass-lint.variable_name_format.detect">
            function <span class="apidocSignatureSpan">sass-lint.variable_name_format.</span>detect
            <span class="apidocSignatureSpan">(ast, parser)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">sass-lint.variable_name_format.</span>defaults</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">sass-lint.variable_name_format.</span>name</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.sass-lint.zero_unit">module sass-lint.zero_unit</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sass-lint.zero_unit.detect">
            function <span class="apidocSignatureSpan">sass-lint.zero_unit.</span>detect
            <span class="apidocSignatureSpan">(ast, parser)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">sass-lint.zero_unit.</span>defaults</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">sass-lint.zero_unit.</span>name</span>

        </li>

    </ol></li>

</ol></div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.sass-lint" id="apidoc.module.sass-lint">module sass-lint</a></h1>


    <h2>
        <a href="#apidoc.element.sass-lint.sass-lint" id="apidoc.element.sass-lint.sass-lint">
        function <span class="apidocSignatureSpan"></span>sass-lint
        <span class="apidocSignatureSpan">(config)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">sass-lint = function (config) { // eslint-disable-line no-unused-vars
  config = require('./lib/config')(config);
  return;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.sass-lint.errorCount" id="apidoc.element.sass-lint.errorCount">
        function <span class="apidocSignatureSpan">sass-lint.</span>errorCount
        <span class="apidocSignatureSpan">(results)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">errorCount = function (results) {
  var errors = {
    count: 0,
    files: []
  };

  results.forEach(function (result) {
    if (result.errorCount) {
      errors.count += result.errorCount;
      errors.files.push(result.filePath);
    }
  });

  return errors;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* a cumulative count of both
*
* @param {object} results our results object
* @returns {int} the cumulative count of errors and warnings detected
*/
sassLint.resultCount = function (results) {
 var warnings = this.warningCount(results),
     errors = this.<span class="apidocCodeKeywordSpan">errorCount</span>(results);

 return warnings.count + errors.count;
};

/**
* Runs each rule against our AST tree and returns our main object of detected
* errors, warnings, messages and filenames.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.sass-lint.failOnError" id="apidoc.element.sass-lint.failOnError">
        function <span class="apidocSignatureSpan">sass-lint.</span>failOnError
        <span class="apidocSignatureSpan">(results, options, configPath)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">failOnError = function (results, options, configPath) {
  // Default parameters
  options = typeof options !== 'undefined' ? options : {};
  configPath = typeof configPath !== 'undefined' ? configPath : null;

  var errorCount = this.errorCount(results),
      warningCount = this.warningCount(results),
      configOptions = this.getConfig(options, configPath).options;

  if (errorCount.count &gt; 0) {
    throw new exceptions.SassLintFailureError(errorCount.count + ' errors were detected in \n- ' + errorCount.files.join('\n- '));
  }

  if (!isNaN(configOptions['max-warnings']) &amp;&amp; warningCount.count &gt; configOptions['max-warnings']) {
    throw new exceptions.MaxWarningsExceededError(
      'Number of warnings (' + warningCount.count +
      ') exceeds the allowed maximum of ' + configOptions['max-warnings'] +
      '.\n'
    );
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
}

if (lint.errorCount(detects).count || tooManyWarnings(detects, userConfig)) {
  exitCode = 1;
}

if (program.exit) {
  lint.<span class="apidocCodeKeywordSpan">failOnError</span>(detects, configOptions, configPath);
}
};

program
.version(meta.version)
.usage('[options] &lt;pattern&gt;')
.option('-c, --config [path]', 'path to custom config file')
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.sass-lint.format" id="apidoc.element.sass-lint.format">
        function <span class="apidocSignatureSpan">sass-lint.</span>format
        <span class="apidocSignatureSpan">(results, options, configPath)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">format = function (results, options, configPath) {
  var config = this.getConfig(options, configPath),
      format = config.options.formatter.toLowerCase();

  var formatted = require('eslint/lib/formatters/' + format);

  return formatted(results);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * @returns {object} results our results object
 */
sassLint.outputResults = function (results, options, configPath) {
  var config = this.getConfig(options, configPath);

  if (this.resultCount(results)) {

var formatted = this.<span class="apidocCodeKeywordSpan">format</span>(results, options, configPath);

if (config.options['output-file']) {
  try {
    fs.outputFileSync(path.resolve(process.cwd(), config.options['output-file']), formatted);
    console.log('Output successfully written to ' + path.resolve(process.cwd(), config.options['output-file']));
  }
  catch (e) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.sass-lint.getConfig" id="apidoc.element.sass-lint.getConfig">
        function <span class="apidocSignatureSpan">sass-lint.</span>getConfig
        <span class="apidocSignatureSpan">(config, configPath)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getConfig = function (config, configPath) {
  return slConfig(config, configPath);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 *
 * @param {object} file file object from fs.readFileSync
 * @param {object} options user specified rules/options passed in
 * @param {string} configPath path to a config file
 * @returns {object} an object containing error &amp; warning counts plus lint messages for each parsed file
 */
sassLint.lintText = function (file, options, configPath) {
var rules = slRules(this.<span class="apidocCodeKeywordSpan">getConfig</span>(options, configPath)),
    ast = {},
    detects,
    results = [],
    errors = 0,
    warnings = 0,
    ruleToggles = null,
    isEnabledFilter = null;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.sass-lint.lintFileText" id="apidoc.element.sass-lint.lintFileText">
        function <span class="apidocSignatureSpan">sass-lint.</span>lintFileText
        <span class="apidocSignatureSpan">(file, options, configPath)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">lintFileText = function (file, options, configPath) {
  var config = this.getConfig(options, configPath),
      ignores = config.files ? config.files.ignore : [];

  if (!globule.isMatch(ignores, file.filename)) {
    return this.lintText(file, options, configPath);
  }

  return {
    'filePath': file.filename,
    'warningCount': 0,
    'errorCount': 0,
    'messages': []
  };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.sass-lint.lintFiles" id="apidoc.element.sass-lint.lintFiles">
        function <span class="apidocSignatureSpan">sass-lint.</span>lintFiles
        <span class="apidocSignatureSpan">(files, options, configPath)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">lintFiles = function (files, options, configPath) {
  var that = this,
      results = [],
      includes = [],
      ignores = '';

  // Files passed as a string on the command line
  if (files) {
    ignores = this.getConfig(options, configPath).files.ignore || '';
    if (files.indexOf(', ') !== -1) {
      files.split(', ').forEach(function (pattern) {
        includes = includes.concat(glob.sync(pattern, {ignore: ignores, nodir: true}));
      });
    }
    else {
      includes = glob.sync(files, {ignore: ignores, nodir: true});
    }
  }
  // If not passed in then we look in the config file
  else {
    files = this.getConfig(options, configPath).files;
    // A glob pattern of files can be just a string
    if (typeof files === 'string') {
      includes = glob.sync(files, {nodir: true});
    }
    // Look into the include property of files and check if there's an array of files
    else if (files.include &amp;&amp; files.include instanceof Array) {
      files.include.forEach(function (pattern) {
        includes = includes.concat(glob.sync(pattern, {ignore: files.ignore, nodir: true}));
      });
    }
    // Or there is only one pattern in the include property of files
    else {
      includes = glob.sync(files.include, {ignore: files.ignore, nodir: true});
    }
  }

  includes.forEach(function (file, index) {
    // Only lint non duplicate files from our glob results
    if (includes.indexOf(file) === index) {
      var lint = that.lintText({
        'text': fs.readFileSync(file),
        'format': options.syntax ? options.syntax : path.extname(file).replace('.', ''),
        'filename': file
      }, options, configPath);
      results.push(lint);
    }
  });

  return results;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var tooManyWarnings = function (detects, userConfig) {
var warningCount = lint.warningCount(detects).count;

return warningCount &gt; 0 &amp;&amp; warningCount &gt; userConfig.options['max-warnings'];
};

var detectPattern = function (pattern, userConfig) {
var detects = lint.<span class="apidocCodeKeywordSpan">lintFiles</span>(pattern, configOptions, configPath);

if (program.verbose) {
  lint.outputResults(detects, configOptions, configPath);
}

if (lint.errorCount(detects).count || tooManyWarnings(detects, userConfig)) {
  exitCode = 1;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.sass-lint.lintText" id="apidoc.element.sass-lint.lintText">
        function <span class="apidocSignatureSpan">sass-lint.</span>lintText
        <span class="apidocSignatureSpan">(file, options, configPath)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">lintText = function (file, options, configPath) {
  var rules = slRules(this.getConfig(options, configPath)),
      ast = {},
      detects,
      results = [],
      errors = 0,
      warnings = 0,
      ruleToggles = null,
      isEnabledFilter = null;

  try {
    ast = groot(file.text, file.format, file.filename);
  }
  catch (e) {
    var line = e.line || 1;
    errors++;

    results = [{
      ruleId: 'Fatal',
      line: line,
      column: 1,
      message: e.message,
      severity: 2
    }];
  }

  if (ast.content &amp;&amp; ast.content.length &gt; 0) {
    ruleToggles = getToggledRules(ast);
    isEnabledFilter = isResultEnabled(ruleToggles);

    rules.forEach(function (rule) {
      detects = rule.rule.detect(ast, rule)
        .filter(isEnabledFilter);
      results = results.concat(detects);
      if (detects.length) {
        if (rule.severity === 1) {
          warnings += detects.length;
        }
        else if (rule.severity === 2) {
          errors += detects.length;
        }
      }
    });
  }

  results.sort(helpers.sortDetects);

  return {
    'filePath': file.filename,
    'warningCount': warnings,
    'errorCount': errors,
    'messages': results
  };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * @returns {object} Return the results of lintText - a results object
 */
sassLint.lintFileText = function (file, options, configPath) {
var config = this.getConfig(options, configPath),
    ignores = config.files ? config.files.ignore : [];

if (!globule.isMatch(ignores, file.filename)) {
  return this.<span class="apidocCodeKeywordSpan">lintText</span>(file, options, configPath);
}

return {
  'filePath': file.filename,
  'warningCount': 0,
  'errorCount': 0,
  'messages': []
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.sass-lint.outputResults" id="apidoc.element.sass-lint.outputResults">
        function <span class="apidocSignatureSpan">sass-lint.</span>outputResults
        <span class="apidocSignatureSpan">(results, options, configPath)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">outputResults = function (results, options, configPath) {
  var config = this.getConfig(options, configPath);

  if (this.resultCount(results)) {

    var formatted = this.format(results, options, configPath);

    if (config.options['output-file']) {
      try {
        fs.outputFileSync(path.resolve(process.cwd(), config.options['output-file']), formatted);
        console.log('Output successfully written to ' + path.resolve(process.cwd(), config.options['output-file']));
      }
      catch (e) {
        console.log('Error: Output was unable to be written to ' + path.resolve(process.cwd(), config.options['output-file']));
      }
    }
    else {
      console.log(formatted);
    }
  }
  return results;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
return warningCount &gt; 0 &amp;&amp; warningCount &gt; userConfig.options['max-warnings'];
};

var detectPattern = function (pattern, userConfig) {
var detects = lint.lintFiles(pattern, configOptions, configPath);

if (program.verbose) {
  lint.<span class="apidocCodeKeywordSpan">outputResults</span>(detects, configOptions, configPath);
}

if (lint.errorCount(detects).count || tooManyWarnings(detects, userConfig)) {
  exitCode = 1;
}

if (program.exit) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.sass-lint.resultCount" id="apidoc.element.sass-lint.resultCount">
        function <span class="apidocSignatureSpan">sass-lint.</span>resultCount
        <span class="apidocSignatureSpan">(results)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">resultCount = function (results) {
  var warnings = this.warningCount(results),
      errors = this.errorCount(results);

  return warnings.count + errors.count;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * @param {object} options user specified rules/options passed in
 * @param {string} configPath path to a config file
 * @returns {object} results our results object
 */
sassLint.outputResults = function (results, options, configPath) {
  var config = this.getConfig(options, configPath);

  if (this.<span class="apidocCodeKeywordSpan">resultCount</span>(results)) {

var formatted = this.format(results, options, configPath);

if (config.options['output-file']) {
  try {
    fs.outputFileSync(path.resolve(process.cwd(), config.options['output-file']), formatted);
    console.log('Output successfully written to ' + path.resolve(process.cwd(), config.options['output-file']));
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.sass-lint.warningCount" id="apidoc.element.sass-lint.warningCount">
        function <span class="apidocSignatureSpan">sass-lint.</span>warningCount
        <span class="apidocSignatureSpan">(results)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">warningCount = function (results) {
  var warnings = {
    count: 0,
    files: []
  };

  results.forEach(function (result) {
    if (result.warningCount) {
      warnings.count += result.warningCount;
      warnings.files.push(result.filePath);
    }
  });

  return warnings;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* Parses our results object to count warnings and errors and return
* a cumulative count of both
*
* @param {object} results our results object
* @returns {int} the cumulative count of errors and warnings detected
*/
sassLint.resultCount = function (results) {
 var warnings = this.<span class="apidocCodeKeywordSpan">warningCount</span>(results),
     errors = this.errorCount(results);

 return warnings.count + errors.count;
};

/**
* Runs each rule against our AST tree and returns our main object of detected
...</pre></li>
    </ul>




























































































































































</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.sass-lint.attribute_quotes" id="apidoc.module.sass-lint.attribute_quotes">module sass-lint.attribute_quotes</a></h1>


    <h2>
        <a href="#apidoc.element.sass-lint.attribute_quotes.detect" id="apidoc.element.sass-lint.attribute_quotes.detect">
        function <span class="apidocSignatureSpan">sass-lint.attribute_quotes.</span>detect
        <span class="apidocSignatureSpan">(ast, parser)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">detect = function (ast, parser) {
  var result = [];

  ast.traverseByType('attributeValue', function (item) {
    if (item.content[0].is('string') &amp;&amp; !parser.options.include) {
      result = helpers.addUnique(result, {
        'ruleId': parser.rule.name,
        'line': item.start.line,
        'column': item.start.column,
        'message': 'Attribute values should not be surrounded by quotes',
        'severity': parser.severity
      });
    }
    else if (item.content[0].is('ident') &amp;&amp; parser.options.include) {
      result = helpers.addUnique(result, {
        'ruleId': parser.rule.name,
        'line': item.start.line,
        'column': item.start.column,
        'message': 'Attribute values should be surrounded by quotes',
        'severity': parser.severity
      });
    }
  });

  return result;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  }

  if (ast.content &amp;&amp; ast.content.length &gt; 0) {
ruleToggles = getToggledRules(ast);
isEnabledFilter = isResultEnabled(ruleToggles);

rules.forEach(function (rule) {
  detects = rule.rule.<span class="apidocCodeKeywordSpan">detect</span>(ast, rule)
    .filter(isEnabledFilter);
  results = results.concat(detects);
  if (detects.length) {
    if (rule.severity === 1) {
      warnings += detects.length;
    }
    else if (rule.severity === 2) {
...</pre></li>
    </ul>






</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.sass-lint.bem_depth" id="apidoc.module.sass-lint.bem_depth">module sass-lint.bem_depth</a></h1>


    <h2>
        <a href="#apidoc.element.sass-lint.bem_depth.detect" id="apidoc.element.sass-lint.bem_depth.detect">
        function <span class="apidocSignatureSpan">sass-lint.bem_depth.</span>detect
        <span class="apidocSignatureSpan">(ast, parser)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">detect = function (ast, parser) {
  var result = [];

  ast.traverseByTypes(['ruleset', 'placeholder'], function (node) {
    var name,
        depth,
        selectorAndExtensions,
        maxDepth = parser.options['max-depth'];

    if (node.is('placeholder')) {
      name = selectorHelpers.constructSelector(node);
      if (name) {
        depth = bemDepth(name);
        if (depth &gt; maxDepth) {
          result = helpers.addUnique(result, {
            'ruleId': parser.rule.name,
            'line': node.start.line,
            'column': node.start.column,
            'message': ['Placeholder \'%', name, '\' should have ', maxDepth, ' or fewer BEM elements, but ',
              depth, ' were found.'].join(''),
            'severity': parser.severity
          });
        }
      }
    }
    else {
      selectorAndExtensions = helpers.collectSuffixExtensions(node, 'class');

      selectorAndExtensions.forEach(function (selector) {
        name = selector.content;
        depth = bemDepth(name);

        if (depth &gt; maxDepth) {
          result = helpers.addUnique(result, {
            'ruleId': parser.rule.name,
            'line': selector.start.line,
            'column': selector.start.column,
            'message': ['Selector \'.', name, '\' should have ', maxDepth, ' or fewer BEM elements, but ',
              depth, ' were found.'].join(''),
            'severity': parser.severity
          });
        }
      });
    }
  });

  return result;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  }

  if (ast.content &amp;&amp; ast.content.length &gt; 0) {
ruleToggles = getToggledRules(ast);
isEnabledFilter = isResultEnabled(ruleToggles);

rules.forEach(function (rule) {
  detects = rule.rule.<span class="apidocCodeKeywordSpan">detect</span>(ast, rule)
    .filter(isEnabledFilter);
  results = results.concat(detects);
  if (detects.length) {
    if (rule.severity === 1) {
      warnings += detects.length;
    }
    else if (rule.severity === 2) {
...</pre></li>
    </ul>






</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.sass-lint.border_zero" id="apidoc.module.sass-lint.border_zero">module sass-lint.border_zero</a></h1>


    <h2>
        <a href="#apidoc.element.sass-lint.border_zero.detect" id="apidoc.element.sass-lint.border_zero.detect">
        function <span class="apidocSignatureSpan">sass-lint.border_zero.</span>detect
        <span class="apidocSignatureSpan">(ast, parser)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">detect = function (ast, parser) {
  var result = [];
  var userConvention = parser.options.convention.toString();
  var convention = allowedConventions.indexOf(userConvention) !== -1
    ? userConvention
    : allowedConventions[0];
  var invalidConvention = convention !== userConvention;

  ast.traverseByType('declaration', function (declaration) {
    var isBorder = false;

    declaration.traverse(function (item) {
      if (item.type === 'property') {
        item.traverse(function (child) {
          if (borders.indexOf(child.content) !== -1) {
            isBorder = true;
          }
        });
      }

      if (isBorder) {
        if (item.type === 'value') {
          var node = item.content[0];
          if (node.type === 'number' || node.type === 'ident') {
            if (node.content === '0' || node.content === 'none') {
              if (convention !== node.content) {
                if (invalidConvention) {
                  invalidConvention = false;
                  result = helpers.addUnique(result, {
                    'ruleId': parser.rule.name,
                    'line': 1,
                    'column': 1,
                    'message': 'The border-zero convention `' + userConvention + ' in your config file is not valid. Defaulted to
 convention\'0\'',
                    'severity': parser.severity
                  });
                }
                result = helpers.addUnique(result, {
                  'ruleId': parser.rule.name,
                  'line': node.start.line,
                  'column': node.start.column,
                  'message': 'A value of `' + node.content + '` is not allowed. `' + convention + '` must be used.',
                  'severity': parser.severity
                });
              }
            }
          }
        }
      }
    });
  });

  return result;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  }

  if (ast.content &amp;&amp; ast.content.length &gt; 0) {
ruleToggles = getToggledRules(ast);
isEnabledFilter = isResultEnabled(ruleToggles);

rules.forEach(function (rule) {
  detects = rule.rule.<span class="apidocCodeKeywordSpan">detect</span>(ast, rule)
    .filter(isEnabledFilter);
  results = results.concat(detects);
  if (detects.length) {
    if (rule.severity === 1) {
      warnings += detects.length;
    }
    else if (rule.severity === 2) {
...</pre></li>
    </ul>






</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.sass-lint.brace_style" id="apidoc.module.sass-lint.brace_style">module sass-lint.brace_style</a></h1>


    <h2>
        <a href="#apidoc.element.sass-lint.brace_style.detect" id="apidoc.element.sass-lint.brace_style.detect">
        function <span class="apidocSignatureSpan">sass-lint.brace_style.</span>detect
        <span class="apidocSignatureSpan">(ast, parser)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">detect = function (ast, parser) {
  var result = [],
      acceptedAtrules = [
        'function',
        'if',
        'else'
      ];

  ast.traverseByTypes(['conditionalStatement', 'atrule', 'ruleset', 'mixin', 'loop'], function (node, i, parent) {
    var currentNode = false,
        previousNode = false,
        checks = {
          singleLineStatement: null,
          openingBraceOnNewLine: null,
          closingBraceOnNewLine: null,
          conditionOnNewLine: null
        },
        messages = [
          'Single line statements are not allowed',
          'Opening brace must be on the same line as condition',
          'Brace must be on a new line',
          'Statement must start on the same line as the closing brace of the previous statement',
          'Statement must begin on a new line',
          'Closing brace must be on a new line'
        ];

    // SCSS syntax only rule
    if (ast.syntax === 'sass') {
      return false;
    }

    // Filter at-rule types
    if (filterAtrule(node, acceptedAtrules)) {
      return false;
    }

    // Assign current &amp; previous nodes based on node type
    currentNode = getCurrentNode(node);
    previousNode = getPreviousNode(node);

    // If not an exception carry on
    if (!isException(node, currentNode, previousNode)) {

      // Run and store rule check results
      checks = runRuleChecks(node, currentNode, previousNode, parent, i);

      // Build single-line statement results
      if (checks.singleLineStatement === false &amp;&amp; checks.closingBraceOnNewLine === false) {
        result = helpers.addUnique(result, createIssue(parser, {
          line: currentNode.end.line,
          column: currentNode.end.column
        }, messages[5]));
      }

      if (checks.singleLineStatement === true) {
        if (parser.options['allow-single-line'] === false) {
          result = helpers.addUnique(result, createIssue(parser, {
            line: node.start.line,
            column: node.start.column
          }, messages[0]));
        }
        return false;
      }

      // Build brace-style results
      if (previousNode &amp;&amp; currentNode) {
        if (parser.options.style === '1tbs') {
          if (checks.openingBraceOnNewLine === false) {
            result = helpers.addUnique(result, createIssue(parser, {
              line: currentNode.start.line,
              column: currentNode.start.column
            }, messages[1]));
          }
          if (checks.conditionOnNewLine === true) {
            result = helpers.addUnique(result, createIssue(parser, {
              line: previousNode.start.line,
              column: previousNode.start.column
            }, messages[3]));
          }
        }

        if (parser.options.style === 'stroustrup') {
          if (checks.openingBraceOnNewLine === false) {
            result = helpers.addUnique(result, createIssue(parser, {
              line: currentNode.start.line,
              column: currentNode.start.column
            }, messages[1]));
          }
          if (checks.conditionOnNewLine === false) {
            result = helpers.addUnique(result, createIssue(parser, {
              line: previousNode.start.line,
              column: previousNode.start.column
            }, messages[4]));
          }
        }

        if (parser.options.style === 'allman') {
          if (checks.openingBraceOnNewLine === true) {
            result = helpers.addUnique(result, createIssue(parser, {
              line: currentNode.end.line,
              column: currentNode.end.column
            }, messages[2]));
          }
          if (checks.conditionOnNewLine === false) {
            result = helpers.addUnique(result, createIssue(parser, {
              line: previousNode.start.line,
              column: previousNode.start.column
            }, messages[4]));
          }
        }
      }
    }

    return true;
  });

  return result;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  }

  if (ast.content &amp;&amp; ast.content.length &gt; 0) {
ruleToggles = getToggledRules(ast);
isEnabledFilter = isResultEnabled(ruleToggles);

rules.forEach(function (rule) {
  detects = rule.rule.<span class="apidocCodeKeywordSpan">detect</span>(ast, rule)
    .filter(isEnabledFilter);
  results = results.concat(detects);
  if (detects.length) {
    if (rule.severity === 1) {
      warnings += detects.length;
    }
    else if (rule.severity === 2) {
...</pre></li>
    </ul>






</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.sass-lint.class_name_format" id="apidoc.module.sass-lint.class_name_format">module sass-lint.class_name_format</a></h1>


    <h2>
        <a href="#apidoc.element.sass-lint.class_name_format.detect" id="apidoc.element.sass-lint.class_name_format.detect">
        function <span class="apidocSignatureSpan">sass-lint.class_name_format.</span>detect
        <span class="apidocSignatureSpan">(ast, parser)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">detect = function (ast, parser) {
  var result = [];

  ast.traverseByType('ruleset', function (ruleset) {
    var selectorAndExtensions = helpers.collectSuffixExtensions(ruleset, 'class');

    selectorAndExtensions.forEach(function (node) {
      var name = node.content,
          strippedName,
          violationMessage = false;

      if (parser.options.ignore.indexOf(name) !== -1) {
        return;
      }

      strippedName = name;

      if (parser.options['allow-leading-underscore'] &amp;&amp; name[0] === '_') {
        strippedName = name.slice(1);
      }

      switch (parser.options.convention) {
      case 'hyphenatedlowercase':
        if (!helpers.isHyphenatedLowercase(strippedName)) {
          violationMessage = 'Class \'.' + name + '\' should be written in lowercase with hyphens';
        }
        break;
      case 'camelcase':
        if (!helpers.isCamelCase(strippedName)) {
          violationMessage = 'Class \'.' + name + '\' should be written in camelCase';
        }
        break;
      case 'pascalcase':
        if (!helpers.isPascalCase(strippedName)) {
          violationMessage = 'Class \'.' + name + '\' should be written in PascalCase';
        }
        break;
      case 'snakecase':
        if (!helpers.isSnakeCase(strippedName)) {
          violationMessage = 'Class \'.' + name + '\' should be written in snake_case';
        }
        break;
      case 'strictbem':
        if (!helpers.isStrictBEM(strippedName)) {
          violationMessage = 'Class \'.' + name + '\' should be written in BEM (Block Element Modifier) format';
        }
        break;
      case 'hyphenatedbem':
        if (!helpers.isHyphenatedBEM(strippedName)) {
          violationMessage = 'Class \'.' + name + '\' should be written in hyphenated BEM (Block Element Modifier) format';
        }
        break;
      default:
        if (!(new RegExp(parser.options.convention).test(strippedName))) {
          violationMessage = 'Class \'.' + name + '\' should match regular expression /' + parser.options.convention + '/';

          // convention-message overrides violationMessage
          if (parser.options['convention-explanation']) {
            violationMessage = parser.options['convention-explanation'];
          }
        }
      }

      if (violationMessage) {
        result = helpers.addUnique(result, {
          'ruleId': parser.rule.name,
          'line': node.start.line,
          'column': node.start.column,
          'message': violationMessage,
          'severity': parser.severity
        });
      }
    });
  });

  return result;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  }

  if (ast.content &amp;&amp; ast.content.length &gt; 0) {
ruleToggles = getToggledRules(ast);
isEnabledFilter = isResultEnabled(ruleToggles);

rules.forEach(function (rule) {
  detects = rule.rule.<span class="apidocCodeKeywordSpan">detect</span>(ast, rule)
    .filter(isEnabledFilter);
  results = results.concat(detects);
  if (detects.length) {
    if (rule.severity === 1) {
      warnings += detects.length;
    }
    else if (rule.severity === 2) {
...</pre></li>
    </ul>






</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.sass-lint.clean_import_paths" id="apidoc.module.sass-lint.clean_import_paths">module sass-lint.clean_import_paths</a></h1>


    <h2>
        <a href="#apidoc.element.sass-lint.clean_import_paths.detect" id="apidoc.element.sass-lint.clean_import_paths.detect">
        function <span class="apidocSignatureSpan">sass-lint.clean_import_paths.</span>detect
        <span class="apidocSignatureSpan">(ast, parser)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">detect = function (ast, parser) {
  var result = [];

  ast.traverseByType('atkeyword', function (keyword, i, parent) {
    keyword.forEach(function (item) {
      if (item.content === 'import') {
        var importPath = getImportPath(parent, keyword.syntax);

        if (importPath) {
          if (typeof importPath === 'string') {
            var filename = path.basename(importPath),
                fileExtension = path.extname(filename);

            if (fileExtension === '.sass' || fileExtension === '.scss' || fileExtension === '') {
              if (filename.charAt(0) === '_') {
                if (!parser.options['leading-underscore']) {
                  result = helpers.addUnique(result, {
                    'ruleId': parser.rule.name,
                    'line': item.start.line,
                    'column': item.start.column,
                    'message': 'Leading underscores are not allowed',
                    'severity': parser.severity
                  });
                }
              }
              else {
                if (parser.options['leading-underscore']) {
                  result = helpers.addUnique(result, {
                    'ruleId': parser.rule.name,
                    'line': item.start.line,
                    'column': item.start.column,
                    'message': 'Leading underscores are required',
                    'severity': parser.severity
                  });
                }
              }

              if (fileExtension) {
                if (!parser.options['filename-extension']) {
                  result = helpers.addUnique(result, {
                    'ruleId': parser.rule.name,
                    'line': item.start.line,
                    'column': item.start.column,
                    'message': 'File extensions are not allowed',
                    'severity': parser.severity
                  });
                }
              }
              else {
                if (parser.options['filename-extension']) {
                  result = helpers.addUnique(result, {
                    'ruleId': parser.rule.name,
                    'line': item.start.line,
                    'column': item.start.column,
                    'message': 'File extensions are required',
                    'severity': parser.severity
                  });
                }
              }
            }
          }
        }
      }
    });
  });

  return result;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  }

  if (ast.content &amp;&amp; ast.content.length &gt; 0) {
ruleToggles = getToggledRules(ast);
isEnabledFilter = isResultEnabled(ruleToggles);

rules.forEach(function (rule) {
  detects = rule.rule.<span class="apidocCodeKeywordSpan">detect</span>(ast, rule)
    .filter(isEnabledFilter);
  results = results.concat(detects);
  if (detects.length) {
    if (rule.severity === 1) {
      warnings += detects.length;
    }
    else if (rule.severity === 2) {
...</pre></li>
    </ul>






</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.sass-lint.config_helpers" id="apidoc.module.sass-lint.config_helpers">module sass-lint.config_helpers</a></h1>


    <h2>
        <a href="#apidoc.element.sass-lint.config_helpers.checkForConfigExtend" id="apidoc.element.sass-lint.config_helpers.checkForConfigExtend">
        function <span class="apidocSignatureSpan">sass-lint.config_helpers.</span>checkForConfigExtend
        <span class="apidocSignatureSpan">(config, curConfPath)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">checkForConfigExtend = function (config, curConfPath) {
  var mergedConfig = config,
      subConfig = config.options['config-file'] || false,
      confPath,
      resolvedSubConfig;

  if (subConfig) {
    if (!pathIsAbsolute(subConfig)) {
      // Process.cwd() in most IDE's will be / so therefore we need to pass the current directory
      // of the config from which you are 'extending' or we resort to process.cwd() which on the CLI
      // will be correct
      confPath = curConfPath ? path.dirname(curConfPath) : process.cwd();
      subConfig = path.resolve(confPath, subConfig);
    }
    // Attempt to load the new found config file
    resolvedSubConfig = loadConfig(subConfig, curConfPath);
    // Check the new config file to see if it too is extending
    resolvedSubConfig = checkForConfigExtend(resolvedSubConfig, subConfig);
    // Merge our configs with the first encountered being the most important, down to the last config
    // being the least.
    mergedConfig = merge.recursive(resolvedSubConfig, config);
  }

  return mergedConfig;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  }
}
else if (!pathIsAbsolute(configPath)) {
  configPath = path.resolve(process.cwd(), configPath);
}

config = confHelpers.loadConfig(configPath);
config = confHelpers.<span class="apidocCodeKeywordSpan">checkForConfigExtend</span>(config, configPath);

// check to see if user config contains an options property and whether property has a property called merge-default-rules
configMergeExists = (config.options &amp;&amp; typeof config.options['merge-default-rules'] !== 'undefined'
;);

// If it does then retrieve the value of it here or return false
configMerge = configMergeExists ? config.options['merge-default-rules'] : false;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.sass-lint.config_helpers.findFile" id="apidoc.element.sass-lint.config_helpers.findFile">
        function <span class="apidocSignatureSpan">sass-lint.config_helpers.</span>findFile
        <span class="apidocSignatureSpan">(configPath, filename)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function findFile(configPath, filename) {
  var HOME = process.env.HOME || process.env.HOMEPATH || process.env.USERPROFILE,
      dirname = null,
      parentDirname = null;

  configPath = configPath || path.join(process.cwd(), filename);

  if (configPath &amp;&amp; fs.existsSync(configPath)) {
    return fs.realpathSync(configPath);
  }
  dirname = path.dirname(configPath);
  parentDirname = path.dirname(dirname);

  if (dirname === null || dirname === HOME || dirname === parentDirname) {
    return null;
  }
  configPath = path.join(parentDirname, filename);

  return findFile(configPath, filename);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  }

  if (options.options &amp;&amp; options.options['config-file']) {
configPath = options.options['config-file'];
  }

  if (!configPath) {
metaPath = confHelpers.<span class="apidocCodeKeywordSpan">findFile</span>(false, 'package.json');
if (metaPath) {
  meta = require(metaPath);
}

if (meta &amp;&amp; meta.sasslintConfig) {
  configPath = path.resolve(path.dirname(metaPath), meta.sasslintConfig);
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.sass-lint.config_helpers.loadConfig" id="apidoc.element.sass-lint.config_helpers.loadConfig">
        function <span class="apidocSignatureSpan">sass-lint.config_helpers.</span>loadConfig
        <span class="apidocSignatureSpan">(cPath)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">loadConfig = function (cPath) {
  var configPath = cPath,
      resolvedConfig = {};

  if (configPath) {
    if (fs.existsSync(configPath)) {
      resolvedConfig = yaml.safeLoad(fs.readFileSync(configPath, 'utf8')) || {};
    }
  }

  return {
    options: resolvedConfig.options || {},
    files: resolvedConfig.files || {},
    rules: resolvedConfig.rules || {}
  };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    configPath = confHelpers.findFile(false, '.sass-lint.yml');
  }
}
else if (!pathIsAbsolute(configPath)) {
  configPath = path.resolve(process.cwd(), configPath);
}

config = confHelpers.<span class="apidocCodeKeywordSpan">loadConfig</span>(configPath);
config = confHelpers.checkForConfigExtend(config, configPath);

// check to see if user config contains an options property and whether property has a property called merge-default-rules
configMergeExists = (config.options &amp;&amp; typeof config.options['merge-default-rules'] !== 'undefined'
;);

// If it does then retrieve the value of it here or return false
configMerge = configMergeExists ? config.options['merge-default-rules'] : false;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.sass-lint.config_helpers.loadDefaults" id="apidoc.element.sass-lint.config_helpers.loadDefaults">
        function <span class="apidocSignatureSpan">sass-lint.config_helpers.</span>loadDefaults
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function loadDefaults() {
  return yaml.safeLoad(fs.readFileSync(path.join(__dirname, 'config', 'sass-lint.yml'), 'utf8'));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
// If it does then retrieve the value of it here or return false
optionsMerge = optionsMergeExists ? options.options['merge-default-rules'] : false;


// order of preference is inline options &gt; user config &gt; default config
// merge-default-rules defaults to true so each step above should merge with the previous. If at any step merge-default-rules is
 set to
// false it should skip that steps merge.
defaults = confHelpers.<span class="apidocCodeKeywordSpan">loadDefaults</span>();
finalConfig = merge.recursive(defaults, config, options);

// if merge-default-rules is set to false in user config file then we essentially skip the merging with default rules by overwriting
 our
// final rules with the content of our user config otherwise we don't take action here as the default merging has already happened
if (configMergeExists &amp;&amp; !configMerge) {
  finalConfig.rules = config.rules;
}
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.sass-lint.declarations_before_nesting" id="apidoc.module.sass-lint.declarations_before_nesting">module sass-lint.declarations_before_nesting</a></h1>


    <h2>
        <a href="#apidoc.element.sass-lint.declarations_before_nesting.detect" id="apidoc.element.sass-lint.declarations_before_nesting.detect">
        function <span class="apidocSignatureSpan">sass-lint.declarations_before_nesting.</span>detect
        <span class="apidocSignatureSpan">(ast, parser)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">detect = function (ast, parser) {
  var result = [],
      error;

  ast.traverseByType('block', function (block) {
    if (block.contains('ruleset') &amp;&amp; block.contains('declaration')) {
      var rulesetIndex;

      block.forEach(function (item, j) {
        var declarationIndex;
        var declaration;

        if (item.is('ruleset') &amp;&amp; rulesetIndex === void 0) {
          rulesetIndex = j;
        }

        if (item.is('declaration')) {
          var property = item.content[0];

          if (property &amp;&amp; property.is('property')) {
            if (property.content[0] &amp;&amp; property.content[0].is('variable')) {
              return;
            }
          }

          declarationIndex = j;
          declaration = item;
        }

        if (rulesetIndex &lt; declarationIndex &amp;&amp; declaration) {
          error = {
            'ruleId': parser.rule.name,
            'line': declaration.start.line,
            'column': declaration.start.column,
            'message': 'Declarations should come before nestings',
            'severity': parser.severity
          };
          result = helpers.addUnique(result, error);
        }
      });

      rulesetIndex = null;
    }
  });

  return result;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  }

  if (ast.content &amp;&amp; ast.content.length &gt; 0) {
ruleToggles = getToggledRules(ast);
isEnabledFilter = isResultEnabled(ruleToggles);

rules.forEach(function (rule) {
  detects = rule.rule.<span class="apidocCodeKeywordSpan">detect</span>(ast, rule)
    .filter(isEnabledFilter);
  results = results.concat(detects);
  if (detects.length) {
    if (rule.severity === 1) {
      warnings += detects.length;
    }
    else if (rule.severity === 2) {
...</pre></li>
    </ul>






</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.sass-lint.empty_args" id="apidoc.module.sass-lint.empty_args">module sass-lint.empty_args</a></h1>


    <h2>
        <a href="#apidoc.element.sass-lint.empty_args.detect" id="apidoc.element.sass-lint.empty_args.detect">
        function <span class="apidocSignatureSpan">sass-lint.empty_args.</span>detect
        <span class="apidocSignatureSpan">(ast, parser)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">detect = function (ast, parser) {
  var result = [];

  ast.traverseByTypes(['mixin', 'include'], function (item) {
    if (item.contains('arguments')) {
      item.traverse(function (node) {
        if (node.type === 'arguments') {
          if (node.content.length === 0) {
            if (!parser.options.include) {
              result = helpers.addUnique(result, {
                'ruleId': parser.rule.name,
                'line': node.start.line,
                'column': node.start.column,
                'message': 'Parenthesis should be removed.',
                'severity': parser.severity
              });
            }
          }
        }
      });
    }
    else {
      if (parser.options.include) {
        result = helpers.addUnique(result, {
          'ruleId': parser.rule.name,
          'line': item.start.line,
          'column': item.start.column,
          'message': 'Parenthesis are required.',
          'severity': parser.severity
        });
      }
    }
  });

  return result;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  }

  if (ast.content &amp;&amp; ast.content.length &gt; 0) {
ruleToggles = getToggledRules(ast);
isEnabledFilter = isResultEnabled(ruleToggles);

rules.forEach(function (rule) {
  detects = rule.rule.<span class="apidocCodeKeywordSpan">detect</span>(ast, rule)
    .filter(isEnabledFilter);
  results = results.concat(detects);
  if (detects.length) {
    if (rule.severity === 1) {
      warnings += detects.length;
    }
    else if (rule.severity === 2) {
...</pre></li>
    </ul>






</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.sass-lint.empty_line_between_blocks" id="apidoc.module.sass-lint.empty_line_between_blocks">module sass-lint.empty_line_between_blocks</a></h1>


    <h2>
        <a href="#apidoc.element.sass-lint.empty_line_between_blocks.detect" id="apidoc.element.sass-lint.empty_line_between_blocks.detect">
        function <span class="apidocSignatureSpan">sass-lint.empty_line_between_blocks.</span>detect
        <span class="apidocSignatureSpan">(ast, parser)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">detect = function (ast, parser) {
  var result = [];
  syntax = ast.syntax;

  ast.traverseByType('ruleset', function (node, j, p) {
    var space;

    if ((node.start.line === node.end.line) &amp;&amp; parser.options['allow-single-line-rulesets']) {
      return false;
    }

    if (syntax === 'scss') {
      space = findNearestReturnSCSS(p, j);

      if (space) {
        if (parser.options.include &amp;&amp; !space.space &amp;&amp; j !== 1) {
          result = helpers.addUnique(result, {
            'ruleId': parser.rule.name,
            'line': space.previous.end.line,
            'column': 1,
            'message': 'Space expected between blocks',
            'severity': parser.severity
          });
        }
        else if (!parser.options.include &amp;&amp; space.space) {
          result = helpers.addUnique(result, {
            'ruleId': parser.rule.name,
            'line': space.previous.end.line,
            'column': 1,
            'message': 'Space not allowed between blocks',
            'severity': parser.severity
          });
        }
      }
    }
    else if (syntax === 'sass') {
      // Reset the counter for each ruleset
      counter = 0;

      if (node.is('ruleset')) {

        node.forEach('block', function (block, i, parent) {
          var previous;

          // Capture the previous node
          if (parent.content[i - 1]) {
            previous = parent.content[i - 1];
          }
          else {
            // Else set the block to act as the previous node
            previous = block;
          }

          // If it's a new line, lets go back up to the selector
          if (previous.is('space') &amp;&amp; helpers.hasEOL(previous.content)) {
            space = findNearestReturnSass(p, j);
          }
        });
      }

      if (space &amp;&amp; space.previous) {
        if (space.previous.start.line !== 1) {
          if (parser.options.include &amp;&amp; !space.space) {
            result = helpers.addUnique(result, {
              'ruleId': parser.rule.name,
              'line': space.previous.end.line + 1,
              'column': 1,
              'message': 'Space expected between blocks',
              'severity': parser.severity
            });
          }
          else if (!parser.options.include &amp;&amp; space.space) {
            result = helpers.addUnique(result, {
              'ruleId': parser.rule.name,
              'line': space.previous.end.line + 1,
              'column': 1,
              'message': 'Space not allowed between blocks',
              'severity': parser.severity
            });
          }
        }
      }
    }
    return true;
  });

  return result;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  }

  if (ast.content &amp;&amp; ast.content.length &gt; 0) {
ruleToggles = getToggledRules(ast);
isEnabledFilter = isResultEnabled(ruleToggles);

rules.forEach(function (rule) {
  detects = rule.rule.<span class="apidocCodeKeywordSpan">detect</span>(ast, rule)
    .filter(isEnabledFilter);
  results = results.concat(detects);
  if (detects.length) {
    if (rule.severity === 1) {
      warnings += detects.length;
    }
    else if (rule.severity === 2) {
...</pre></li>
    </ul>






</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.sass-lint.exceptions" id="apidoc.module.sass-lint.exceptions">module sass-lint.exceptions</a></h1>


    <h2>
        <a href="#apidoc.element.sass-lint.exceptions.MaxWarningsExceededError" id="apidoc.element.sass-lint.exceptions.MaxWarningsExceededError">
        function <span class="apidocSignatureSpan">sass-lint.exceptions.</span>MaxWarningsExceededError
        <span class="apidocSignatureSpan">(message)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">MaxWarningsExceededError = function (message) {
  Error.captureStackTrace(this, this.constructor);
  this.name = 'MaxWarningsExceededError';
  this.message = message;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
      configOptions = this.getConfig(options, configPath).options;

  if (errorCount.count &gt; 0) {
    throw new exceptions.SassLintFailureError(errorCount.count + ' errors were detected in \n- ' + errorCount.files.join
('\n- '));
  }

  if (!isNaN(configOptions['max-warnings']) &amp;&amp; warningCount.count &gt; configOptions['max-warnings'
;]) {
    throw new exceptions.<span class="apidocCodeKeywordSpan">MaxWarningsExceededError</span>(
      'Number of warnings (' + warningCount.count +
      ') exceeds the allowed maximum of ' + configOptions['max-warnings'] +
      '.\n'
    );
  }
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.sass-lint.exceptions.SassLintFailureError" id="apidoc.element.sass-lint.exceptions.SassLintFailureError">
        function <span class="apidocSignatureSpan">sass-lint.exceptions.</span>SassLintFailureError
        <span class="apidocSignatureSpan">(message)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">SassLintFailureError = function (message) {
  Error.captureStackTrace(this, this.constructor);
  this.name = 'SassLintFailureError';
  this.message = message;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
configPath = typeof configPath !== 'undefined' ? configPath : null;

var errorCount = this.errorCount(results),
    warningCount = this.warningCount(results),
    configOptions = this.getConfig(options, configPath).options;

if (errorCount.count &gt; 0) {
  throw new exceptions.<span class="apidocCodeKeywordSpan">SassLintFailureError</span>(errorCount.count + ' errors were detected
 in\n- ' + errorCount.files.join('\n- '));
}

if (!isNaN(configOptions['max-warnings']) &amp;&amp; warningCount.count &gt; configOptions['max-warnings'
;]) {
  throw new exceptions.MaxWarningsExceededError(
    'Number of warnings (' + warningCount.count +
    ') exceeds the allowed maximum of ' + configOptions['max-warnings'] +
    '.\n'
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.sass-lint.extends_before_declarations" id="apidoc.module.sass-lint.extends_before_declarations">module sass-lint.extends_before_declarations</a></h1>


    <h2>
        <a href="#apidoc.element.sass-lint.extends_before_declarations.detect" id="apidoc.element.sass-lint.extends_before_declarations.detect">
        function <span class="apidocSignatureSpan">sass-lint.extends_before_declarations.</span>detect
        <span class="apidocSignatureSpan">(ast, parser)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">detect = function (ast, parser) {
  var result = [],
      error;

  ast.traverseByType('block', function (block) {
    var lastDeclaration = null;

    block.forEach(function (item, j) {
      if (item.is('include') || item.is('extend')) {
        if (item.contains('atkeyword')) {
          var atkeyword = item.first('atkeyword');

          if (atkeyword.contains('ident')) {
            var ident = atkeyword.first('ident');

            if (ident.content === 'extend') {
              if (j &gt; lastDeclaration &amp;&amp; lastDeclaration !== null) {
                error = {
                  'ruleId': parser.rule.name,
                  'line': item.start.line,
                  'column': item.start.column,
                  'message': 'Extends should come before declarations',
                  'severity': parser.severity
                };
                result = helpers.addUnique(result, error);
              }
            }
          }
        }
      }

      if (item.is('declaration')) {
        lastDeclaration = j;
      }
    });
    lastDeclaration = null;
  });

  return result;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  }

  if (ast.content &amp;&amp; ast.content.length &gt; 0) {
ruleToggles = getToggledRules(ast);
isEnabledFilter = isResultEnabled(ruleToggles);

rules.forEach(function (rule) {
  detects = rule.rule.<span class="apidocCodeKeywordSpan">detect</span>(ast, rule)
    .filter(isEnabledFilter);
  results = results.concat(detects);
  if (detects.length) {
    if (rule.severity === 1) {
      warnings += detects.length;
    }
    else if (rule.severity === 2) {
...</pre></li>
    </ul>






</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.sass-lint.extends_before_mixins" id="apidoc.module.sass-lint.extends_before_mixins">module sass-lint.extends_before_mixins</a></h1>


    <h2>
        <a href="#apidoc.element.sass-lint.extends_before_mixins.detect" id="apidoc.element.sass-lint.extends_before_mixins.detect">
        function <span class="apidocSignatureSpan">sass-lint.extends_before_mixins.</span>detect
        <span class="apidocSignatureSpan">(ast, parser)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">detect = function (ast, parser) {
  var result = [];

  ast.traverseByType('block', function (block) {
    var lastMixin = null;

    block.forEach(function (item, j) {
      if (item.is('include') || item.is('extend')) {
        if (item.contains('atkeyword')) {
          var atkeyword = item.first('atkeyword');

          if (atkeyword.contains('ident')) {
            var ident = atkeyword.first('ident');

            if (ident.content === 'extend') {
              if (j &gt; lastMixin &amp;&amp; lastMixin !== null) {
                result = helpers.addUnique(result, {
                  'ruleId': parser.rule.name,
                  'line': item.start.line,
                  'column': item.start.column,
                  'message': 'Extends should come before mixins',
                  'severity': parser.severity
                });
              }
            }
          }
        }
      }

      if (item.is('include')) {
        lastMixin = j;
      }
    });

    lastMixin = null;
  });

  return result;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  }

  if (ast.content &amp;&amp; ast.content.length &gt; 0) {
ruleToggles = getToggledRules(ast);
isEnabledFilter = isResultEnabled(ruleToggles);

rules.forEach(function (rule) {
  detects = rule.rule.<span class="apidocCodeKeywordSpan">detect</span>(ast, rule)
    .filter(isEnabledFilter);
  results = results.concat(detects);
  if (detects.length) {
    if (rule.severity === 1) {
      warnings += detects.length;
    }
    else if (rule.severity === 2) {
...</pre></li>
    </ul>






</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.sass-lint.final_newline" id="apidoc.module.sass-lint.final_newline">module sass-lint.final_newline</a></h1>


    <h2>
        <a href="#apidoc.element.sass-lint.final_newline.detect" id="apidoc.element.sass-lint.final_newline.detect">
        function <span class="apidocSignatureSpan">sass-lint.final_newline.</span>detect
        <span class="apidocSignatureSpan">(ast, parser)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">detect = function (ast, parser) {
  var result = [],
      last,
      error = {
        'ruleId': parser.rule.name,
        'severity': parser.severity
      };

  // If the syntax is Sass we must recursively loop to determine the last node.
  // This is not required for SCSS which will always use the last node in the
  // content of the parent stylesheet node
  if (ast.syntax === 'sass') {
    last = getLastNode(ast);
  }
  else {
    last = ast.content[ast.content.length - 1];
  }

  if (!last.is('space') &amp;&amp; !last.is('declarationDelimiter')) {
    if (parser.options.include) {
      error.line = last.end.line;
      error.column = last.end.column;
      error.message = 'Files must end with a new line';
      result = helpers.addUnique(result, error);
    }
  }
  else if ((last.is('space') || last.is('declarationDelimiter'))) {
    if (!helpers.hasEOL(last.content) &amp;&amp; parser.options.include) {
      error.line = last.start.line;
      error.column = last.start.column;
      error.message = 'Files must end with a new line';
      result = helpers.addUnique(result, error);
    }
    else if (helpers.hasEOL(last.content) &amp;&amp; !parser.options.include) {
      error.line = last.start.line;
      error.column = last.start.column;
      error.message = 'Files must not end with a new line';
      result = helpers.addUnique(result, error);
    }
  }

  return result;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  }

  if (ast.content &amp;&amp; ast.content.length &gt; 0) {
ruleToggles = getToggledRules(ast);
isEnabledFilter = isResultEnabled(ruleToggles);

rules.forEach(function (rule) {
  detects = rule.rule.<span class="apidocCodeKeywordSpan">detect</span>(ast, rule)
    .filter(isEnabledFilter);
  results = results.concat(detects);
  if (detects.length) {
    if (rule.severity === 1) {
      warnings += detects.length;
    }
    else if (rule.severity === 2) {
...</pre></li>
    </ul>






</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.sass-lint.force_attribute_nesting" id="apidoc.module.sass-lint.force_attribute_nesting">module sass-lint.force_attribute_nesting</a></h1>


    <h2>
        <a href="#apidoc.element.sass-lint.force_attribute_nesting.detect" id="apidoc.element.sass-lint.force_attribute_nesting.detect">
        function <span class="apidocSignatureSpan">sass-lint.force_attribute_nesting.</span>detect
        <span class="apidocSignatureSpan">(ast, parser)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">detect = function (ast, parser) {
  var result = [],
      elements = nestableElements.concat(nestableAttributes, nestablePseudo);

  ast.traverseByType('ruleset', function (ruleset) {

    ruleset.forEach('selector', function (selector) {
      var previousVal;
      selector.forEach(function (item) {
        if (previousVal) {
          if (helpers.isNestable(item.type, previousVal.type, elements, nestableAttributes)) {
            helpers.addUnique(result, {
              'ruleId': parser.rule.name,
              'line': selector.start.line,
              'column': selector.start.column,
              'message': formatOutput(item.type) + ' should be nested within its parent ' + formatOutput(previousVal.type),
              'severity': parser.severity
            });
          }
        }
        previousVal = item;
      });
    });
  });

  return result;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  }

  if (ast.content &amp;&amp; ast.content.length &gt; 0) {
ruleToggles = getToggledRules(ast);
isEnabledFilter = isResultEnabled(ruleToggles);

rules.forEach(function (rule) {
  detects = rule.rule.<span class="apidocCodeKeywordSpan">detect</span>(ast, rule)
    .filter(isEnabledFilter);
  results = results.concat(detects);
  if (detects.length) {
    if (rule.severity === 1) {
      warnings += detects.length;
    }
    else if (rule.severity === 2) {
...</pre></li>
    </ul>






</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.sass-lint.force_element_nesting" id="apidoc.module.sass-lint.force_element_nesting">module sass-lint.force_element_nesting</a></h1>


    <h2>
        <a href="#apidoc.element.sass-lint.force_element_nesting.detect" id="apidoc.element.sass-lint.force_element_nesting.detect">
        function <span class="apidocSignatureSpan">sass-lint.force_element_nesting.</span>detect
        <span class="apidocSignatureSpan">(ast, parser)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">detect = function (ast, parser) {
  var result = [],
      elements = nestableElements.concat(nestableAttributes, nestablePseudo);

  ast.traverseByType('ruleset', function (ruleset) {
    ruleset.forEach(function (selector) {

      var previousVal;
      selector.forEach(function (item) {
        if (previousVal) {
          if (helpers.isNestable(item.type, previousVal.type, elements, nestableElements)) {
            helpers.addUnique(result, {
              'ruleId': parser.rule.name,
              'line': selector.start.line,
              'column': selector.start.column,
              'message': formatOutput(item.type) + ' should be nested within its parent ' + formatOutput(previousVal.type),
              'severity': parser.severity
            });
          }
        }
        if (!item.is('space')) {
          previousVal = item;
        }
      });
    });
  });

  return result;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  }

  if (ast.content &amp;&amp; ast.content.length &gt; 0) {
ruleToggles = getToggledRules(ast);
isEnabledFilter = isResultEnabled(ruleToggles);

rules.forEach(function (rule) {
  detects = rule.rule.<span class="apidocCodeKeywordSpan">detect</span>(ast, rule)
    .filter(isEnabledFilter);
  results = results.concat(detects);
  if (detects.length) {
    if (rule.severity === 1) {
      warnings += detects.length;
    }
    else if (rule.severity === 2) {
...</pre></li>
    </ul>






</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.sass-lint.force_pseudo_nesting" id="apidoc.module.sass-lint.force_pseudo_nesting">module sass-lint.force_pseudo_nesting</a></h1>


    <h2>
        <a href="#apidoc.element.sass-lint.force_pseudo_nesting.detect" id="apidoc.element.sass-lint.force_pseudo_nesting.detect">
        function <span class="apidocSignatureSpan">sass-lint.force_pseudo_nesting.</span>detect
        <span class="apidocSignatureSpan">(ast, parser)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">detect = function (ast, parser) {
  var result = [],
      elements = nestableElements.concat(nestableAttributes, nestablePseudo);

  ast.traverseByType('ruleset', function (ruleset) {

    ruleset.forEach('selector', function (selector) {
      var previousVal;
      selector.forEach(function (item) {
        if (previousVal) {
          if (helpers.isNestable(item.type, previousVal.type, elements, nestablePseudo)) {
            helpers.addUnique(result, {
              'ruleId': parser.rule.name,
              'line': selector.start.line,
              'column': selector.start.column,
              'message': formatOutput(item.type) + ' should be nested within its parent ' + formatOutput(previousVal.type),
              'severity': parser.severity
            });
          }
        }
        previousVal = item;
      });
    });
  });

  return result;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  }

  if (ast.content &amp;&amp; ast.content.length &gt; 0) {
ruleToggles = getToggledRules(ast);
isEnabledFilter = isResultEnabled(ruleToggles);

rules.forEach(function (rule) {
  detects = rule.rule.<span class="apidocCodeKeywordSpan">detect</span>(ast, rule)
    .filter(isEnabledFilter);
  results = results.concat(detects);
  if (detects.length) {
    if (rule.severity === 1) {
      warnings += detects.length;
    }
    else if (rule.severity === 2) {
...</pre></li>
    </ul>






</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.sass-lint.function_name_format" id="apidoc.module.sass-lint.function_name_format">module sass-lint.function_name_format</a></h1>


    <h2>
        <a href="#apidoc.element.sass-lint.function_name_format.detect" id="apidoc.element.sass-lint.function_name_format.detect">
        function <span class="apidocSignatureSpan">sass-lint.function_name_format.</span>detect
        <span class="apidocSignatureSpan">(ast, parser)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">detect = function (ast, parser) {
  var result = [];

  ast.traverseByType('function', function (node) {
    var name = node.first('ident').content,
        strippedName,
        violationMessage = false;

    // ignore functions on whitelist - css3 transforms
    if (whitelist.indexOf(name) !== -1) {
      return;
    }

    strippedName = name;

    if (parser.options['allow-leading-underscore'] &amp;&amp; name[0] === '_') {
      strippedName = name.slice(1);
    }

    switch (parser.options.convention) {
    case 'hyphenatedlowercase':
      if (!helpers.isHyphenatedLowercase(strippedName)) {
        violationMessage = 'Function \'' + name + '\' should be written in lowercase with hyphens';
      }
      break;
    case 'camelcase':
      if (!helpers.isCamelCase(strippedName)) {
        violationMessage = 'Function \'' + name + '\' should be written in camelCase';
      }
      break;
    case 'pascalcase':
      if (!helpers.isPascalCase(strippedName)) {
        violationMessage = 'Function \'' + name + '\' should be written in PascalCase';
      }
      break;
    case 'snakecase':
      if (!helpers.isSnakeCase(strippedName)) {
        violationMessage = 'Function \'' + name + '\' should be written in snake_case';
      }
      break;
    case 'strictbem':
      if (!helpers.isStrictBEM(strippedName)) {
        violationMessage = 'Function \'' + name + '\' should be written in BEM (Block Element Modifier) format';
      }
      break;
    case 'hyphenatedbem':
      if (!helpers.isHyphenatedBEM(strippedName)) {
        violationMessage = 'Function \'' + name + '\' should be written in hyphenated BEM (Block Element Modifier) format';
      }
      break;
    default:
      if (!(new RegExp(parser.options.convention).test(strippedName))) {
        violationMessage = 'Function \'' + name + '\' should match regular expression /' + parser.options.convention + '/';

        // convention-message overrides violationMessage
        if (parser.options['convention-explanation']) {
          violationMessage = parser.options['convention-explanation'];
        }
      }
    }

    if (violationMessage) {
      result = helpers.addUnique(result, {
        'ruleId': parser.rule.name,
        'line': node.start.line,
        'column': node.start.column,
        'message': violationMessage,
        'severity': parser.severity
      });
    }
  });

  return result;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  }

  if (ast.content &amp;&amp; ast.content.length &gt; 0) {
ruleToggles = getToggledRules(ast);
isEnabledFilter = isResultEnabled(ruleToggles);

rules.forEach(function (rule) {
  detects = rule.rule.<span class="apidocCodeKeywordSpan">detect</span>(ast, rule)
    .filter(isEnabledFilter);
  results = results.concat(detects);
  if (detects.length) {
    if (rule.severity === 1) {
      warnings += detects.length;
    }
    else if (rule.severity === 2) {
...</pre></li>
    </ul>






</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.sass-lint.helpers" id="apidoc.module.sass-lint.helpers">module sass-lint.helpers</a></h1>


    <h2>
        <a href="#apidoc.element.sass-lint.helpers.addUnique" id="apidoc.element.sass-lint.helpers.addUnique">
        function <span class="apidocSignatureSpan">sass-lint.helpers.</span>addUnique
        <span class="apidocSignatureSpan">(results, item)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">addUnique = function (results, item) {
  if (this.isUnique(results, item)) {
    results.push(item);
  }
  return results;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
'include': true
  },
  'detect': function (ast, parser) {
var result = [];

ast.traverseByType('attributeValue', function (item) {
  if (item.content[0].is('string') &amp;&amp; !parser.options.include) {
    result = helpers.<span class="apidocCodeKeywordSpan">addUnique</span>(result, {
      'ruleId': parser.rule.name,
      'line': item.start.line,
      'column': item.start.column,
      'message': 'Attribute values should not be surrounded by quotes',
      'severity': parser.severity
    });
  }
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.sass-lint.helpers.attemptTraversal" id="apidoc.element.sass-lint.helpers.attemptTraversal">
        function <span class="apidocSignatureSpan">sass-lint.helpers.</span>attemptTraversal
        <span class="apidocSignatureSpan">(node, traversalPath)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">attemptTraversal = function (node, traversalPath) {
  var i,
      nextNodeList,
      currentNodeList = [],
      processChildNode = function processChildNode (child) {
        child.forEach(traversalPath[i], function (n) {
          nextNodeList.push(n);
        });
      };

  node.forEach(traversalPath[0], function (n) {
    currentNodeList.push(n);
  });

  for (i = 1; i &lt; traversalPath.length; i++) {
    if (currentNodeList.length === 0) {
      return [];
    }

    nextNodeList = [];
    currentNodeList.forEach(processChildNode);
    currentNodeList = nextNodeList;
  }
  return currentNodeList;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * Collects all suffix extensions for a selector
 * @param   {object}  ruleset      ASTNode of type ruleset, containing a selector with nested suffix extensions
 * @param   {string}  selectorType Node type of the selector (e.g. class, id)
 * @returns {array}                Array of Nodes with the content property replaced by the complete selector
 *                                       (without '.', '#', etc) resulting from suffix extensions
 */
helpers.collectSuffixExtensions = function (ruleset, selectorType) {
var parentSelectors = helpers.<span class="apidocCodeKeywordSpan">attemptTraversal</span>(ruleset, ['selector', selectorType
, 'ident']),
    childSuffixes = helpers.attemptTraversal(ruleset, ['block', 'ruleset']),
    selectorList = [];

if (parentSelectors.length === 0) {
  return [];
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.sass-lint.helpers.collectSuffixExtensions" id="apidoc.element.sass-lint.helpers.collectSuffixExtensions">
        function <span class="apidocSignatureSpan">sass-lint.helpers.</span>collectSuffixExtensions
        <span class="apidocSignatureSpan">(ruleset, selectorType)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">collectSuffixExtensions = function (ruleset, selectorType) {
  var parentSelectors = helpers.attemptTraversal(ruleset, ['selector', selectorType, 'ident']),
      childSuffixes = helpers.attemptTraversal(ruleset, ['block', 'ruleset']),
      selectorList = [];

  if (parentSelectors.length === 0) {
    return [];
  }

  // Goes recursively through all nodes that look like suffix extensions. There may be multiple parents that are
  // extended, so lots of looping is required.
  var processChildSuffix = function (child, parents) {
    var currentParents = [],
        selectors = helpers.attemptTraversal(child, ['selector', 'parentSelectorExtension', 'ident']),
        nestedChildSuffixes = helpers.attemptTraversal(child, ['block', 'ruleset']);

    selectors.forEach(function (childSuffixNode) {
      // append suffix extension to all parent selectors
      parents.forEach(function (parent) {
        // clone so we don't modify the actual AST
        var clonedChildSuffixNode = gonzales.createNode(childSuffixNode);
        clonedChildSuffixNode.content = parent.content + clonedChildSuffixNode.content;

        currentParents.push(clonedChildSuffixNode);
      });
    });

    selectorList = selectorList.concat(currentParents);

    nestedChildSuffixes.forEach(function (childSuffix) {
      processChildSuffix(childSuffix, currentParents);
    });
  };

  childSuffixes.forEach(function (childSuffix) {
    processChildSuffix(childSuffix, parentSelectors);
  });

  return parentSelectors.concat(selectorList);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
      depth, ' were found.'].join(''),
    'severity': parser.severity
  });
}
        }
      }
      else {
        selectorAndExtensions = helpers.<span class="apidocCodeKeywordSpan">collectSuffixExtensions</span>(node, 'class'
;);

        selectorAndExtensions.forEach(function (selector) {
name = selector.content;
depth = bemDepth(name);

if (depth &gt; maxDepth) {
  result = helpers.addUnique(result, {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.sass-lint.helpers.hasEOL" id="apidoc.element.sass-lint.helpers.hasEOL">
        function <span class="apidocSignatureSpan">sass-lint.helpers.</span>hasEOL
        <span class="apidocSignatureSpan">(str)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">hasEOL = function (str) {
  return /\r\n|\n/.test(str);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 */
var isClosingBraceOnNewLine = function (node) {
  if (node.contains('block')) {
    var content = node.first('block'),
        contentLength = content.length - 1,
        lastNode = content.get(contentLength);

    if (lastNode &amp;&amp; lastNode.is('space') &amp;&amp; helpers.<span class="apidocCodeKeywordSpan">hasEOL</span>(lastNode.content)) {
      return true;
    }
    return false;
  }
  return null;
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.sass-lint.helpers.isCamelCase" id="apidoc.element.sass-lint.helpers.isCamelCase">
        function <span class="apidocSignatureSpan">sass-lint.helpers.</span>isCamelCase
        <span class="apidocSignatureSpan">(str)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isCamelCase = function (str) {
  return /^[a-z][a-zA-Z0-9]*$/.test(str);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
switch (parser.options.convention) {
case 'hyphenatedlowercase':
  if (!helpers.isHyphenatedLowercase(strippedName)) {
    violationMessage = 'Class \'.' + name + '\' should be written in lowercase with hyphens';
  }
  break;
case 'camelcase':
  if (!helpers.<span class="apidocCodeKeywordSpan">isCamelCase</span>(strippedName)) {
    violationMessage = 'Class \'.' + name + '\' should be written in camelCase';
  }
  break;
case 'pascalcase':
  if (!helpers.isPascalCase(strippedName)) {
    violationMessage = 'Class \'.' + name + '\' should be written in PascalCase';
  }
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.sass-lint.helpers.isEmptyLine" id="apidoc.element.sass-lint.helpers.isEmptyLine">
        function <span class="apidocSignatureSpan">sass-lint.helpers.</span>isEmptyLine
        <span class="apidocSignatureSpan">(str)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isEmptyLine = function (str) {
  return /(\r\n|\n){2}/.test(str);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

if (i &gt;= 2) {
  doublePrevious = parent.content[i - 2];

  // First check to see that the previous line is not a new line as if it is
  // we don't want to recursively run the function again

  if (!helpers.<span class="apidocCodeKeywordSpan">isEmptyLine</span>(previous.content)) {
    if (doublePrevious.type.indexOf('Comment') !== -1) {
      return findNearestReturnSCSS(parent, i - 1);
    }
  }
}

if (i &gt;= 1) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.sass-lint.helpers.isEqual" id="apidoc.element.sass-lint.helpers.isEqual">
        function <span class="apidocSignatureSpan">sass-lint.helpers.</span>isEqual
        <span class="apidocSignatureSpan">(a, b)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isEqual = function (a, b) {
  var startLine = a.start.line === b.start.line ? true : false,
      endLine = a.end.line === b.end.line ? true : false,
      type = a.type === b.type ? true : false,
      length = a.content.length === b.content.length ? true : false;

  if (startLine &amp;&amp; endLine &amp;&amp; type &amp;&amp; length) {
    return true;
  }
  else {
    return false;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    empty = false;

if (block.content.length === 0) {
  empty = true;
}
else {
  block.traverse(function (item) {
    if (!helpers.<span class="apidocCodeKeywordSpan">isEqual</span>(block, item)) {
      if (item.type !== 'space') {
        nonSpaceCount++;
      }
    }
  });
  if (nonSpaceCount === 0) {
    empty = true;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.sass-lint.helpers.isHyphenatedBEM" id="apidoc.element.sass-lint.helpers.isHyphenatedBEM">
        function <span class="apidocSignatureSpan">sass-lint.helpers.</span>isHyphenatedBEM
        <span class="apidocSignatureSpan">(str)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isHyphenatedBEM = function (str) {
  return !(/[A-Z]|-{3}|_{3}|[^_]_[^_]/.test(str));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  break;
case 'strictbem':
  if (!helpers.isStrictBEM(strippedName)) {
    violationMessage = 'Class \'.' + name + '\' should be written in BEM (Block Element Modifier) format
';
  }
  break;
case 'hyphenatedbem':
  if (!helpers.<span class="apidocCodeKeywordSpan">isHyphenatedBEM</span>(strippedName)) {
    violationMessage = 'Class \'.' + name + '\' should be written in hyphenated BEM (Block Element Modifier
) format';
  }
  break;
default:
  if (!(new RegExp(parser.options.convention).test(strippedName))) {
    violationMessage = 'Class \'.' + name + '\' should match regular expression /' + parser.options
.convention + '/';
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.sass-lint.helpers.isHyphenatedLowercase" id="apidoc.element.sass-lint.helpers.isHyphenatedLowercase">
        function <span class="apidocSignatureSpan">sass-lint.helpers.</span>isHyphenatedLowercase
        <span class="apidocSignatureSpan">(str)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isHyphenatedLowercase = function (str) {
  return !(/[^\-a-z0-9]/.test(str));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

if (parser.options['allow-leading-underscore'] &amp;&amp; name[0] === '_') {
  strippedName = name.slice(1);
}

switch (parser.options.convention) {
case 'hyphenatedlowercase':
  if (!helpers.<span class="apidocCodeKeywordSpan">isHyphenatedLowercase</span>(strippedName)) {
    violationMessage = 'Class \'.' + name + '\' should be written in lowercase with hyphens';
  }
  break;
case 'camelcase':
  if (!helpers.isCamelCase(strippedName)) {
    violationMessage = 'Class \'.' + name + '\' should be written in camelCase';
  }
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.sass-lint.helpers.isLowerCase" id="apidoc.element.sass-lint.helpers.isLowerCase">
        function <span class="apidocSignatureSpan">sass-lint.helpers.</span>isLowerCase
        <span class="apidocSignatureSpan">(str)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isLowerCase = function (str) {
  var pieces = str.split(''),
      i,
      result = 0;

  for (i = 0; i &lt; pieces.length; i++) {
    if (!helpers.isNumber(pieces[i])) {
      if (pieces[i] === pieces[i].toLowerCase() &amp;&amp; pieces[i] !== pieces[i].toUpperCase()) {
        result++;
      }
      else {
        return false;
      }
    }
  }
  if (result) {
    return true;
  }
  return false;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  },
  'detect': function (ast, parser) {
var result = [];

ast.traverseByType('color', function (value) {
  if (value.content.match(/[a-z]/i)) {
    if (parser.options.style === 'lowercase') {
      if (!helpers.<span class="apidocCodeKeywordSpan">isLowerCase</span>(value.content)) {
        result = helpers.addUnique(result, {
          'ruleId': parser.rule.name,
          'line': value.start.line,
          'column': value.start.column,
          'message': 'Hex notation should all be lower case',
          'severity': parser.severity
        });
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.sass-lint.helpers.isNestable" id="apidoc.element.sass-lint.helpers.isNestable">
        function <span class="apidocSignatureSpan">sass-lint.helpers.</span>isNestable
        <span class="apidocSignatureSpan">(currentVal, previousVal, elements, nestable)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isNestable = function (currentVal, previousVal, elements, nestable) {
  // check if they are nestable by checking the previous element against one
  // of the user specified selector types
  if (elements.indexOf(previousVal) !== -1 &amp;&amp; nestable.indexOf(currentVal) !== -1) {
    return true;
  }

  return false;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

    ast.traverseByType('ruleset', function (ruleset) {

ruleset.forEach('selector', function (selector) {
  var previousVal;
  selector.forEach(function (item) {
    if (previousVal) {
      if (helpers.<span class="apidocCodeKeywordSpan">isNestable</span>(item.type, previousVal.type, elements, nestableAttributes
)) {
        helpers.addUnique(result, {
          'ruleId': parser.rule.name,
          'line': selector.start.line,
          'column': selector.start.column,
          'message': formatOutput(item.type) + ' should be nested within its parent ' + formatOutput(previousVal
.type),
          'severity': parser.severity
        });
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.sass-lint.helpers.isNewLine" id="apidoc.element.sass-lint.helpers.isNewLine">
        function <span class="apidocSignatureSpan">sass-lint.helpers.</span>isNewLine
        <span class="apidocSignatureSpan">(node)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isNewLine = function (node) {
  // using type === instead of is just in case node happens to be a string
  return !!(node &amp;&amp; node.type === 'space' &amp;&amp; node.content.match('\n'));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
      plural = level &gt; 1 ? 's' : '';
      reportNode = nextNode;
      reportCondition = i !== node.length - 1;
    }
  }
}
else if (n.syntax === 'sass') {
  if (n.is('declarationDelimiter') || (helpers.<span class="apidocCodeKeywordSpan">isNewLine</span>(n))) {
    // Due to the way gonzales handles line endings in Sass we don't care if it's CRLF or just LF
    if (nextNode &amp;&amp; nextNode.is('space') &amp;&amp; nextNode.content.indexOf('\n') === -1) {
      spaceLength = nextNode.content.length;
      spaceCount = nextNode.content.match(/ /g);
      tabCount = nextNode.content.match(/\t/g);
      plural = level &gt; 1 ? 's' : '';
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.sass-lint.helpers.isNumber" id="apidoc.element.sass-lint.helpers.isNumber">
        function <span class="apidocSignatureSpan">sass-lint.helpers.</span>isNumber
        <span class="apidocSignatureSpan">(val)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isNumber = function (val) {
  if (isNaN(parseInt(val, 10))) {
    return false;
  }
  return true;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

helpers.isUpperCase = function (str) {
var pieces = str.split(''),
    i,
    result = 0;

for (i = 0; i &lt; pieces.length; i++) {
  if (!helpers.<span class="apidocCodeKeywordSpan">isNumber</span>(pieces[i])) {
    if (pieces[i] === pieces[i].toUpperCase() &amp;&amp; pieces[i] !== pieces[i].toLowerCase()) {
      result++;
    }
    else {
      return false;
    }
  }
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.sass-lint.helpers.isPartialStringMatch" id="apidoc.element.sass-lint.helpers.isPartialStringMatch">
        function <span class="apidocSignatureSpan">sass-lint.helpers.</span>isPartialStringMatch
        <span class="apidocSignatureSpan">(needle, haystack)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isPartialStringMatch = function (needle, haystack) {
  for (var i = 0; i &lt; haystack.length; i++) {
    if (haystack[i].indexOf(needle) &gt;= 0) {
      return true;
    }
  }

  return false;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var curProperty = node.first().content,
    propertyList = getCombinedList(properties, parser.options['extra-properties']);

if (curProperty.charAt(0) === '-') {
  curProperty = helpers.stripPrefix(curProperty);
}

if (helpers.<span class="apidocCodeKeywordSpan">isPartialStringMatch</span>(curProperty, propertyList)) {
  return false;
}

if (curProperty.length &gt; 0) {
  result = helpers.addUnique(result, {
    'ruleId': parser.rule.name,
    'line': node.start.line,
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.sass-lint.helpers.isPascalCase" id="apidoc.element.sass-lint.helpers.isPascalCase">
        function <span class="apidocSignatureSpan">sass-lint.helpers.</span>isPascalCase
        <span class="apidocSignatureSpan">(str)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isPascalCase = function (str) {
  return /^[A-Z][a-zA-Z0-9]*$/.test(str);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  break;
case 'camelcase':
  if (!helpers.isCamelCase(strippedName)) {
    violationMessage = 'Class \'.' + name + '\' should be written in camelCase';
  }
  break;
case 'pascalcase':
  if (!helpers.<span class="apidocCodeKeywordSpan">isPascalCase</span>(strippedName)) {
    violationMessage = 'Class \'.' + name + '\' should be written in PascalCase';
  }
  break;
case 'snakecase':
  if (!helpers.isSnakeCase(strippedName)) {
    violationMessage = 'Class \'.' + name + '\' should be written in snake_case';
  }
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.sass-lint.helpers.isSnakeCase" id="apidoc.element.sass-lint.helpers.isSnakeCase">
        function <span class="apidocSignatureSpan">sass-lint.helpers.</span>isSnakeCase
        <span class="apidocSignatureSpan">(str)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isSnakeCase = function (str) {
  return !(/[^_a-z0-9]/.test(str));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  break;
case 'pascalcase':
  if (!helpers.isPascalCase(strippedName)) {
    violationMessage = 'Class \'.' + name + '\' should be written in PascalCase';
  }
  break;
case 'snakecase':
  if (!helpers.<span class="apidocCodeKeywordSpan">isSnakeCase</span>(strippedName)) {
    violationMessage = 'Class \'.' + name + '\' should be written in snake_case';
  }
  break;
case 'strictbem':
  if (!helpers.isStrictBEM(strippedName)) {
    violationMessage = 'Class \'.' + name + '\' should be written in BEM (Block Element Modifier) format
';
  }
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.sass-lint.helpers.isSpace" id="apidoc.element.sass-lint.helpers.isSpace">
        function <span class="apidocSignatureSpan">sass-lint.helpers.</span>isSpace
        <span class="apidocSignatureSpan">(node)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isSpace = function (node) {
  return !!(node &amp;&amp; node.type === 'space' &amp;&amp; !node.content.match('\n'));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    }

    reportNode = sassNextNode;
    reportCondition = true;
  }
}
// Check all the spaces in Sass that aren't newlines
else if (helpers.<span class="apidocCodeKeywordSpan">isSpace</span>(n)) {
  // This is a special condition for the first property in a block with Sass as it usually
  // doesn't have a previous node before the space appears so we need to check this is
  // valid and then we can rely on the declarationDelimiter check above.
  if (inBlock &amp;&amp; (!prevNode || prevNode.is('space'))) {
    inBlock = false;
    spaceLength = n.content.length;
    spaceCount = n.content.match(/ /g);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.sass-lint.helpers.isStrictBEM" id="apidoc.element.sass-lint.helpers.isStrictBEM">
        function <span class="apidocSignatureSpan">sass-lint.helpers.</span>isStrictBEM
        <span class="apidocSignatureSpan">(str)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isStrictBEM = function (str) {
  return /^[a-z](\-?[a-z0-9]+)*(__[a-z0-9](\-?[a-z0-9]+)*)?((_[a-z0-9](\-?[a-z0-9]+)*){0,2})?$/.test(str);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  break;
case 'snakecase':
  if (!helpers.isSnakeCase(strippedName)) {
    violationMessage = 'Class \'.' + name + '\' should be written in snake_case';
  }
  break;
case 'strictbem':
  if (!helpers.<span class="apidocCodeKeywordSpan">isStrictBEM</span>(strippedName)) {
    violationMessage = 'Class \'.' + name + '\' should be written in BEM (Block Element Modifier) format
';
  }
  break;
case 'hyphenatedbem':
  if (!helpers.isHyphenatedBEM(strippedName)) {
    violationMessage = 'Class \'.' + name + '\' should be written in hyphenated BEM (Block Element Modifier
) format';
  }
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.sass-lint.helpers.isUnique" id="apidoc.element.sass-lint.helpers.isUnique">
        function <span class="apidocSignatureSpan">sass-lint.helpers.</span>isUnique
        <span class="apidocSignatureSpan">(results, item)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isUnique = function (results, item) {
  var search = this.propertySearch(results, item.line, 'line');

  if (search === -1) {
    return true;
  }
  else if (results[search].column === item.column &amp;&amp; results[search].message === item.message) {
    return false;
  }
  else {
    return true;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
}
else {
  return true;
}
};

helpers.addUnique = function (results, item) {
if (this.<span class="apidocCodeKeywordSpan">isUnique</span>(results, item)) {
  results.push(item);
}
return results;
};

helpers.sortDetects = function (a, b) {
if (a.line &lt; b.line) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.sass-lint.helpers.isUpperCase" id="apidoc.element.sass-lint.helpers.isUpperCase">
        function <span class="apidocSignatureSpan">sass-lint.helpers.</span>isUpperCase
        <span class="apidocSignatureSpan">(str)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isUpperCase = function (str) {
  var pieces = str.split(''),
      i,
      result = 0;

  for (i = 0; i &lt; pieces.length; i++) {
    if (!helpers.isNumber(pieces[i])) {
      if (pieces[i] === pieces[i].toUpperCase() &amp;&amp; pieces[i] !== pieces[i].toLowerCase()) {
        result++;
      }
      else {
        return false;
      }
    }
  }
  if (result) {
    return true;
  }
  return false;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
      'column': value.start.column,
      'message': 'Hex notation should all be lower case',
      'severity': parser.severity
    });
  }
}
else if (parser.options.style === 'uppercase') {
  if (!helpers.<span class="apidocCodeKeywordSpan">isUpperCase</span>(value.content)) {
    result = helpers.addUnique(result, {
      'ruleId': parser.rule.name,
      'line': value.start.line,
      'column': value.start.column,
      'message': 'Hex notation should all be upper case',
      'severity': parser.severity
    });
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.sass-lint.helpers.isValidHex" id="apidoc.element.sass-lint.helpers.isValidHex">
        function <span class="apidocSignatureSpan">sass-lint.helpers.</span>isValidHex
        <span class="apidocSignatureSpan">(str)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isValidHex = function (str) {
  if (str.match(/^([A-Fa-f0-9]{6}|[A-Fa-f0-9]{3})$/)) {
    return true;
  }
  return false;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* Check if the value is a color literal
*
* @param {Object} node - The node we're checking
* @param {Array} validColorFunctions - The array of valid color function types to check against
* @returns {boolean} Whether the node matches the specified types
*/
var checkIsLiteral = function (node, validColorFunctions) {
 return cssColors.indexOf(node.content) !== -1 || helpers.<span class="apidocCodeKeywordSpan">isValidHex</span>(node.content) ||
validColorFunctions.indexOf(node.content) !== -1;
};

/**
* Checks the see if the node type is a hex value if so return the correct prefix
*
* @param {String} nodeType - The node type identifier
* @returns {String} Either a '#' or an empty string
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.sass-lint.helpers.loadConfigFile" id="apidoc.element.sass-lint.helpers.loadConfigFile">
        function <span class="apidocSignatureSpan">sass-lint.helpers.</span>loadConfigFile
        <span class="apidocSignatureSpan">(configPath)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">loadConfigFile = function (configPath) {
  var fileDir = path.dirname(configPath),
      fileName = path.basename(configPath),
      fileExtension = path.extname(fileName),
      filePath = path.join(__dirname, 'config', fileDir, fileName),
      file = fs.readFileSync(filePath, 'utf8') || false;

  if (file) {
    if (fileExtension === '.yml') {
      return yaml.safeLoad(file);
    }
  }

  return file;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  'concentric': 'concentric.yml'
};

var getOrderConfig = function (order) {
  if (typeof order === 'string') {
    if (orderPresets.hasOwnProperty(order)) {
      var filename = orderPresets[order],
          orderConfig = helpers.<span class="apidocCodeKeywordSpan">loadConfigFile</span>('property-sort-orders/' + filename
);

      return orderConfig.order;
    }
  }

  return false;
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.sass-lint.helpers.log" id="apidoc.element.sass-lint.helpers.log">
        function <span class="apidocSignatureSpan">sass-lint.helpers.</span>log
        <span class="apidocSignatureSpan">(input)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function log(input) {
  console.log(util.inspect(input, false, null));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  if (this.resultCount(results)) {

var formatted = this.format(results, options, configPath);

if (config.options['output-file']) {
  try {
    fs.outputFileSync(path.resolve(process.cwd(), config.options['output-file']), formatted);
    console.<span class="apidocCodeKeywordSpan">log</span>('Output successfully written to ' + path.resolve(process.cwd
(), config.options['output-file']));
  }
  catch (e) {
    console.log('Error: Output was unable to be written to ' + path.resolve(process.cwd(), config.options['output
-file']));
  }
}
else {
  console.log(formatted);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.sass-lint.helpers.propertySearch" id="apidoc.element.sass-lint.helpers.propertySearch">
        function <span class="apidocSignatureSpan">sass-lint.helpers.</span>propertySearch
        <span class="apidocSignatureSpan">(haystack, needle, property)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">propertySearch = function (haystack, needle, property) {
  var length = haystack.length,
      i;

  for (i = 0; i &lt; length; i++) {
    if (haystack[i][property] === needle) {
      return i;
    }
  }
  return -1;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
}
else {
  return false;
}
};

helpers.isUnique = function (results, item) {
var search = this.<span class="apidocCodeKeywordSpan">propertySearch</span>(results, item.line, 'line');

if (search === -1) {
  return true;
}
else if (results[search].column === item.column &amp;&amp; results[search].message === item.message) {
  return false;
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.sass-lint.helpers.sortDetects" id="apidoc.element.sass-lint.helpers.sortDetects">
        function <span class="apidocSignatureSpan">sass-lint.helpers.</span>sortDetects
        <span class="apidocSignatureSpan">(a, b)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">sortDetects = function (a, b) {
  if (a.line &lt; b.line) {
    return -1;
  }
  if (a.line &gt; b.line) {
    return 1;
  }
  if (a.line === b.line) {
    if (a.column &lt; b.column) {
      return -1;
    }
    if (a.column &gt; b.column) {
      return 1;
    }
    return 0;
  }
  return 0;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.sass-lint.helpers.stripBom" id="apidoc.element.sass-lint.helpers.stripBom">
        function <span class="apidocSignatureSpan">sass-lint.helpers.</span>stripBom
        <span class="apidocSignatureSpan">(str)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">stripBom = function (str) {
  if (typeof str !== 'string') {
    throw new TypeError('Expected a string, got ' + typeof str);
  }

  if (str.charCodeAt(0) === 0xFEFF) {
    return str.slice(1);
  }

  return str;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var fm = require('front-matter');
var helpers = require('./helpers');

module.exports = function (text, syntax, filename) {
var tree;

// Run `.toString()` to allow Buffers to be passed in
text = helpers.<span class="apidocCodeKeywordSpan">stripBom</span>(text.toString());

// if we're skipping front matter do it here, fall back to just our text in case it fails
if (fm.test(text)) {
  text = fm(text).body || text;
}

try {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.sass-lint.helpers.stripLastSpace" id="apidoc.element.sass-lint.helpers.stripLastSpace">
        function <span class="apidocSignatureSpan">sass-lint.helpers.</span>stripLastSpace
        <span class="apidocSignatureSpan">(selector)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">stripLastSpace = function (selector) {

  if (selector.charAt(selector.length - 1) === ' ') {
    return selector.substr(0, selector.length - 1);

  }

  return selector;

}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * @param {string} line - The line that the ruleset starts
 * @param {string} col - The column that the ruleset starts
 * @returns {undefined}
 */
var updateList = function (ruleSet, isAtRule, line, col) {
  parentSelector[curLevel] = ruleSet;
  curSelector = {
    selector: helpers.<span class="apidocCodeKeywordSpan">stripLastSpace</span>(parentSelector.join('')),
    line: line,
    column: col
  };
  if (!isAtRule) {
    selectorList.push(curSelector);
  }
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.sass-lint.helpers.stripPrefix" id="apidoc.element.sass-lint.helpers.stripPrefix">
        function <span class="apidocSignatureSpan">sass-lint.helpers.</span>stripPrefix
        <span class="apidocSignatureSpan">(str)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">stripPrefix = function (str) {
  var modPropertyArr = str.split('-'),
      modProperty = '',
      prefLength = modPropertyArr[2] === 'osx' ? 2 : 1;

  modPropertyArr.splice(1, prefLength);

  modPropertyArr.forEach(function (item, index) {
    modProperty = modProperty + item;
    if (index &gt; 0 &amp;&amp; index &lt; modPropertyArr.length - 1) {
      modProperty = modProperty + '-';
    }
  });

  return modProperty;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

    ast.traverseByType('property', function (node) {
      if (node.first().is('ident')) {
var curProperty = node.first().content,
    propertyList = getCombinedList(properties, parser.options['extra-properties']);

if (curProperty.charAt(0) === '-') {
  curProperty = helpers.<span class="apidocCodeKeywordSpan">stripPrefix</span>(curProperty);
}

if (helpers.isPartialStringMatch(curProperty, propertyList)) {
  return false;
}

if (curProperty.length &gt; 0) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.sass-lint.helpers.stripQuotes" id="apidoc.element.sass-lint.helpers.stripQuotes">
        function <span class="apidocSignatureSpan">sass-lint.helpers.</span>stripQuotes
        <span class="apidocSignatureSpan">(str)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">stripQuotes = function (str) {
  return str.substring(1, str.length - 1);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

var getImportPath = function (parent, syntax) {
  if (parent.first('uri')) {
return parent.first('uri');
  }

  if (parent.first('string')) {
return helpers.<span class="apidocCodeKeywordSpan">stripQuotes</span>(parent.first('string').content);
  }

  if (parent.first('ident')) {

if (syntax === 'sass') {
  var output = '',
      isFinished = false;
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.sass-lint.hex_length" id="apidoc.module.sass-lint.hex_length">module sass-lint.hex_length</a></h1>


    <h2>
        <a href="#apidoc.element.sass-lint.hex_length.detect" id="apidoc.element.sass-lint.hex_length.detect">
        function <span class="apidocSignatureSpan">sass-lint.hex_length.</span>detect
        <span class="apidocSignatureSpan">(ast, parser)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">detect = function (ast, parser) {
  var result = [];

  ast.traverseByType('color', function (value) {
    if (parser.options.style === 'short' &amp;&amp; canShorten(value.content)) {
      result = helpers.addUnique(result, {
        'ruleId': parser.rule.name,
        'line': value.start.line,
        'column': value.start.column,
        'message': 'Hex values should use the shorthand format - 3 characters where possible',
        'severity': parser.severity
      });
    }
    else if (parser.options.style === 'long') {
      if (value.content.length !== lengths.long) {
        result = helpers.addUnique(result, {
          'ruleId': parser.rule.name,
          'line': value.start.line,
          'column': value.start.column,
          'message': 'Hex values should use the long-form format - 6 characters',
          'severity': parser.severity
        });
      }
    }
  });

  return result;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  }

  if (ast.content &amp;&amp; ast.content.length &gt; 0) {
ruleToggles = getToggledRules(ast);
isEnabledFilter = isResultEnabled(ruleToggles);

rules.forEach(function (rule) {
  detects = rule.rule.<span class="apidocCodeKeywordSpan">detect</span>(ast, rule)
    .filter(isEnabledFilter);
  results = results.concat(detects);
  if (detects.length) {
    if (rule.severity === 1) {
      warnings += detects.length;
    }
    else if (rule.severity === 2) {
...</pre></li>
    </ul>






</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.sass-lint.hex_notation" id="apidoc.module.sass-lint.hex_notation">module sass-lint.hex_notation</a></h1>


    <h2>
        <a href="#apidoc.element.sass-lint.hex_notation.detect" id="apidoc.element.sass-lint.hex_notation.detect">
        function <span class="apidocSignatureSpan">sass-lint.hex_notation.</span>detect
        <span class="apidocSignatureSpan">(ast, parser)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">detect = function (ast, parser) {
  var result = [];

  ast.traverseByType('color', function (value) {
    if (value.content.match(/[a-z]/i)) {
      if (parser.options.style === 'lowercase') {
        if (!helpers.isLowerCase(value.content)) {
          result = helpers.addUnique(result, {
            'ruleId': parser.rule.name,
            'line': value.start.line,
            'column': value.start.column,
            'message': 'Hex notation should all be lower case',
            'severity': parser.severity
          });
        }
      }
      else if (parser.options.style === 'uppercase') {
        if (!helpers.isUpperCase(value.content)) {
          result = helpers.addUnique(result, {
            'ruleId': parser.rule.name,
            'line': value.start.line,
            'column': value.start.column,
            'message': 'Hex notation should all be upper case',
            'severity': parser.severity
          });
        }
      }
    }
  });

  return result;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  }

  if (ast.content &amp;&amp; ast.content.length &gt; 0) {
ruleToggles = getToggledRules(ast);
isEnabledFilter = isResultEnabled(ruleToggles);

rules.forEach(function (rule) {
  detects = rule.rule.<span class="apidocCodeKeywordSpan">detect</span>(ast, rule)
    .filter(isEnabledFilter);
  results = results.concat(detects);
  if (detects.length) {
    if (rule.severity === 1) {
      warnings += detects.length;
    }
    else if (rule.severity === 2) {
...</pre></li>
    </ul>






</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.sass-lint.id_name_format" id="apidoc.module.sass-lint.id_name_format">module sass-lint.id_name_format</a></h1>


    <h2>
        <a href="#apidoc.element.sass-lint.id_name_format.detect" id="apidoc.element.sass-lint.id_name_format.detect">
        function <span class="apidocSignatureSpan">sass-lint.id_name_format.</span>detect
        <span class="apidocSignatureSpan">(ast, parser)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">detect = function (ast, parser) {
  var result = [];

  ast.traverseByType('ruleset', function (ruleset) {
    var selectorAndExtensions = helpers.collectSuffixExtensions(ruleset, 'id');

    selectorAndExtensions.forEach(function (node) {
      var name = node.content,
          strippedName,
          violationMessage = false;

      if (parser.options.ignore.indexOf(name) !== -1) {
        return;
      }

      strippedName = name;

      if (parser.options['allow-leading-underscore'] &amp;&amp; name[0] === '_') {
        strippedName = name.slice(1);
      }

      switch (parser.options.convention) {
      case 'hyphenatedlowercase':
        if (!helpers.isHyphenatedLowercase(strippedName)) {
          violationMessage = 'ID \'#' + name + '\' should be written in lowercase with hyphens';
        }
        break;
      case 'camelcase':
        if (!helpers.isCamelCase(strippedName)) {
          violationMessage = 'ID \'#' + name + '\' should be written in camelCase';
        }
        break;
      case 'pascalcase':
        if (!helpers.isPascalCase(strippedName)) {
          violationMessage = 'ID \'#' + name + '\' should be written in PascalCase';
        }
        break;
      case 'snakecase':
        if (!helpers.isSnakeCase(strippedName)) {
          violationMessage = 'ID \'#' + name + '\' should be written in snake_case';
        }
        break;
      default:
        if (!(new RegExp(parser.options.convention).test(strippedName))) {
          violationMessage = 'ID \'#' + name + '\' should match regular expression /' + parser.options.convention + '/';

          // convention-message overrides violationMessage
          if (parser.options['convention-explanation']) {
            violationMessage = parser.options['convention-explanation'];
          }
        }
      }

      if (violationMessage) {
        result = helpers.addUnique(result, {
          'ruleId': parser.rule.name,
          'line': node.start.line,
          'column': node.start.column,
          'message': violationMessage,
          'severity': parser.severity
        });
      }
    });
  });

  return result;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  }

  if (ast.content &amp;&amp; ast.content.length &gt; 0) {
ruleToggles = getToggledRules(ast);
isEnabledFilter = isResultEnabled(ruleToggles);

rules.forEach(function (rule) {
  detects = rule.rule.<span class="apidocCodeKeywordSpan">detect</span>(ast, rule)
    .filter(isEnabledFilter);
  results = results.concat(detects);
  if (detects.length) {
    if (rule.severity === 1) {
      warnings += detects.length;
    }
    else if (rule.severity === 2) {
...</pre></li>
    </ul>






</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.sass-lint.indentation" id="apidoc.module.sass-lint.indentation">module sass-lint.indentation</a></h1>


    <h2>
        <a href="#apidoc.element.sass-lint.indentation.detect" id="apidoc.element.sass-lint.indentation.detect">
        function <span class="apidocSignatureSpan">sass-lint.indentation.</span>detect
        <span class="apidocSignatureSpan">(ast, parser)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">detect = function (ast, parser) {
  var result = [],
      inAtRule = false,
      inProps = false,
      inBlock = false,
      lintSize = parser.options.size,
      lintType = 'space',
      plural = '',
      detected = [lintType];

  // Prepare to check for mixed spaces or tabs depending on what the user has specified
  if (parser.options.size === 'tab') {
    lintSize = 1;
    lintType = 'tab';
    detected[0] = lintType;
  }

  var processNode = function (node, level) {
    var i,
        n,
        prevNode,
        nextNode,
        sassNextNode,
        reportNode,
        reportCondition,
        space,
        spaceLength,
        newlineLength,
        spaceCount,
        tabCount,
        mixedWarning;

    level = level || 0;

    if (node.is('braces')) {
      return;
    }

    for (i = 0; i &lt; node.length; i++) {
      n = node.get(i);
      prevNode = node.get(i - 1);
      nextNode = node.get(i + 1) || false;
      // Due to the Sass structure in gonzales we sometimes need to check 2 ahead
      sassNextNode = node.get(i + 2) || false;
      reportNode = null;

      if (!n) {
        continue;
      }

      if (n.syntax === 'scss') {
        if (n.type === 'space') {

          // Test for CRLF first, since it includes LF
          space = n.content.lastIndexOf('\r\n');
          newlineLength = 2;

          if (space === -1) {
            // Test for LF
            space = n.content.lastIndexOf('\n');
            newlineLength = 1;
          }

          if (space &gt;= 0) {
            // Check how many spaces or tabs we have and set our plural character if necessary for
            // our lint reporting message
            spaceLength = n.content.slice(space + newlineLength).length;
            spaceCount = n.content.slice(space + newlineLength).match(/ /g);
            tabCount = n.content.slice(space + newlineLength).match(/\t/g);
            plural = level &gt; 1 ? 's' : '';
            reportNode = nextNode;
            reportCondition = i !== node.length - 1;
          }
        }
      }
      else if (n.syntax === 'sass') {
        if (n.is('declarationDelimiter') || (helpers.isNewLine(n))) {
          // Due to the way gonzales handles line endings in Sass we don't care if it's CRLF or just LF
          if (nextNode &amp;&amp; nextNode.is('space') &amp;&amp; nextNode.content.indexOf('\n') === -1) {
            spaceLength = nextNode.content.length;
            spaceCount = nextNode.content.match(/ /g);
            tabCount = nextNode.content.match(/\t/g);
            plural = level &gt; 1 ? 's' : '';

            // if we're at the end of a block we want to drop the level here for Sass
            if (!node.get(i + 2)) {
              level--;
            }

            reportNode = sassNextNode;
            reportCondition = true;
          }
        }
        // Check all the spaces in Sass that aren't newlines
        else if (helpers.isSpace(n)) {
          // This is a special condition for the first property in a block with Sass as it usually
          // doesn't have a previous node before the space appears so we need to check this is
          // valid and then we can rely on the declarationDelimiter check above.
          if (inBlock &amp;&amp; (!prevNode || prevNode.is('space'))) {
            inBlock = false;
            spaceLength = n.content.length;
            spaceCount = n.content.match(/ /g);
            tabCount = n.content.match(/\t/g);
            plural = level &gt; 1 ? 's' : '';
            reportNode = nextNode;
            reportCondition = true;
          }
          // A extra check for tabs when using spaces as single tab characters aren't highlighted
          // as mixed spaces and tabs without this. Spaces on the other hand are fine. Gonzales
          // reports them a little differently.
          else if (n.type === 'space' &amp;&amp; lintType === 'space') {
            tabCount = n.content.match(/\t/g);
            reportNode = nextNode;
            // we dont want to check the lint levels here as it could be a tab between a prop and
            // value, totally unrealistic I know but we still want to repo ...</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  }

  if (ast.content &amp;&amp; ast.content.length &gt; 0) {
ruleToggles = getToggledRules(ast);
isEnabledFilter = isResultEnabled(ruleToggles);

rules.forEach(function (rule) {
  detects = rule.rule.<span class="apidocCodeKeywordSpan">detect</span>(ast, rule)
    .filter(isEnabledFilter);
  results = results.concat(detects);
  if (detects.length) {
    if (rule.severity === 1) {
      warnings += detects.length;
    }
    else if (rule.severity === 2) {
...</pre></li>
    </ul>






</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.sass-lint.leading_zero" id="apidoc.module.sass-lint.leading_zero">module sass-lint.leading_zero</a></h1>


    <h2>
        <a href="#apidoc.element.sass-lint.leading_zero.detect" id="apidoc.element.sass-lint.leading_zero.detect">
        function <span class="apidocSignatureSpan">sass-lint.leading_zero.</span>detect
        <span class="apidocSignatureSpan">(ast, parser)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">detect = function (ast, parser) {
  var result = [];

  ast.traverseByType('number', function (num) {
    if (num.content.match(/^-?(0?\.\d+)/)) {
      if (num.content.match(leadingZeroRegex)) {
        if (!parser.options.include) {
          result = helpers.addUnique(result, {
            'ruleId': parser.rule.name,
            'line': num.start.line,
            'column': num.start.column,
            'message': 'Don\'t include leading zeros on numbers',
            'severity': parser.severity
          });
        }
      }
      if (num.content.match(noLeadingZeroRegex)) {
        if (parser.options.include) {
          result = helpers.addUnique(result, {
            'ruleId': parser.rule.name,
            'line': num.start.line,
            'column': num.start.column - 1,
            'message': 'Include leading zeros on numbers',
            'severity': parser.severity
          });
        }
      }
    }
  });

  return result;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  }

  if (ast.content &amp;&amp; ast.content.length &gt; 0) {
ruleToggles = getToggledRules(ast);
isEnabledFilter = isResultEnabled(ruleToggles);

rules.forEach(function (rule) {
  detects = rule.rule.<span class="apidocCodeKeywordSpan">detect</span>(ast, rule)
    .filter(isEnabledFilter);
  results = results.concat(detects);
  if (detects.length) {
    if (rule.severity === 1) {
      warnings += detects.length;
    }
    else if (rule.severity === 2) {
...</pre></li>
    </ul>






</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.sass-lint.max_file_line_count" id="apidoc.module.sass-lint.max_file_line_count">module sass-lint.max_file_line_count</a></h1>


    <h2>
        <a href="#apidoc.element.sass-lint.max_file_line_count.detect" id="apidoc.element.sass-lint.max_file_line_count.detect">
        function <span class="apidocSignatureSpan">sass-lint.max_file_line_count.</span>detect
        <span class="apidocSignatureSpan">(ast, parser)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">detect = function (ast, parser) {
  var result = [];

  if (ast.end.line &gt; parser.options.length) {
    result = helpers.addUnique(result, {
      'ruleId': parser.rule.name,
      'line': ast.end.line,
      'column': 0,
      'message': 'This file has ' + ast.end.line + ' lines, which exceeds the maximum of ' + parser.options.length + ' lines allowed
.',
      'severity': parser.severity
    });
  }

  return result;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  }

  if (ast.content &amp;&amp; ast.content.length &gt; 0) {
ruleToggles = getToggledRules(ast);
isEnabledFilter = isResultEnabled(ruleToggles);

rules.forEach(function (rule) {
  detects = rule.rule.<span class="apidocCodeKeywordSpan">detect</span>(ast, rule)
    .filter(isEnabledFilter);
  results = results.concat(detects);
  if (detects.length) {
    if (rule.severity === 1) {
      warnings += detects.length;
    }
    else if (rule.severity === 2) {
...</pre></li>
    </ul>






</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.sass-lint.max_line_length" id="apidoc.module.sass-lint.max_line_length">module sass-lint.max_line_length</a></h1>


    <h2>
        <a href="#apidoc.element.sass-lint.max_line_length.detect" id="apidoc.element.sass-lint.max_line_length.detect">
        function <span class="apidocSignatureSpan">sass-lint.max_line_length.</span>detect
        <span class="apidocSignatureSpan">(ast, parser)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">detect = function (ast, parser) {
  var result = [];

  ast.traverseByType('space', function (space) {
    var lineLength = 0;
    if (helpers.hasEOL(space.content)) {
      lineLength = space.start.column - 1;
    }

    if (lineLength &gt; parser.options.length) {
      result = helpers.addUnique(result, {
        'ruleId': parser.rule.name,
        'severity': parser.severity,
        'line': space.start.line,
        'column': 0,
        'message': 'line ' + space.start.line + ' exceeds the maximum line length of ' + parser.options.length
      });
    }
  });

  return result;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  }

  if (ast.content &amp;&amp; ast.content.length &gt; 0) {
ruleToggles = getToggledRules(ast);
isEnabledFilter = isResultEnabled(ruleToggles);

rules.forEach(function (rule) {
  detects = rule.rule.<span class="apidocCodeKeywordSpan">detect</span>(ast, rule)
    .filter(isEnabledFilter);
  results = results.concat(detects);
  if (detects.length) {
    if (rule.severity === 1) {
      warnings += detects.length;
    }
    else if (rule.severity === 2) {
...</pre></li>
    </ul>






</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.sass-lint.mixin_name_format" id="apidoc.module.sass-lint.mixin_name_format">module sass-lint.mixin_name_format</a></h1>


    <h2>
        <a href="#apidoc.element.sass-lint.mixin_name_format.detect" id="apidoc.element.sass-lint.mixin_name_format.detect">
        function <span class="apidocSignatureSpan">sass-lint.mixin_name_format.</span>detect
        <span class="apidocSignatureSpan">(ast, parser)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">detect = function (ast, parser) {
  var result = [];

  ast.traverseByTypes(['mixin', 'include'], function (node) {
    var name,
        strippedName,
        violationMessage = false;

    if (node.is('mixin')) {
      if (node.contains('ident')) {
        name = node.first('ident').content;
      }
    }
    else {
      // We're not linting extends here
      if (node.contains('atkeyword')) {
        if (node.first('atkeyword').contains('ident')) {
          if (node.first('atkeyword').first('ident').content === 'extend') {
            return false;
          }
        }
      }

      if (node.contains('ident')) {
        name = node.first('ident').content;
      }
    }

    if (name) {
      strippedName = name;

      if (parser.options['allow-leading-underscore'] &amp;&amp; name[0] === '_') {
        strippedName = name.slice(1);
      }

      switch (parser.options.convention) {
      case 'hyphenatedlowercase':
        if (!helpers.isHyphenatedLowercase(strippedName)) {
          violationMessage = 'Mixin \'' + name + '\' should be written in lowercase with hyphens';
        }
        break;
      case 'camelcase':
        if (!helpers.isCamelCase(strippedName)) {
          violationMessage = 'Mixin \'' + name + '\' should be written in camelCase';
        }
        break;
      case 'pascalcase':
        if (!helpers.isPascalCase(strippedName)) {
          violationMessage = 'Mixin \'' + name + '\' should be written in PascalCase';
        }
        break;
      case 'snakecase':
        if (!helpers.isSnakeCase(strippedName)) {
          violationMessage = 'Mixin \'' + name + '\' should be written in snake_case';
        }
        break;
      case 'strictbem':
        if (!helpers.isStrictBEM(strippedName)) {
          violationMessage = 'Mixin \'' + name + '\' should be written in BEM (Block Element Modifier) format';
        }
        break;
      case 'hyphenatedbem':
        if (!helpers.isHyphenatedBEM(strippedName)) {
          violationMessage = 'Mixin \'' + name + '\' should be written in hyphenated BEM (Block Element Modifier) format';
        }
        break;
      default:
        if (!(new RegExp(parser.options.convention).test(strippedName))) {
          violationMessage = 'Mixin \'' + name + '\' should match regular expression /' + parser.options.convention + '/';

          // convention-message overrides violationMessage
          if (parser.options['convention-explanation']) {
            violationMessage = parser.options['convention-explanation'];
          }
        }
      }

      if (violationMessage) {
        result = helpers.addUnique(result, {
          'ruleId': parser.rule.name,
          'line': node.start.line,
          'column': node.start.column,
          'message': violationMessage,
          'severity': parser.severity
        });
      }
    }
    return true;
  });

  return result;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  }

  if (ast.content &amp;&amp; ast.content.length &gt; 0) {
ruleToggles = getToggledRules(ast);
isEnabledFilter = isResultEnabled(ruleToggles);

rules.forEach(function (rule) {
  detects = rule.rule.<span class="apidocCodeKeywordSpan">detect</span>(ast, rule)
    .filter(isEnabledFilter);
  results = results.concat(detects);
  if (detects.length) {
    if (rule.severity === 1) {
      warnings += detects.length;
    }
    else if (rule.severity === 2) {
...</pre></li>
    </ul>






</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.sass-lint.mixins_before_declarations" id="apidoc.module.sass-lint.mixins_before_declarations">module sass-lint.mixins_before_declarations</a></h1>


    <h2>
        <a href="#apidoc.element.sass-lint.mixins_before_declarations.detect" id="apidoc.element.sass-lint.mixins_before_declarations.detect">
        function <span class="apidocSignatureSpan">sass-lint.mixins_before_declarations.</span>detect
        <span class="apidocSignatureSpan">(ast, parser)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">detect = function (ast, parser) {
  var result = [],
      error;

  ast.traverseByType('include', function (node, i, parent) {
    var depth = 0,
        declarationCount = [depth];

    parent.forEach(function (item) {
      if (item.is('ruleset')) {
        depth++;
        declarationCount[depth] = 0;
      }
      else if (item.is('declaration')) {
        if (item.first().is('property')) {
          var prop = item.first();

          if (prop.first().is('ident')) {
            declarationCount[depth]++;
          }
        }
      }
      else if (item.is('include')) {
        item.forEach('ident', function (name) {
          if (parser.options.exclude.indexOf(name.content) === -1 &amp;&amp; declarationCount[depth] &gt; 0) {
            error = {
              'ruleId': parser.rule.name,
              'line': item.start.line,
              'column': item.start.column,
              'message': 'Mixins should come before declarations',
              'severity': parser.severity
            };
            result = helpers.addUnique(result, error);
          }
        });
      }
    });
  });
  return result;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  }

  if (ast.content &amp;&amp; ast.content.length &gt; 0) {
ruleToggles = getToggledRules(ast);
isEnabledFilter = isResultEnabled(ruleToggles);

rules.forEach(function (rule) {
  detects = rule.rule.<span class="apidocCodeKeywordSpan">detect</span>(ast, rule)
    .filter(isEnabledFilter);
  results = results.concat(detects);
  if (detects.length) {
    if (rule.severity === 1) {
      warnings += detects.length;
    }
    else if (rule.severity === 2) {
...</pre></li>
    </ul>






</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.sass-lint.nesting_depth" id="apidoc.module.sass-lint.nesting_depth">module sass-lint.nesting_depth</a></h1>


    <h2>
        <a href="#apidoc.element.sass-lint.nesting_depth.detect" id="apidoc.element.sass-lint.nesting_depth.detect">
        function <span class="apidocSignatureSpan">sass-lint.nesting_depth.</span>detect
        <span class="apidocSignatureSpan">(ast, parser)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">detect = function (ast, parser) {
  var result = [],
      nodes = {},
      depth = 0;

  var recursiveSearch = function (node) {
    if (node.contains('block')) {
      node.forEach('block', function (block) {
        if (block.contains('ruleset')) {
          depth++;
          block.forEach('ruleset', function (ruleset) {
            var selector = ruleset.first('selector');

            if (depth &gt; parser.options['max-depth']) {
              var nodeLineColumn = selector.start.line + ':' + selector.start.column;

              if (nodes[nodeLineColumn]) {
                if (depth &gt; nodes[nodeLineColumn].depth) {
                  nodes[nodeLineColumn].depth = depth;
                }
              }
              else {
                nodes[nodeLineColumn] = {
                  'line': selector.start.line,
                  'column': selector.start.column,
                  'depth': depth
                };
              }
            }
            else {
              recursiveSearch(ruleset);
            }
          });
        }
      });
    }
    depth--;
  };

  ast.traverseByType('selector', function (selector, i, parent) {
    recursiveSearch(parent);
    depth = 0;
  });

  Object.keys(nodes).forEach(function (node) {
    node = nodes[node];
    result = helpers.addUnique(result, {
      'ruleId': parser.rule.name,
      'line': node.line,
      'column': node.column,
      'message': 'Nesting depth ' + node.depth + ' greater than max of ' + parser.options['max-depth'],
      'severity': parser.severity
    });
  });


  return result;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  }

  if (ast.content &amp;&amp; ast.content.length &gt; 0) {
ruleToggles = getToggledRules(ast);
isEnabledFilter = isResultEnabled(ruleToggles);

rules.forEach(function (rule) {
  detects = rule.rule.<span class="apidocCodeKeywordSpan">detect</span>(ast, rule)
    .filter(isEnabledFilter);
  results = results.concat(detects);
  if (detects.length) {
    if (rule.severity === 1) {
      warnings += detects.length;
    }
    else if (rule.severity === 2) {
...</pre></li>
    </ul>






</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.sass-lint.no_attribute_selectors" id="apidoc.module.sass-lint.no_attribute_selectors">module sass-lint.no_attribute_selectors</a></h1>


    <h2>
        <a href="#apidoc.element.sass-lint.no_attribute_selectors.detect" id="apidoc.element.sass-lint.no_attribute_selectors.detect">
        function <span class="apidocSignatureSpan">sass-lint.no_attribute_selectors.</span>detect
        <span class="apidocSignatureSpan">(ast, parser)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">detect = function (ast, parser) {
  var result = [];

  ast.traverseByType('attributeSelector', function (item) {
    result = helpers.addUnique(result, {
      'ruleId': parser.rule.name,
      'line': item.start.line,
      'column': item.start.column,
      'message': 'Attribute selectors are not allowed',
      'severity': parser.severity
    });
  });

  return result;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  }

  if (ast.content &amp;&amp; ast.content.length &gt; 0) {
ruleToggles = getToggledRules(ast);
isEnabledFilter = isResultEnabled(ruleToggles);

rules.forEach(function (rule) {
  detects = rule.rule.<span class="apidocCodeKeywordSpan">detect</span>(ast, rule)
    .filter(isEnabledFilter);
  results = results.concat(detects);
  if (detects.length) {
    if (rule.severity === 1) {
      warnings += detects.length;
    }
    else if (rule.severity === 2) {
...</pre></li>
    </ul>






</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.sass-lint.no_color_hex" id="apidoc.module.sass-lint.no_color_hex">module sass-lint.no_color_hex</a></h1>


    <h2>
        <a href="#apidoc.element.sass-lint.no_color_hex.detect" id="apidoc.element.sass-lint.no_color_hex.detect">
        function <span class="apidocSignatureSpan">sass-lint.no_color_hex.</span>detect
        <span class="apidocSignatureSpan">(ast, parser)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">detect = function (ast, parser) {
  var result = [];

  ast.traverseByType('color', function (value) {
    result = helpers.addUnique(result, {
      'ruleId': parser.rule.name,
      'line': value.start.line,
      'column': value.start.column,
      'message': 'Hexadecimal colors should not be used',
      'severity': parser.severity
    });
  });
  return result;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  }

  if (ast.content &amp;&amp; ast.content.length &gt; 0) {
ruleToggles = getToggledRules(ast);
isEnabledFilter = isResultEnabled(ruleToggles);

rules.forEach(function (rule) {
  detects = rule.rule.<span class="apidocCodeKeywordSpan">detect</span>(ast, rule)
    .filter(isEnabledFilter);
  results = results.concat(detects);
  if (detects.length) {
    if (rule.severity === 1) {
      warnings += detects.length;
    }
    else if (rule.severity === 2) {
...</pre></li>
    </ul>






</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.sass-lint.no_color_keywords" id="apidoc.module.sass-lint.no_color_keywords">module sass-lint.no_color_keywords</a></h1>


    <h2>
        <a href="#apidoc.element.sass-lint.no_color_keywords.detect" id="apidoc.element.sass-lint.no_color_keywords.detect">
        function <span class="apidocSignatureSpan">sass-lint.no_color_keywords.</span>detect
        <span class="apidocSignatureSpan">(ast, parser)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">detect = function (ast, parser) {
  var result = [];

  ast.traverseByType('value', function (node) {
    node.traverse(function (elem, i, parent) {
      if (elem.type === 'ident' &amp;&amp; !checkValidParentType(parent)) {
        var index = cssColors.indexOf(elem.content.toLowerCase());

        if (index !== -1) {
          result = helpers.addUnique(result, {
            'ruleId': parser.rule.name,
            'line': elem.start.line,
            'column': elem.start.column,
            'message': 'Color \'' + elem.content + '\' should be written in its hexadecimal form #' + cssColors[index + 1],
            'severity': parser.severity
          });
        }
      }
    });

  });
  return result;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  }

  if (ast.content &amp;&amp; ast.content.length &gt; 0) {
ruleToggles = getToggledRules(ast);
isEnabledFilter = isResultEnabled(ruleToggles);

rules.forEach(function (rule) {
  detects = rule.rule.<span class="apidocCodeKeywordSpan">detect</span>(ast, rule)
    .filter(isEnabledFilter);
  results = results.concat(detects);
  if (detects.length) {
    if (rule.severity === 1) {
      warnings += detects.length;
    }
    else if (rule.severity === 2) {
...</pre></li>
    </ul>






</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.sass-lint.no_color_literals" id="apidoc.module.sass-lint.no_color_literals">module sass-lint.no_color_literals</a></h1>


    <h2>
        <a href="#apidoc.element.sass-lint.no_color_literals.detect" id="apidoc.element.sass-lint.no_color_literals.detect">
        function <span class="apidocSignatureSpan">sass-lint.no_color_literals.</span>detect
        <span class="apidocSignatureSpan">(ast, parser)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">detect = function (ast, parser) {
  var result = [],
      validColorFunctions = getColorFunctionsCopy(colorFunctions);

  if (parser.options['allow-rgba'] &amp;&amp; validColorFunctions.indexOf('rgba') !== -1) {
    validColorFunctions.splice(validColorFunctions.indexOf('rgba'), 1);
  }

  ast.traverseByTypes(['value', 'variable'], function (node, i, parent) {

    // If we don't literals as variable names then check each variable name
    if (node.is('variable') &amp;&amp; !parser.options['allow-variable-identifiers']) {
      if (cssColors.indexOf(node.content[0].content) !== -1) {
        result = helpers.addUnique(result, {
          'ruleId': parser.rule.name,
          'line': node.start.line,
          'column': node.start.column,
          'message': 'Color literals should not be used as variable names',
          'severity': parser.severity
        });
      }
    }
    // check the value nodes
    else if (node.is('value')) {
      node.forEach(function (valElem) {
        var declarationType = parent.content[0].content[0].type;
        // check type is color, content isn't a css color literal
        if (valElem.type === 'color' || cssColors.indexOf(valElem.content) !== -1) {
          if (declarationType === 'ident') {
            result = helpers.addUnique(result, {
              'ruleId': parser.rule.name,
              'line': valElem.start.line,
              'column': valElem.start.column,
              'message': 'Color literals such as \'' + checkHexPrefix(valElem.type) + valElem.content + '\' should only be used
in variable declarations',
              'severity': parser.severity
            });
          }
        }

        // if not a color value or a variable then check if it's a function
        else if (valElem.type === 'function') {
          var funcType = valElem.content[0].content;

          // check it's not a blacklisted color function and even if it is that it's not assigned to a variable
          if (validColorFunctions.indexOf(funcType) !== -1 &amp;&amp; declarationType !== 'variable') {
            result = helpers.addUnique(result, {
              'ruleId': parser.rule.name,
              'line': valElem.start.line,
              'column': valElem.start.column,
              'message': 'Color functions such as \'' + funcType + '\' should only be used in variable declarations',
              'severity': parser.severity
            });
          }

          // if rgba usage is allowed we need to make sure only variables are being passed to it.
          else if (
            parser.options['allow-rgba'] &amp;&amp;
            funcType === 'rgba' &amp;&amp;
            valElem.content[1].content[0].type !== 'variable' &amp;&amp;
            declarationType !== 'variable'
          ) {
            result = helpers.addUnique(result, {
              'ruleId': parser.rule.name,
              'line': valElem.start.line,
              'column': valElem.start.column,
              'message': 'A color in variable form must be passed to rgba, literals are restricted',
              'severity': parser.severity
            });
          }

          // if a non color function we should check its arguments
          else {
            valElem.content.forEach( function (funcContent) {
              if (funcContent.type === 'arguments') {
                funcContent.forEach(function (funcArgs) {
                  // if the arguments are not functions themselves
                  if (funcArgs.type !== 'function') {
                    // check if the argument types are therefore color literals
                    if ((funcArgs.type === 'color' || funcArgs.type === 'ident') &amp;&amp; (cssColors.indexOf(funcArgs.content) !== -1 ||
helpers.isValidHex(funcArgs.content))) {
                      result = helpers.addUnique(result, {
                        'ruleId': parser.rule.name,
                        'line': funcArgs.start.line,
                        'column': funcArgs.start.column,
                        'message': 'Color literals such as \'' + checkHexPrefix(funcArgs.type) + funcArgs.content + '\' should not
 be passed to functions, use variables', ...</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  }

  if (ast.content &amp;&amp; ast.content.length &gt; 0) {
ruleToggles = getToggledRules(ast);
isEnabledFilter = isResultEnabled(ruleToggles);

rules.forEach(function (rule) {
  detects = rule.rule.<span class="apidocCodeKeywordSpan">detect</span>(ast, rule)
    .filter(isEnabledFilter);
  results = results.concat(detects);
  if (detects.length) {
    if (rule.severity === 1) {
      warnings += detects.length;
    }
    else if (rule.severity === 2) {
...</pre></li>
    </ul>






</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.sass-lint.no_combinators" id="apidoc.module.sass-lint.no_combinators">module sass-lint.no_combinators</a></h1>


    <h2>
        <a href="#apidoc.element.sass-lint.no_combinators.detect" id="apidoc.element.sass-lint.no_combinators.detect">
        function <span class="apidocSignatureSpan">sass-lint.no_combinators.</span>detect
        <span class="apidocSignatureSpan">(ast, parser)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">detect = function (ast, parser) {
  var result = [];

  ast.traverseByType('selector', function (selector) {
    selector.forEach(function (item, i) {
      var previous = selector.content[i - 1] || false,
          next = selector.content[i + 1] || false;

      if (isException(item, next, previous)) {
        return false;
      }

      if (item.is('combinator') || item.is('space')) {
        result = helpers.addUnique(result, {
          'ruleId': parser.rule.name,
          'line': item.start.line,
          'column': item.start.column,
          'message': 'Combinators are not allowed',
          'severity': parser.severity
        });
      }
      return false;
    });
  });

  return result;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  }

  if (ast.content &amp;&amp; ast.content.length &gt; 0) {
ruleToggles = getToggledRules(ast);
isEnabledFilter = isResultEnabled(ruleToggles);

rules.forEach(function (rule) {
  detects = rule.rule.<span class="apidocCodeKeywordSpan">detect</span>(ast, rule)
    .filter(isEnabledFilter);
  results = results.concat(detects);
  if (detects.length) {
    if (rule.severity === 1) {
      warnings += detects.length;
    }
    else if (rule.severity === 2) {
...</pre></li>
    </ul>






</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.sass-lint.no_css_comments" id="apidoc.module.sass-lint.no_css_comments">module sass-lint.no_css_comments</a></h1>


    <h2>
        <a href="#apidoc.element.sass-lint.no_css_comments.detect" id="apidoc.element.sass-lint.no_css_comments.detect">
        function <span class="apidocSignatureSpan">sass-lint.no_css_comments.</span>detect
        <span class="apidocSignatureSpan">(ast, parser)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">detect = function (ast, parser) {
  var result = [];

  ast.traverseByType('multilineComment', function (node) {
    if (node.content.charAt(0) !== '!') {
      result = helpers.addUnique(result, {
        'ruleId': parser.rule.name,
        'line': node.start.line,
        'column': node.start.column,
        'message': 'Multiline style comments should not be used',
        'severity': parser.severity
      });
    }
  });
  return result;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  }

  if (ast.content &amp;&amp; ast.content.length &gt; 0) {
ruleToggles = getToggledRules(ast);
isEnabledFilter = isResultEnabled(ruleToggles);

rules.forEach(function (rule) {
  detects = rule.rule.<span class="apidocCodeKeywordSpan">detect</span>(ast, rule)
    .filter(isEnabledFilter);
  results = results.concat(detects);
  if (detects.length) {
    if (rule.severity === 1) {
      warnings += detects.length;
    }
    else if (rule.severity === 2) {
...</pre></li>
    </ul>






</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.sass-lint.no_debug" id="apidoc.module.sass-lint.no_debug">module sass-lint.no_debug</a></h1>


    <h2>
        <a href="#apidoc.element.sass-lint.no_debug.detect" id="apidoc.element.sass-lint.no_debug.detect">
        function <span class="apidocSignatureSpan">sass-lint.no_debug.</span>detect
        <span class="apidocSignatureSpan">(ast, parser)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">detect = function (ast, parser) {
  var result = [];

  ast.traverseByType('atkeyword', function (keyword) {
    keyword.traverse(function (item) {
      if (item.content === 'debug') {
        result = helpers.addUnique(result, {
          'ruleId': parser.rule.name,
          'line': item.start.line,
          'column': item.start.column,
          'message': '@debug not allowed',
          'severity': parser.severity
        });
      }
    });
  });

  return result;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  }

  if (ast.content &amp;&amp; ast.content.length &gt; 0) {
ruleToggles = getToggledRules(ast);
isEnabledFilter = isResultEnabled(ruleToggles);

rules.forEach(function (rule) {
  detects = rule.rule.<span class="apidocCodeKeywordSpan">detect</span>(ast, rule)
    .filter(isEnabledFilter);
  results = results.concat(detects);
  if (detects.length) {
    if (rule.severity === 1) {
      warnings += detects.length;
    }
    else if (rule.severity === 2) {
...</pre></li>
    </ul>






</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.sass-lint.no_disallowed_properties" id="apidoc.module.sass-lint.no_disallowed_properties">module sass-lint.no_disallowed_properties</a></h1>


    <h2>
        <a href="#apidoc.element.sass-lint.no_disallowed_properties.detect" id="apidoc.element.sass-lint.no_disallowed_properties.detect">
        function <span class="apidocSignatureSpan">sass-lint.no_disallowed_properties.</span>detect
        <span class="apidocSignatureSpan">(ast, parser)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">detect = function (ast, parser) {
  var result = [];

  ast.traverseByType('property', function (node) {
    var first = node.first();
    if (!first.is('ident') || parser.options.properties.indexOf(first.content) === -1) {
      return;
    }
    result = helpers.addUnique(result, {
      'ruleId': parser.rule.name,
      'line': node.start.line,
      'column': node.start.column,
      'message': 'Property `' + first.content + '` should not be used',
      'severity': parser.severity
    });
  });
  return result;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  }

  if (ast.content &amp;&amp; ast.content.length &gt; 0) {
ruleToggles = getToggledRules(ast);
isEnabledFilter = isResultEnabled(ruleToggles);

rules.forEach(function (rule) {
  detects = rule.rule.<span class="apidocCodeKeywordSpan">detect</span>(ast, rule)
    .filter(isEnabledFilter);
  results = results.concat(detects);
  if (detects.length) {
    if (rule.severity === 1) {
      warnings += detects.length;
    }
    else if (rule.severity === 2) {
...</pre></li>
    </ul>






</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.sass-lint.no_duplicate_properties" id="apidoc.module.sass-lint.no_duplicate_properties">module sass-lint.no_duplicate_properties</a></h1>


    <h2>
        <a href="#apidoc.element.sass-lint.no_duplicate_properties.detect" id="apidoc.element.sass-lint.no_duplicate_properties.detect">
        function <span class="apidocSignatureSpan">sass-lint.no_duplicate_properties.</span>detect
        <span class="apidocSignatureSpan">(ast, parser)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">detect = function (ast, parser) {
  var result = [];

  ast.traverseByType('block', function (block) {
    var properties = [],
        items = [],
        warnMessage = false;

    block.eachFor('declaration', function (declaration) {
      items.push(declaration);
    });

    items.reverse();

    items.forEach(function (declaration) {
      warnMessage = false;

      declaration.eachFor('property', function (item) {
        var property = '';

        // Check if declaration is actually a variable declaration
        if (item.content[0] &amp;&amp; item.content[0].is('variable')) {
          return;
        }

        item.forEach(function (subItem) {
          // Although not a selector the method here helps us construct the proper property name
          // taking into account any interpolation etc
          property += selectorHelpers.constructSelector(subItem);
        });

        if (properties.indexOf(property) !== -1 &amp;&amp; properties.length &gt;= 1) {
          if (parser.options.exclude.indexOf(property) !== -1 &amp;&amp; properties[properties.length - 1] !== property) {
            warnMessage = 'Excluded duplicate properties must directly follow each other.';
          }
          else if (parser.options.exclude.indexOf(property) === -1) {
            warnMessage = 'Duplicate properties are not allowed within a block';
          }
        }

        properties.push(property);

        if (warnMessage) {
          result = helpers.addUnique(result, {
            'ruleId': parser.rule.name,
            'line': item.start.line,
            'column': item.start.column,
            'message': warnMessage,
            'severity': parser.severity
          });
        }
      });
    });
  });

  return result;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  }

  if (ast.content &amp;&amp; ast.content.length &gt; 0) {
ruleToggles = getToggledRules(ast);
isEnabledFilter = isResultEnabled(ruleToggles);

rules.forEach(function (rule) {
  detects = rule.rule.<span class="apidocCodeKeywordSpan">detect</span>(ast, rule)
    .filter(isEnabledFilter);
  results = results.concat(detects);
  if (detects.length) {
    if (rule.severity === 1) {
      warnings += detects.length;
    }
    else if (rule.severity === 2) {
...</pre></li>
    </ul>






</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.sass-lint.no_empty_rulesets" id="apidoc.module.sass-lint.no_empty_rulesets">module sass-lint.no_empty_rulesets</a></h1>


    <h2>
        <a href="#apidoc.element.sass-lint.no_empty_rulesets.detect" id="apidoc.element.sass-lint.no_empty_rulesets.detect">
        function <span class="apidocSignatureSpan">sass-lint.no_empty_rulesets.</span>detect
        <span class="apidocSignatureSpan">(ast, parser)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">detect = function (ast, parser) {
  var result = [];

  ast.traverseByType('block', function (block) {
    var nonSpaceCount = 0,
        empty = false;

    if (block.content.length === 0) {
      empty = true;
    }
    else {
      block.traverse(function (item) {
        if (!helpers.isEqual(block, item)) {
          if (item.type !== 'space') {
            nonSpaceCount++;
          }
        }
      });
      if (nonSpaceCount === 0) {
        empty = true;
      }
    }

    if (empty) {
      result = helpers.addUnique(result, {
        'ruleId': parser.rule.name,
        'severity': parser.severity,
        'line': block.start.line,
        'column': block.start.column,
        'message': 'No empty blocks allowed'
      });
    }
  });


  return result;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  }

  if (ast.content &amp;&amp; ast.content.length &gt; 0) {
ruleToggles = getToggledRules(ast);
isEnabledFilter = isResultEnabled(ruleToggles);

rules.forEach(function (rule) {
  detects = rule.rule.<span class="apidocCodeKeywordSpan">detect</span>(ast, rule)
    .filter(isEnabledFilter);
  results = results.concat(detects);
  if (detects.length) {
    if (rule.severity === 1) {
      warnings += detects.length;
    }
    else if (rule.severity === 2) {
...</pre></li>
    </ul>






</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.sass-lint.no_extends" id="apidoc.module.sass-lint.no_extends">module sass-lint.no_extends</a></h1>


    <h2>
        <a href="#apidoc.element.sass-lint.no_extends.detect" id="apidoc.element.sass-lint.no_extends.detect">
        function <span class="apidocSignatureSpan">sass-lint.no_extends.</span>detect
        <span class="apidocSignatureSpan">(ast, parser)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">detect = function (ast, parser) {
  var result = [];

  ast.traverseByType('atkeyword', function (keyword) {
    keyword.traverse(function (item) {
      if (item.content === 'extend') {
        result = helpers.addUnique(result, {
          'ruleId': parser.rule.name,
          'line': item.start.line,
          'column': item.start.column,
          'message': '@extend not allowed',
          'severity': parser.severity
        });
      }
    });
  });

  return result;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  }

  if (ast.content &amp;&amp; ast.content.length &gt; 0) {
ruleToggles = getToggledRules(ast);
isEnabledFilter = isResultEnabled(ruleToggles);

rules.forEach(function (rule) {
  detects = rule.rule.<span class="apidocCodeKeywordSpan">detect</span>(ast, rule)
    .filter(isEnabledFilter);
  results = results.concat(detects);
  if (detects.length) {
    if (rule.severity === 1) {
      warnings += detects.length;
    }
    else if (rule.severity === 2) {
...</pre></li>
    </ul>






</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.sass-lint.no_ids" id="apidoc.module.sass-lint.no_ids">module sass-lint.no_ids</a></h1>


    <h2>
        <a href="#apidoc.element.sass-lint.no_ids.detect" id="apidoc.element.sass-lint.no_ids.detect">
        function <span class="apidocSignatureSpan">sass-lint.no_ids.</span>detect
        <span class="apidocSignatureSpan">(ast, parser)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">detect = function (ast, parser) {
  var result = [];

  ast.traverseByType('id', function (id) {
    result = helpers.addUnique(result, {
      'ruleId': parser.rule.name,
      'line': id.start.line,
      'column': id.start.column,
      'message': 'ID selectors not allowed',
      'severity': parser.severity
    });
  });

  return result;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  }

  if (ast.content &amp;&amp; ast.content.length &gt; 0) {
ruleToggles = getToggledRules(ast);
isEnabledFilter = isResultEnabled(ruleToggles);

rules.forEach(function (rule) {
  detects = rule.rule.<span class="apidocCodeKeywordSpan">detect</span>(ast, rule)
    .filter(isEnabledFilter);
  results = results.concat(detects);
  if (detects.length) {
    if (rule.severity === 1) {
      warnings += detects.length;
    }
    else if (rule.severity === 2) {
...</pre></li>
    </ul>






</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.sass-lint.no_important" id="apidoc.module.sass-lint.no_important">module sass-lint.no_important</a></h1>


    <h2>
        <a href="#apidoc.element.sass-lint.no_important.detect" id="apidoc.element.sass-lint.no_important.detect">
        function <span class="apidocSignatureSpan">sass-lint.no_important.</span>detect
        <span class="apidocSignatureSpan">(ast, parser)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">detect = function (ast, parser) {
  var result = [];

  ast.traverseByType('important', function (item) {
    result = helpers.addUnique(result, {
      'ruleId': parser.rule.name,
      'line': item.start.line,
      'column': item.start.column,
      'message': '!important not allowed',
      'severity': parser.severity
    });
  });

  return result;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  }

  if (ast.content &amp;&amp; ast.content.length &gt; 0) {
ruleToggles = getToggledRules(ast);
isEnabledFilter = isResultEnabled(ruleToggles);

rules.forEach(function (rule) {
  detects = rule.rule.<span class="apidocCodeKeywordSpan">detect</span>(ast, rule)
    .filter(isEnabledFilter);
  results = results.concat(detects);
  if (detects.length) {
    if (rule.severity === 1) {
      warnings += detects.length;
    }
    else if (rule.severity === 2) {
...</pre></li>
    </ul>






</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.sass-lint.no_invalid_hex" id="apidoc.module.sass-lint.no_invalid_hex">module sass-lint.no_invalid_hex</a></h1>


    <h2>
        <a href="#apidoc.element.sass-lint.no_invalid_hex.detect" id="apidoc.element.sass-lint.no_invalid_hex.detect">
        function <span class="apidocSignatureSpan">sass-lint.no_invalid_hex.</span>detect
        <span class="apidocSignatureSpan">(ast, parser)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">detect = function (ast, parser) {
  var result = [];

  ast.traverseByType('color', function (value) {
    if (!helpers.isValidHex(value.content)) {
      result = helpers.addUnique(result, {
        'ruleId': parser.rule.name,
        'line': value.start.line,
        'column': value.start.column,
        'message': 'Hexadecimal values must be a valid format',
        'severity': parser.severity
      });
    }
  });
  return result;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  }

  if (ast.content &amp;&amp; ast.content.length &gt; 0) {
ruleToggles = getToggledRules(ast);
isEnabledFilter = isResultEnabled(ruleToggles);

rules.forEach(function (rule) {
  detects = rule.rule.<span class="apidocCodeKeywordSpan">detect</span>(ast, rule)
    .filter(isEnabledFilter);
  results = results.concat(detects);
  if (detects.length) {
    if (rule.severity === 1) {
      warnings += detects.length;
    }
    else if (rule.severity === 2) {
...</pre></li>
    </ul>






</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.sass-lint.no_mergeable_selectors" id="apidoc.module.sass-lint.no_mergeable_selectors">module sass-lint.no_mergeable_selectors</a></h1>


    <h2>
        <a href="#apidoc.element.sass-lint.no_mergeable_selectors.detect" id="apidoc.element.sass-lint.no_mergeable_selectors.detect">
        function <span class="apidocSignatureSpan">sass-lint.no_mergeable_selectors.</span>detect
        <span class="apidocSignatureSpan">(ast, parser)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">detect = function (ast, parser) {
  curLevel = 0;
  curSelector = [];
  parentSelector = [];
  selectorList = [];
  syntax = ast.syntax;
  ast.traverseByType('stylesheet', function (styleSheet) {
    traverseBlock(styleSheet, traverseNode);
  });
  return checkMergeable(parser);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  }

  if (ast.content &amp;&amp; ast.content.length &gt; 0) {
ruleToggles = getToggledRules(ast);
isEnabledFilter = isResultEnabled(ruleToggles);

rules.forEach(function (rule) {
  detects = rule.rule.<span class="apidocCodeKeywordSpan">detect</span>(ast, rule)
    .filter(isEnabledFilter);
  results = results.concat(detects);
  if (detects.length) {
    if (rule.severity === 1) {
      warnings += detects.length;
    }
    else if (rule.severity === 2) {
...</pre></li>
    </ul>






</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.sass-lint.no_misspelled_properties" id="apidoc.module.sass-lint.no_misspelled_properties">module sass-lint.no_misspelled_properties</a></h1>


    <h2>
        <a href="#apidoc.element.sass-lint.no_misspelled_properties.detect" id="apidoc.element.sass-lint.no_misspelled_properties.detect">
        function <span class="apidocSignatureSpan">sass-lint.no_misspelled_properties.</span>detect
        <span class="apidocSignatureSpan">(ast, parser)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">detect = function (ast, parser) {
  var result = [];

  ast.traverseByType('property', function (node) {
    if (node.first().is('ident')) {
      var curProperty = node.first().content,
          propertyList = getCombinedList(properties, parser.options['extra-properties']);

      if (curProperty.charAt(0) === '-') {
        curProperty = helpers.stripPrefix(curProperty);
      }

      if (helpers.isPartialStringMatch(curProperty, propertyList)) {
        return false;
      }

      if (curProperty.length &gt; 0) {
        result = helpers.addUnique(result, {
          'ruleId': parser.rule.name,
          'line': node.start.line,
          'column': node.start.column,
          'message': 'Property `' + curProperty + '` appears to be spelled incorrectly',
          'severity': parser.severity
        });
      }
    }

    return false;
  });

  return result;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  }

  if (ast.content &amp;&amp; ast.content.length &gt; 0) {
ruleToggles = getToggledRules(ast);
isEnabledFilter = isResultEnabled(ruleToggles);

rules.forEach(function (rule) {
  detects = rule.rule.<span class="apidocCodeKeywordSpan">detect</span>(ast, rule)
    .filter(isEnabledFilter);
  results = results.concat(detects);
  if (detects.length) {
    if (rule.severity === 1) {
      warnings += detects.length;
    }
    else if (rule.severity === 2) {
...</pre></li>
    </ul>






</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.sass-lint.no_qualifying_elements" id="apidoc.module.sass-lint.no_qualifying_elements">module sass-lint.no_qualifying_elements</a></h1>


    <h2>
        <a href="#apidoc.element.sass-lint.no_qualifying_elements.detect" id="apidoc.element.sass-lint.no_qualifying_elements.detect">
        function <span class="apidocSignatureSpan">sass-lint.no_qualifying_elements.</span>detect
        <span class="apidocSignatureSpan">(ast, parser)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">detect = function (ast, parser) {
  var result = [];

  ast.traverseByType('selector', function (selector) {
    selector.forEach(function (item, i) {
      if (item.is('attributeSelector') || item.is('class') || item.is('id')) {
        var previous = selector.content[i - 1] || false;

        if (previous &amp;&amp; previous.is('typeSelector')) {
          if (previous.contains('ident')) {
            var type = null;

            if (item.is('attributeSelector')) {
              type = 'attribute';
            }

            if (item.is('class')) {
              type = 'class';
            }

            if (item.is('id')) {
              type = 'id';
            }

            if (type &amp;&amp; !parser.options['allow-element-with-' + type]) {
              result = helpers.addUnique(result, {
                'ruleId': parser.rule.name,
                'line': item.start.line,
                'column': item.start.column,
                'message': 'Qualifying elements are not allowed for ' + type + ' selectors',
                'severity': parser.severity
              });
            }
          }
        }
      }
    });
  });

  return result;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  }

  if (ast.content &amp;&amp; ast.content.length &gt; 0) {
ruleToggles = getToggledRules(ast);
isEnabledFilter = isResultEnabled(ruleToggles);

rules.forEach(function (rule) {
  detects = rule.rule.<span class="apidocCodeKeywordSpan">detect</span>(ast, rule)
    .filter(isEnabledFilter);
  results = results.concat(detects);
  if (detects.length) {
    if (rule.severity === 1) {
      warnings += detects.length;
    }
    else if (rule.severity === 2) {
...</pre></li>
    </ul>






</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.sass-lint.no_trailing_whitespace" id="apidoc.module.sass-lint.no_trailing_whitespace">module sass-lint.no_trailing_whitespace</a></h1>


    <h2>
        <a href="#apidoc.element.sass-lint.no_trailing_whitespace.detect" id="apidoc.element.sass-lint.no_trailing_whitespace.detect">
        function <span class="apidocSignatureSpan">sass-lint.no_trailing_whitespace.</span>detect
        <span class="apidocSignatureSpan">(ast, parser)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">detect = function (ast, parser) {
  var result = [];
  var trailing = (/( |\t)+\n/);
  var trailingCRLF = (/( |\t)+\r\n/);

  ast.traverseByType('space', function (space, i, parent) {
    var content = space.content;
    var nextIndex = i + 1;
    var next = parent.content[nextIndex];

    while (next &amp;&amp; (next.is('space') || next.is('declarationDelimiter'))) {
      content += next.content;
      nextIndex++;
      next = parent.content[nextIndex];
    }

    if (trailing.test(content) || trailingCRLF.test(content)) {
      result = helpers.addUnique(result, {
        'ruleId': parser.rule.name,
        'severity': parser.severity,
        'line': space.start.line,
        'column': space.start.column,
        'message': 'No trailing whitespace allowed'
      });
    }
  });

  return result;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  }

  if (ast.content &amp;&amp; ast.content.length &gt; 0) {
ruleToggles = getToggledRules(ast);
isEnabledFilter = isResultEnabled(ruleToggles);

rules.forEach(function (rule) {
  detects = rule.rule.<span class="apidocCodeKeywordSpan">detect</span>(ast, rule)
    .filter(isEnabledFilter);
  results = results.concat(detects);
  if (detects.length) {
    if (rule.severity === 1) {
      warnings += detects.length;
    }
    else if (rule.severity === 2) {
...</pre></li>
    </ul>






</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.sass-lint.no_trailing_zero" id="apidoc.module.sass-lint.no_trailing_zero">module sass-lint.no_trailing_zero</a></h1>


    <h2>
        <a href="#apidoc.element.sass-lint.no_trailing_zero.detect" id="apidoc.element.sass-lint.no_trailing_zero.detect">
        function <span class="apidocSignatureSpan">sass-lint.no_trailing_zero.</span>detect
        <span class="apidocSignatureSpan">(ast, parser)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">detect = function (ast, parser) {
  var result = [];

  ast.traverseByType('number', function (num) {

    if (num.content.match(trailingZeroRegex)) {
      result = helpers.addUnique(result, {
        'ruleId': parser.rule.name,
        'line': num.start.line,
        'column': num.start.column,
        'message': 'Don\'t include trailing zeros on numbers',
        'severity': parser.severity
      });
    }
  });

  return result;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  }

  if (ast.content &amp;&amp; ast.content.length &gt; 0) {
ruleToggles = getToggledRules(ast);
isEnabledFilter = isResultEnabled(ruleToggles);

rules.forEach(function (rule) {
  detects = rule.rule.<span class="apidocCodeKeywordSpan">detect</span>(ast, rule)
    .filter(isEnabledFilter);
  results = results.concat(detects);
  if (detects.length) {
    if (rule.severity === 1) {
      warnings += detects.length;
    }
    else if (rule.severity === 2) {
...</pre></li>
    </ul>






</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.sass-lint.no_transition_all" id="apidoc.module.sass-lint.no_transition_all">module sass-lint.no_transition_all</a></h1>


    <h2>
        <a href="#apidoc.element.sass-lint.no_transition_all.detect" id="apidoc.element.sass-lint.no_transition_all.detect">
        function <span class="apidocSignatureSpan">sass-lint.no_transition_all.</span>detect
        <span class="apidocSignatureSpan">(ast, parser)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">detect = function (ast, parser) {
  var result = [];

  ast.traverseByType('declaration', function (declaration) {

    if (declaration.first('property')) {
      if (declaration.first('property').first('ident')) {
        var propertyName = declaration.first('property').first('ident').content;

        if (propertyName.charAt(0) === '-') {
          propertyName = helpers.stripPrefix(propertyName);
        }

        if (propertyName === 'transition' || propertyName === 'transition-property' ) {
          declaration.forEach('value', function (val) {
            val.forEach('ident', function (ident) {
              if (ident.content === 'all') {
                result = helpers.addUnique(result, {
                  'ruleId': parser.rule.name,
                  'line': declaration.start.line,
                  'column': declaration.start.column,
                  'message': 'The keyword `all` should not be used with the property `' + propertyName + '`',
                  'severity': parser.severity
                });
              }
            });
          });
        }
      }
    }
  });
  return result;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  }

  if (ast.content &amp;&amp; ast.content.length &gt; 0) {
ruleToggles = getToggledRules(ast);
isEnabledFilter = isResultEnabled(ruleToggles);

rules.forEach(function (rule) {
  detects = rule.rule.<span class="apidocCodeKeywordSpan">detect</span>(ast, rule)
    .filter(isEnabledFilter);
  results = results.concat(detects);
  if (detects.length) {
    if (rule.severity === 1) {
      warnings += detects.length;
    }
    else if (rule.severity === 2) {
...</pre></li>
    </ul>






</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.sass-lint.no_universal_selectors" id="apidoc.module.sass-lint.no_universal_selectors">module sass-lint.no_universal_selectors</a></h1>


    <h2>
        <a href="#apidoc.element.sass-lint.no_universal_selectors.detect" id="apidoc.element.sass-lint.no_universal_selectors.detect">
        function <span class="apidocSignatureSpan">sass-lint.no_universal_selectors.</span>detect
        <span class="apidocSignatureSpan">(ast, parser)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">detect = function (ast, parser) {
  var result = [];

  ast.traverseByType('typeSelector', function (typeSelector) {
    typeSelector.traverse(function (item) {
      if (item.is('ident') &amp;&amp; item.content === '*') {
        result = helpers.addUnique(result, {
          'ruleId': parser.rule.name,
          'line': item.start.line,
          'column': item.start.column,
          'message': '* (universal) selectors are not allowed',
          'severity': parser.severity
        });
      }
    });
  });

  return result;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  }

  if (ast.content &amp;&amp; ast.content.length &gt; 0) {
ruleToggles = getToggledRules(ast);
isEnabledFilter = isResultEnabled(ruleToggles);

rules.forEach(function (rule) {
  detects = rule.rule.<span class="apidocCodeKeywordSpan">detect</span>(ast, rule)
    .filter(isEnabledFilter);
  results = results.concat(detects);
  if (detects.length) {
    if (rule.severity === 1) {
      warnings += detects.length;
    }
    else if (rule.severity === 2) {
...</pre></li>
    </ul>






</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.sass-lint.no_url_domains" id="apidoc.module.sass-lint.no_url_domains">module sass-lint.no_url_domains</a></h1>


    <h2>
        <a href="#apidoc.element.sass-lint.no_url_domains.detect" id="apidoc.element.sass-lint.no_url_domains.detect">
        function <span class="apidocSignatureSpan">sass-lint.no_url_domains.</span>detect
        <span class="apidocSignatureSpan">(ast, parser)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">detect = function (ast, parser) {
  var result = [];

  ast.traverseByType('uri', function (uri) {
    uri.traverse(function (item) {
      if (item.is('string')) {
        var stripped = helpers.stripQuotes(item.content),
            parsedUrl = url.parse(stripped, false, true);

        if (parsedUrl.host &amp;&amp; parsedUrl.protocol !== 'data:') {
          result = helpers.addUnique(result, {
            'ruleId': parser.rule.name,
            'severity': parser.severity,
            'line': item.end.line,
            'column': item.end.column,
            'message': 'Domains in URLs are disallowed'
          });
        }
      }
    });
  });

  return result;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  }

  if (ast.content &amp;&amp; ast.content.length &gt; 0) {
ruleToggles = getToggledRules(ast);
isEnabledFilter = isResultEnabled(ruleToggles);

rules.forEach(function (rule) {
  detects = rule.rule.<span class="apidocCodeKeywordSpan">detect</span>(ast, rule)
    .filter(isEnabledFilter);
  results = results.concat(detects);
  if (detects.length) {
    if (rule.severity === 1) {
      warnings += detects.length;
    }
    else if (rule.severity === 2) {
...</pre></li>
    </ul>






</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.sass-lint.no_url_protocols" id="apidoc.module.sass-lint.no_url_protocols">module sass-lint.no_url_protocols</a></h1>


    <h2>
        <a href="#apidoc.element.sass-lint.no_url_protocols.detect" id="apidoc.element.sass-lint.no_url_protocols.detect">
        function <span class="apidocSignatureSpan">sass-lint.no_url_protocols.</span>detect
        <span class="apidocSignatureSpan">(ast, parser)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">detect = function (ast, parser) {
  var result = [];

  ast.traverseByType('uri', function (uri) {
    uri.traverse(function (item) {
      if (item.is('string')) {
        var stripped = helpers.stripQuotes(item.content),
            regexSelector = !parser.options['allow-protocol-relative-urls'] ?
                isUrlRegex : protocolRelativeRegex,
            message = !parser.options['allow-protocol-relative-urls'] ?
                'Protocols and domains in URLs are disallowed' :
                'Protocols in URLS are disallowed';

        if (stripped.match(regexSelector)) {
          result = helpers.addUnique(result, {
            'ruleId': parser.rule.name,
            'severity': parser.severity,
            'line': item.end.line,
            'column': item.end.column,
            'message': message
          });
        }
      }
    });
  });

  return result;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  }

  if (ast.content &amp;&amp; ast.content.length &gt; 0) {
ruleToggles = getToggledRules(ast);
isEnabledFilter = isResultEnabled(ruleToggles);

rules.forEach(function (rule) {
  detects = rule.rule.<span class="apidocCodeKeywordSpan">detect</span>(ast, rule)
    .filter(isEnabledFilter);
  results = results.concat(detects);
  if (detects.length) {
    if (rule.severity === 1) {
      warnings += detects.length;
    }
    else if (rule.severity === 2) {
...</pre></li>
    </ul>






</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.sass-lint.no_warn" id="apidoc.module.sass-lint.no_warn">module sass-lint.no_warn</a></h1>


    <h2>
        <a href="#apidoc.element.sass-lint.no_warn.detect" id="apidoc.element.sass-lint.no_warn.detect">
        function <span class="apidocSignatureSpan">sass-lint.no_warn.</span>detect
        <span class="apidocSignatureSpan">(ast, parser)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">detect = function (ast, parser) {
  var result = [];

  ast.traverseByType('atkeyword', function (keyword) {
    keyword.traverse(function (item) {
      if (item.content === 'warn') {
        result = helpers.addUnique(result, {
          'ruleId': parser.rule.name,
          'line': item.start.line,
          'column': item.start.column,
          'message': '@warn not allowed',
          'severity': parser.severity
        });
      }
    });
  });

  return result;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  }

  if (ast.content &amp;&amp; ast.content.length &gt; 0) {
ruleToggles = getToggledRules(ast);
isEnabledFilter = isResultEnabled(ruleToggles);

rules.forEach(function (rule) {
  detects = rule.rule.<span class="apidocCodeKeywordSpan">detect</span>(ast, rule)
    .filter(isEnabledFilter);
  results = results.concat(detects);
  if (detects.length) {
    if (rule.severity === 1) {
      warnings += detects.length;
    }
    else if (rule.severity === 2) {
...</pre></li>
    </ul>






</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.sass-lint.one_declaration_per_line" id="apidoc.module.sass-lint.one_declaration_per_line">module sass-lint.one_declaration_per_line</a></h1>


    <h2>
        <a href="#apidoc.element.sass-lint.one_declaration_per_line.detect" id="apidoc.element.sass-lint.one_declaration_per_line.detect">
        function <span class="apidocSignatureSpan">sass-lint.one_declaration_per_line.</span>detect
        <span class="apidocSignatureSpan">(ast, parser)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">detect = function (ast, parser) {
  var result = [],
      lastLine = {};

  ast.traverseByType('declaration', function (declaration, i, parent) {

    if (declaration.start.line === lastLine.start || declaration.start.line === lastLine.end) {
      if (parent.type !== 'arguments') {
        result = helpers.addUnique(result, {
          'ruleId': parser.rule.name,
          'line': declaration.start.line,
          'column': declaration.start.column,
          'message': 'Only one declaration allowed per line',
          'severity': parser.severity
        });
      }
    }

    lastLine.start = declaration.start.line;
    lastLine.end = declaration.end.line;
  });

  return result;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  }

  if (ast.content &amp;&amp; ast.content.length &gt; 0) {
ruleToggles = getToggledRules(ast);
isEnabledFilter = isResultEnabled(ruleToggles);

rules.forEach(function (rule) {
  detects = rule.rule.<span class="apidocCodeKeywordSpan">detect</span>(ast, rule)
    .filter(isEnabledFilter);
  results = results.concat(detects);
  if (detects.length) {
    if (rule.severity === 1) {
      warnings += detects.length;
    }
    else if (rule.severity === 2) {
...</pre></li>
    </ul>






</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.sass-lint.placeholder_in_extend" id="apidoc.module.sass-lint.placeholder_in_extend">module sass-lint.placeholder_in_extend</a></h1>


    <h2>
        <a href="#apidoc.element.sass-lint.placeholder_in_extend.detect" id="apidoc.element.sass-lint.placeholder_in_extend.detect">
        function <span class="apidocSignatureSpan">sass-lint.placeholder_in_extend.</span>detect
        <span class="apidocSignatureSpan">(ast, parser)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">detect = function (ast, parser) {
  var result = [];

  ast.traverseByType('atkeyword', function (keyword, i, parent) {
    keyword.forEach(function (item) {
      if (item.content === 'extend') {

        parent.forEach('selector', function (selector) {
          var placeholder = false;

          selector.content.forEach(function (selectorPiece) {
            if (selectorPiece.type === 'placeholder') {
              placeholder = true;
            }
          });

          if (!placeholder) {
            result = helpers.addUnique(result, {
              'ruleId': parser.rule.name,
              'line': selector.start.line,
              'column': selector.start.column,
              'message': '@extend must be used with a %placeholder',
              'severity': parser.severity
            });
          }
        });
      }
    });
  });

  return result;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  }

  if (ast.content &amp;&amp; ast.content.length &gt; 0) {
ruleToggles = getToggledRules(ast);
isEnabledFilter = isResultEnabled(ruleToggles);

rules.forEach(function (rule) {
  detects = rule.rule.<span class="apidocCodeKeywordSpan">detect</span>(ast, rule)
    .filter(isEnabledFilter);
  results = results.concat(detects);
  if (detects.length) {
    if (rule.severity === 1) {
      warnings += detects.length;
    }
    else if (rule.severity === 2) {
...</pre></li>
    </ul>






</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.sass-lint.placeholder_name_format" id="apidoc.module.sass-lint.placeholder_name_format">module sass-lint.placeholder_name_format</a></h1>


    <h2>
        <a href="#apidoc.element.sass-lint.placeholder_name_format.detect" id="apidoc.element.sass-lint.placeholder_name_format.detect">
        function <span class="apidocSignatureSpan">sass-lint.placeholder_name_format.</span>detect
        <span class="apidocSignatureSpan">(ast, parser)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">detect = function (ast, parser) {
  var result = [];

  ast.traverseByType('placeholder', function (node) {
    var name = node.first().content,
        strippedName,
        violationMessage = false;

    if (node.first().is('ident')) {
      strippedName = name;
      if (parser.options['allow-leading-underscore'] &amp;&amp; name[0] === '_') {
        strippedName = name.slice(1);
      }

      switch (parser.options.convention) {
      case 'hyphenatedlowercase':
        if (!helpers.isHyphenatedLowercase(strippedName)) {
          violationMessage = 'Placeholder \'%' + name + '\' should be written in lowercase with hyphens';
        }
        break;
      case 'camelcase':
        if (!helpers.isCamelCase(strippedName)) {
          violationMessage = 'Placeholder \'%' + name + '\' should be written in camelCase';
        }
        break;
      case 'pascalcase':
        if (!helpers.isPascalCase(strippedName)) {
          violationMessage = 'Placeholder \'%' + name + '\' should be written in PascalCase';
        }
        break;
      case 'snakecase':
        if (!helpers.isSnakeCase(strippedName)) {
          violationMessage = 'Placeholder \'%' + name + '\' should be written in snake_case';
        }
        break;
      case 'strictbem':
        if (!helpers.isStrictBEM(strippedName)) {
          violationMessage = 'Placeholder \'%' + name + '\' should be written in BEM (Block Element Modifier) format';
        }
        break;
      case 'hyphenatedbem':
        if (!helpers.isHyphenatedBEM(strippedName)) {
          violationMessage = 'Placeholder \'%' + name + '\' should be written in hyphenated BEM (Block Element Modifier) format';
        }
        break;
      default:
        if (!(new RegExp(parser.options.convention).test(strippedName))) {
          violationMessage = 'Placeholder \'%' + name + '\' should match regular expression /' + parser.options.convention + '/';

          // convention-message overrides violationMessage
          if (parser.options['convention-explanation']) {
            violationMessage = parser.options['convention-explanation'];
          }
        }
      }

      if (violationMessage) {
        result = helpers.addUnique(result, {
          'ruleId': parser.rule.name,
          'line': node.start.line,
          'column': node.start.column,
          'message': violationMessage,
          'severity': parser.severity
        });
      }
    }
  });
  return result;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  }

  if (ast.content &amp;&amp; ast.content.length &gt; 0) {
ruleToggles = getToggledRules(ast);
isEnabledFilter = isResultEnabled(ruleToggles);

rules.forEach(function (rule) {
  detects = rule.rule.<span class="apidocCodeKeywordSpan">detect</span>(ast, rule)
    .filter(isEnabledFilter);
  results = results.concat(detects);
  if (detects.length) {
    if (rule.severity === 1) {
      warnings += detects.length;
    }
    else if (rule.severity === 2) {
...</pre></li>
    </ul>






</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.sass-lint.property_sort_order" id="apidoc.module.sass-lint.property_sort_order">module sass-lint.property_sort_order</a></h1>


    <h2>
        <a href="#apidoc.element.sass-lint.property_sort_order.detect" id="apidoc.element.sass-lint.property_sort_order.detect">
        function <span class="apidocSignatureSpan">sass-lint.property_sort_order.</span>detect
        <span class="apidocSignatureSpan">(ast, parser)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">detect = function (ast, parser) {
  var result = [],
      order = getOrderConfig(parser.options.order) || parser.options.order;

  ast.traverseByType('block', function (block) {
    var properties = {},
        sorted,
        pKeys,
        sKeys;

    if (block) {
      block.forEach('declaration', function (dec) {
        var prop = dec.first('property'),
            name = prop.first('ident');

        if (name) {
          if (parser.options['ignore-custom-properties']) {
            if (propertyCheckList.indexOf(name.content) !== -1) {
              properties[name.content] = prop;
            }
          }
          else {
            properties[name.content] = prop;
          }
        }
      });

      sorted = sortProperties(properties, order);

      pKeys = Object.keys(properties);
      sKeys = Object.keys(sorted);

      sKeys.every(function (e, i) {
        var pKey = pKeys[i],
            prop = properties[pKey];

        if (e !== pKey) {
          result = helpers.addUnique(result, {
            'ruleId': parser.rule.name,
            'line': prop.start.line,
            'column': prop.start.column,
            'message': 'Expected `' + e + '`, found `' + pKey + '`',
            'severity': parser.severity
          });
        }
        return true;
      });
    }
  });

  return result;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  }

  if (ast.content &amp;&amp; ast.content.length &gt; 0) {
ruleToggles = getToggledRules(ast);
isEnabledFilter = isResultEnabled(ruleToggles);

rules.forEach(function (rule) {
  detects = rule.rule.<span class="apidocCodeKeywordSpan">detect</span>(ast, rule)
    .filter(isEnabledFilter);
  results = results.concat(detects);
  if (detects.length) {
    if (rule.severity === 1) {
      warnings += detects.length;
    }
    else if (rule.severity === 2) {
...</pre></li>
    </ul>






</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.sass-lint.property_units" id="apidoc.module.sass-lint.property_units">module sass-lint.property_units</a></h1>


    <h2>
        <a href="#apidoc.element.sass-lint.property_units.detect" id="apidoc.element.sass-lint.property_units.detect">
        function <span class="apidocSignatureSpan">sass-lint.property_units.</span>detect
        <span class="apidocSignatureSpan">(ast, parser)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">detect = function (ast, parser) {
  var result = [],
      unitsAllowedGlobally = parser.options.global,
      unitsAllowedPerProperty = parser.options['per-property'];

  ast.traverseByType('declaration', function (declaration) {
    var property = declaration.first('property'),
        ident = property ? property.first('ident') : null,
        propertyName = ident ? ident.content : null,
        valueNode = declaration.first('value'),
        hasDimension = valueNode ? !!valueNode.first('dimension') : null;
    if (propertyName &amp;&amp; hasDimension) {
      // properties such as box-shadow may have multiple dimensions defined so enumerate through them
      valueNode.forEach('dimension', function (dimension) {
        var dimensionIdent = dimension ? dimension.first('ident') : null,
            unitType = dimensionIdent ? dimensionIdent.content : null,
            unitsAllowed = unitsAllowedPerProperty[propertyName];
        // If a property is defined in unitsAllowed, then it will only validate those unit types
        if (unitType &amp;&amp; unitsAllowed) {
          if (unitsAllowed.indexOf(unitType) === -1) {
            result = helpers.addUnique(result, {
              'ruleId': parser.rule.name,
              'severity': parser.severity,
              'line': dimension.start.line,
              'column': dimension.start.column,
              'message': 'Values for property \'' + propertyName + '\' may not use ' + unitType + ' units'
            });
          }
        }
        // If no units are defined in unitsAllowedGlobally, then allow all of them
        // Otherwise, verify the given unit is in the unitsAllowedGlobally list.
        else if (unitType &amp;&amp; unitsAllowedGlobally.length &amp;&amp; unitsAllowedGlobally.indexOf(unitType) === -1) {
          result = helpers.addUnique(result, {
            'ruleId': parser.rule.name,
            'severity': parser.severity,
            'line': dimension.start.line,
            'column': dimension.start.column,
            'message': 'Values for property \'' + propertyName + '\' may not use ' + unitType + ' units'
          });
        }
      });
    }
  });
  return result;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  }

  if (ast.content &amp;&amp; ast.content.length &gt; 0) {
ruleToggles = getToggledRules(ast);
isEnabledFilter = isResultEnabled(ruleToggles);

rules.forEach(function (rule) {
  detects = rule.rule.<span class="apidocCodeKeywordSpan">detect</span>(ast, rule)
    .filter(isEnabledFilter);
  results = results.concat(detects);
  if (detects.length) {
    if (rule.severity === 1) {
      warnings += detects.length;
    }
    else if (rule.severity === 2) {
...</pre></li>
    </ul>






</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.sass-lint.pseudo_element" id="apidoc.module.sass-lint.pseudo_element">module sass-lint.pseudo_element</a></h1>


    <h2>
        <a href="#apidoc.element.sass-lint.pseudo_element.detect" id="apidoc.element.sass-lint.pseudo_element.detect">
        function <span class="apidocSignatureSpan">sass-lint.pseudo_element.</span>detect
        <span class="apidocSignatureSpan">(ast, parser)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">detect = function (ast, parser) {
  var result = [];

  ast.traverseByType('pseudoClass', function (node) {
    if (isPseudoElement(node.content[0].content)) {
      result = helpers.addUnique(result, {
        'ruleId': parser.rule.name,
        'line': node.start.line,
        'column': node.start.column,
        'message': 'Pseudo-elements must start with double colons',
        'severity': parser.severity
      });
    }
  });

  ast.traverseByType('pseudoElement', function (node) {
    if (isPseudoClass(node.content[0].content)) {
      result = helpers.addUnique(result, {
        'ruleId': parser.rule.name,
        'line': node.start.line,
        'column': node.start.column,
        'message': 'Pseudo-classes must start with a single colon',
        'severity': parser.severity
      });
    }
  });

  return result;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  }

  if (ast.content &amp;&amp; ast.content.length &gt; 0) {
ruleToggles = getToggledRules(ast);
isEnabledFilter = isResultEnabled(ruleToggles);

rules.forEach(function (rule) {
  detects = rule.rule.<span class="apidocCodeKeywordSpan">detect</span>(ast, rule)
    .filter(isEnabledFilter);
  results = results.concat(detects);
  if (detects.length) {
    if (rule.severity === 1) {
      warnings += detects.length;
    }
    else if (rule.severity === 2) {
...</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.sass-lint.quotes" id="apidoc.module.sass-lint.quotes">module sass-lint.quotes</a></h1>


    <h2>
        <a href="#apidoc.element.sass-lint.quotes.detect" id="apidoc.element.sass-lint.quotes.detect">
        function <span class="apidocSignatureSpan">sass-lint.quotes.</span>detect
        <span class="apidocSignatureSpan">(ast, parser)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">detect = function (ast, parser) {
  var result = [];

  ast.traverseByType('string', function (node) {
    var firstQuote = node.content.charAt(0),
        lastQuote = node.content.charAt(node.content.length - 1);

    if (firstQuote !== lastQuote) {
      result = helpers.addUnique(result, {
        'ruleId': parser.rule.name,
        'line': node.start.line,
        'column': node.start.column,
        'message': 'Mixed quote styles',
        'severity': parser.severity
      });
    }

    if (parser.options.style === 'single' &amp;&amp; firstQuote !== '\'') {
      result = helpers.addUnique(result, {
        'ruleId': parser.rule.name,
        'line': node.start.line,
        'column': node.start.column,
        'message': 'Strings must use single quotes',
        'severity': parser.severity
      });
    }
    else if (parser.options.style === 'double' &amp;&amp; firstQuote !== '"') {
      result = helpers.addUnique(result, {
        'ruleId': parser.rule.name,
        'line': node.start.line,
        'column': node.start.column,
        'message': 'Strings must use double quotes',
        'severity': parser.severity
      });
    }
  });

  return result;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  }

  if (ast.content &amp;&amp; ast.content.length &gt; 0) {
ruleToggles = getToggledRules(ast);
isEnabledFilter = isResultEnabled(ruleToggles);

rules.forEach(function (rule) {
  detects = rule.rule.<span class="apidocCodeKeywordSpan">detect</span>(ast, rule)
    .filter(isEnabledFilter);
  results = results.concat(detects);
  if (detects.length) {
    if (rule.severity === 1) {
      warnings += detects.length;
    }
    else if (rule.severity === 2) {
...</pre></li>
    </ul>






</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.sass-lint.ruleToggler" id="apidoc.module.sass-lint.ruleToggler">module sass-lint.ruleToggler</a></h1>


    <h2>
        <a href="#apidoc.element.sass-lint.ruleToggler.getToggledRules" id="apidoc.element.sass-lint.ruleToggler.getToggledRules">
        function <span class="apidocSignatureSpan">sass-lint.ruleToggler.</span>getToggledRules
        <span class="apidocSignatureSpan">(ast)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getToggledRules = function (ast) {
  var toggledRules = {
    ruleEnable: {
      // Format in here is [isEnabled, line, column]
    },
    globalEnable: []
  };
  if (!ast.traverseByTypes) {
    return toggledRules;
  }
  ast.traverseByTypes(['multilineComment', 'singlelineComment'], function (comment, i, parent) {
    var content = comment.content;
    if (!content) {
      return;
    }
    var tokens = content.split(/[\s,]+/)
      .filter(function (s) {
        return s.trim().length &gt; 0;
      });
    if (!tokens.length) {
      return;
    }
    var first = tokens[0],
        rules = tokens.slice(1);
    switch (first) {
    case 'sass-lint:disable':
      addDisable(toggledRules, rules, comment.start.line, comment.start.column);
      break;
    case 'sass-lint:enable':
      addEnable(toggledRules, rules, comment.start.line, comment.start.column);
      break;
    case 'sass-lint:disable-block':
      // future ref: not sure what the appropriate behavior is if there is no parent block; currently NPEs
      addDisableBlock(toggledRules, rules, parent);
      break;
    case 'sass-lint:disable-all':
      addDisableAll(toggledRules, comment.start.line, comment.start.column);
      break;
    case 'sass-lint:enable-all':
      addEnableAll(toggledRules, comment.start.line, comment.start.column);
      break;
    case 'sass-lint:disable-line':
      addDisableLine(toggledRules, rules, comment.start.line);
      break;
    default:
      return;
    }
  });
  // Sort these toggle stacks so reading them is easier (algorithmically).
  // Usually already sorted but since it's not guaranteed by the contract with gonzales-pe, ensuring it is.
  toggledRules.globalEnable.sort(sortRange);
  Object.keys(toggledRules.ruleEnable).map(function (ruleId) {
    toggledRules.ruleEnable[ruleId].sort(sortRange);
  });
  return toggledRules;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.sass-lint.ruleToggler.isResultEnabled" id="apidoc.element.sass-lint.ruleToggler.isResultEnabled">
        function <span class="apidocSignatureSpan">sass-lint.ruleToggler.</span>isResultEnabled
        <span class="apidocSignatureSpan">(toggledRules)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isResultEnabled = function (toggledRules) {
  return function (ruleResult) {
    var ruleId = ruleResult.ruleId;
    // Convention: if no column or line, assume rule is targetting 1.
    var line = ruleResult.line || 1;
    var column = ruleResult.column || 1;
    var isGloballyEnabled = toggledRules.globalEnable
      .reduce(function (acc, toggleRange) {
        return isBeforeOrSame(line, column, toggleRange[1], toggleRange[2])
          ? acc
          : toggleRange[0];
      }, true);
    if (!isGloballyEnabled) {
      return false;
    }
    if (!toggledRules.ruleEnable[ruleId]) {
      return true;
    }
    var isRuleEnabled = toggledRules.ruleEnable[ruleId]
      .reduce(function (acc, toggleRange) {
        return isBeforeOrSame(line, column, toggleRange[1], toggleRange[2])
          ? acc
          : toggleRange[0];
      }, true);
    if (!isRuleEnabled) {
      return false;
    }
    return true;
  };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.sass-lint.selector_helpers" id="apidoc.module.sass-lint.selector_helpers">module sass-lint.selector_helpers</a></h1>


    <h2>
        <a href="#apidoc.element.sass-lint.selector_helpers.constructSelector" id="apidoc.element.sass-lint.selector_helpers.constructSelector">
        function <span class="apidocSignatureSpan">sass-lint.selector_helpers.</span>constructSelector
        <span class="apidocSignatureSpan">(val)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">constructSelector = function (val) {
  var content = null;

  if (val.is('arguments')) {
    content = constructSubSelector(val, '(', ')', constructSelector);
  }

  else if (val.is('atkeyword')) {
    content = constructSubSelector(val, '@', '', constructSelector);
  }

  else if (val.is('attributeSelector')) {
    content = constructSubSelector(val, '[', ']', constructSelector);
  }

  else if (val.is('class')) {
    content = addGrammar(val, '.', '');
  }

  else if (val.is('id')) {
    content = addGrammar(val, '#', '');
  }

  else if (val.is('interpolation')) {
    content = constructSubSelector(val, '#{', '}', constructSelector);
  }

  else if (val.is('nth')) {
    content = addGrammar(val, '(', ')');
  }

  else if (val.is('nthSelector')) {
    content = constructSubSelector(val, ':', '', constructSelector);
  }

  else if (val.is('parentheses')) {
    content = constructSubSelector(val, '(', ')', constructSelector);
  }

  else if (val.is('placeholder')) {
    content = constructSubSelector(val, '%', '', constructSelector);
  }

  else if (val.is('pseudoClass')) {
    content = constructSubSelector(val, ':', '', constructSelector);
  }

  else if (val.is('pseudoElement')) {
    content = addGrammar(val, '::', '');
  }

  else if (val.is('space')) {
    content = ' ';
  }

  else if (val.is('variable')) {
    content = constructSubSelector(val, '$', '', constructSelector);
  }

  else if (simpleIdents.indexOf(val.type) !== -1) {
    content = val.content;
  }

  else if (subSelectors.indexOf(val.type) !== -1) {
    content = constructSubSelector(val, '', '', constructSelector);
  }

  return content;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    ast.traverseByTypes(['ruleset', 'placeholder'], function (node) {
var name,
    depth,
    selectorAndExtensions,
    maxDepth = parser.options['max-depth'];

if (node.is('placeholder')) {
  name = selectorHelpers.<span class="apidocCodeKeywordSpan">constructSelector</span>(node);
  if (name) {
    depth = bemDepth(name);
    if (depth &gt; maxDepth) {
      result = helpers.addUnique(result, {
        'ruleId': parser.rule.name,
        'line': node.start.line,
        'column': node.start.column,
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.sass-lint.shorthand_values" id="apidoc.module.sass-lint.shorthand_values">module sass-lint.shorthand_values</a></h1>


    <h2>
        <a href="#apidoc.element.sass-lint.shorthand_values.detect" id="apidoc.element.sass-lint.shorthand_values.detect">
        function <span class="apidocSignatureSpan">sass-lint.shorthand_values.</span>detect
        <span class="apidocSignatureSpan">(ast, parser)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">detect = function (ast, parser) {
  var result = [];

  ast.traverseByType('declaration', function (declaration) {
    var isShorthandProperty = false,
        property;

    declaration.traverse(function (item) {

      if (item.is('property')) {
        item.traverse(function (child) {
          // check if the property is a possible shorthand property
          if (shortVals.indexOf(child.content) !== -1) {
            isShorthandProperty = true;

            // store a reference to the property for our error
            property = shortVals[shortVals.indexOf(child.content)];
          }
        });
      }

      if (isShorthandProperty) {
        var value = [];

        if (item.is('value')) {
          var node = item.content;

          // Build each value into an array of strings with value and type
          value = scanValue(node);

          if (value.length &lt;= 4 &amp;&amp; value.length &gt;= 1) {
            var output = [];

            // check which values can condense
            if (condenseToOne(value, parser.options['allowed-shorthands'])) {
              output = [value[0]];
            }
            else if (condenseToTwo(value, parser.options['allowed-shorthands'])) {
              output = [value[0], value[1]];
            }
            else if (condenseToThree(value, parser.options['allowed-shorthands'])) {
              output = [value[0], value[1], value[2]];
            }

            if (output.length) {
              result = helpers.addUnique(result, {
                'ruleId': parser.rule.name,
                'line': item.start.line,
                'column': item.start.column,
                'message': 'Property `' + property + '` should be written more concisely as `' + output.join(' ') + '` instead of
 `' + value.join(' ') + '`',
                'severity': parser.severity
              });
            }
          }
        }
      }
    });
  });
  return result;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  }

  if (ast.content &amp;&amp; ast.content.length &gt; 0) {
ruleToggles = getToggledRules(ast);
isEnabledFilter = isResultEnabled(ruleToggles);

rules.forEach(function (rule) {
  detects = rule.rule.<span class="apidocCodeKeywordSpan">detect</span>(ast, rule)
    .filter(isEnabledFilter);
  results = results.concat(detects);
  if (detects.length) {
    if (rule.severity === 1) {
      warnings += detects.length;
    }
    else if (rule.severity === 2) {
...</pre></li>
    </ul>






</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.sass-lint.single_line_per_selector" id="apidoc.module.sass-lint.single_line_per_selector">module sass-lint.single_line_per_selector</a></h1>


    <h2>
        <a href="#apidoc.element.sass-lint.single_line_per_selector.detect" id="apidoc.element.sass-lint.single_line_per_selector.detect">
        function <span class="apidocSignatureSpan">sass-lint.single_line_per_selector.</span>detect
        <span class="apidocSignatureSpan">(ast, parser)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">detect = function (ast, parser) {
  var result = [];

  ast.traverseByType('ruleset', function (ruleset) {
    ruleset.forEach('delimiter', function (delimiter, j) {
      var next = checkLineForSelector(ruleset, j);

      if (next) {
        result = helpers.addUnique(result, {
          'ruleId': parser.rule.name,
          'line': next.start.line,
          'column': next.start.column,
          'message': 'Selectors must be placed on new lines',
          'severity': parser.severity
        });
      }
    });
  });

  return result;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  }

  if (ast.content &amp;&amp; ast.content.length &gt; 0) {
ruleToggles = getToggledRules(ast);
isEnabledFilter = isResultEnabled(ruleToggles);

rules.forEach(function (rule) {
  detects = rule.rule.<span class="apidocCodeKeywordSpan">detect</span>(ast, rule)
    .filter(isEnabledFilter);
  results = results.concat(detects);
  if (detects.length) {
    if (rule.severity === 1) {
      warnings += detects.length;
    }
    else if (rule.severity === 2) {
...</pre></li>
    </ul>






</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.sass-lint.space_after_bang" id="apidoc.module.sass-lint.space_after_bang">module sass-lint.space_after_bang</a></h1>


    <h2>
        <a href="#apidoc.element.sass-lint.space_after_bang.detect" id="apidoc.element.sass-lint.space_after_bang.detect">
        function <span class="apidocSignatureSpan">sass-lint.space_after_bang.</span>detect
        <span class="apidocSignatureSpan">(ast, parser)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">detect = function (ast, parser) {
  var result = [],
      regex = /!\s/;

  ast.traverseByTypes(['important', 'default', 'global', 'optional'], function (block) {
    if (block.content.match(regex) !== null) {
      if (parser.options.include) {
        result = helpers.addUnique(result, {
          'ruleId': parser.rule.name,
          'line': block.start.line,
          'column': block.start.column + 1,
          'message': 'Bangs (!) should be followed by a space',
          'severity': parser.severity
        });
      }
      else {
        result = helpers.addUnique(result, {
          'ruleId': parser.rule.name,
          'line': block.start.line,
          'column': block.start.column,
          'message': 'Bangs (!) should not be followed by a space',
          'severity': parser.severity
        });
      }
    }
  });

  return result;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  }

  if (ast.content &amp;&amp; ast.content.length &gt; 0) {
ruleToggles = getToggledRules(ast);
isEnabledFilter = isResultEnabled(ruleToggles);

rules.forEach(function (rule) {
  detects = rule.rule.<span class="apidocCodeKeywordSpan">detect</span>(ast, rule)
    .filter(isEnabledFilter);
  results = results.concat(detects);
  if (detects.length) {
    if (rule.severity === 1) {
      warnings += detects.length;
    }
    else if (rule.severity === 2) {
...</pre></li>
    </ul>






</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.sass-lint.space_after_colon" id="apidoc.module.sass-lint.space_after_colon">module sass-lint.space_after_colon</a></h1>


    <h2>
        <a href="#apidoc.element.sass-lint.space_after_colon.detect" id="apidoc.element.sass-lint.space_after_colon.detect">
        function <span class="apidocSignatureSpan">sass-lint.space_after_colon.</span>detect
        <span class="apidocSignatureSpan">(ast, parser)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">detect = function (ast, parser) {
  var result = [];

  ast.traverseByTypes(['propertyDelimiter', 'operator'], function (delimiter, i, parent) {
    if (delimiter.content === ':') {
      var next = parent.content[i + 1];

      if (next &amp;&amp; next.is('space')) {
        if (!parser.options.include) {
          result = helpers.addUnique(result, {
            'ruleId': parser.rule.name,
            'line': next.start.line,
            'column': next.start.column,
            'message': 'No space allowed after `:`',
            'severity': parser.severity
          });
        }
      }
      else {
        if (parser.options.include) {
          result = helpers.addUnique(result, {
            'ruleId': parser.rule.name,
            'line': delimiter.start.line,
            'column': delimiter.start.column,
            'message': 'Space expected after `:`',
            'severity': parser.severity
          });
        }
      }
    }
  });

  return result;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  }

  if (ast.content &amp;&amp; ast.content.length &gt; 0) {
ruleToggles = getToggledRules(ast);
isEnabledFilter = isResultEnabled(ruleToggles);

rules.forEach(function (rule) {
  detects = rule.rule.<span class="apidocCodeKeywordSpan">detect</span>(ast, rule)
    .filter(isEnabledFilter);
  results = results.concat(detects);
  if (detects.length) {
    if (rule.severity === 1) {
      warnings += detects.length;
    }
    else if (rule.severity === 2) {
...</pre></li>
    </ul>






</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.sass-lint.space_after_comma" id="apidoc.module.sass-lint.space_after_comma">module sass-lint.space_after_comma</a></h1>


    <h2>
        <a href="#apidoc.element.sass-lint.space_after_comma.detect" id="apidoc.element.sass-lint.space_after_comma.detect">
        function <span class="apidocSignatureSpan">sass-lint.space_after_comma.</span>detect
        <span class="apidocSignatureSpan">(ast, parser)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">detect = function (ast, parser) {
  var result = [];

  ast.traverseByTypes(['operator', 'delimiter'], function (operator, i, parent) {
    var next,
        doubleNext;

    if (operator.content === ',') {
      next = parent.content[i + 1] || false;
      doubleNext = parent.content[i + 2] || false;

      if (next) {
        if (operator.is('delimiter')) {
          if (next.is('selector')) {
            next = next.content[0];
          }
        }

        if ((next.is('space') &amp;&amp; !helpers.hasEOL(next.content)) &amp;&amp; !parser.options.include) {
          if (doubleNext &amp;&amp; doubleNext.is('singlelineComment')) {
            return false;
          }

          result = helpers.addUnique(result, {
            'ruleId': parser.rule.name,
            'line': next.start.line,
            'column': next.start.column,
            'message': 'Commas should not be followed by a space',
            'severity': parser.severity
          });
        }

        if (!next.is('space') &amp;&amp; parser.options.include) {
          result = helpers.addUnique(result, {
            'ruleId': parser.rule.name,
            'line': operator.start.line,
            'column': operator.start.column,
            'message': 'Commas should be followed by a space',
            'severity': parser.severity
          });
        }
      }
    }
    return true;
  });

  return result;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  }

  if (ast.content &amp;&amp; ast.content.length &gt; 0) {
ruleToggles = getToggledRules(ast);
isEnabledFilter = isResultEnabled(ruleToggles);

rules.forEach(function (rule) {
  detects = rule.rule.<span class="apidocCodeKeywordSpan">detect</span>(ast, rule)
    .filter(isEnabledFilter);
  results = results.concat(detects);
  if (detects.length) {
    if (rule.severity === 1) {
      warnings += detects.length;
    }
    else if (rule.severity === 2) {
...</pre></li>
    </ul>






</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.sass-lint.space_around_operator" id="apidoc.module.sass-lint.space_around_operator">module sass-lint.space_around_operator</a></h1>


    <h2>
        <a href="#apidoc.element.sass-lint.space_around_operator.detect" id="apidoc.element.sass-lint.space_around_operator.detect">
        function <span class="apidocSignatureSpan">sass-lint.space_around_operator.</span>detect
        <span class="apidocSignatureSpan">(ast, parser)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">detect = function (ast, parser) {
  var result = [];

  ast.traverseByTypes(['condition', 'atrule', 'value'], function (node) {
    node.forEach(function (item, i, parent) {
      // Perform another loop of the children if we come across a parenthesis
      // parent node
      if (item.is('parentheses')) {
        item.forEach(function (child, j, childParent) {
          // Do the spacing checks
          checkSpacing(child, j, childParent, parser, result);
        });
      }
      else {
        // Do the spacing checks
        checkSpacing(item, i, parent, parser, result);
      }
    });
  });

  return result;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  }

  if (ast.content &amp;&amp; ast.content.length &gt; 0) {
ruleToggles = getToggledRules(ast);
isEnabledFilter = isResultEnabled(ruleToggles);

rules.forEach(function (rule) {
  detects = rule.rule.<span class="apidocCodeKeywordSpan">detect</span>(ast, rule)
    .filter(isEnabledFilter);
  results = results.concat(detects);
  if (detects.length) {
    if (rule.severity === 1) {
      warnings += detects.length;
    }
    else if (rule.severity === 2) {
...</pre></li>
    </ul>






</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.sass-lint.space_before_bang" id="apidoc.module.sass-lint.space_before_bang">module sass-lint.space_before_bang</a></h1>


    <h2>
        <a href="#apidoc.element.sass-lint.space_before_bang.detect" id="apidoc.element.sass-lint.space_before_bang.detect">
        function <span class="apidocSignatureSpan">sass-lint.space_before_bang.</span>detect
        <span class="apidocSignatureSpan">(ast, parser)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">detect = function (ast, parser) {
  var result = [];

  ast.traverseByTypes(['important', 'default'], function (block, i, parent) {
    var previous = parent.content[i - 1];

    if (!previous.is('space')) {
      if (parser.options.include) {
        result = helpers.addUnique(result, {
          'ruleId': parser.rule.name,
          'line': block.start.line,
          'column': block.start.column,
          'message': 'Whitespace required before !important',
          'severity': parser.severity
        });
      }
    }
    else {
      if (!parser.options.include) {
        result = helpers.addUnique(result, {
          'ruleId': parser.rule.name,
          'line': previous.start.line,
          'column': previous.start.column,
          'message': 'Whitespace not allowed before !important',
          'severity': parser.severity
        });
      }
    }
  });

  return result;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  }

  if (ast.content &amp;&amp; ast.content.length &gt; 0) {
ruleToggles = getToggledRules(ast);
isEnabledFilter = isResultEnabled(ruleToggles);

rules.forEach(function (rule) {
  detects = rule.rule.<span class="apidocCodeKeywordSpan">detect</span>(ast, rule)
    .filter(isEnabledFilter);
  results = results.concat(detects);
  if (detects.length) {
    if (rule.severity === 1) {
      warnings += detects.length;
    }
    else if (rule.severity === 2) {
...</pre></li>
    </ul>






</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.sass-lint.space_before_brace" id="apidoc.module.sass-lint.space_before_brace">module sass-lint.space_before_brace</a></h1>


    <h2>
        <a href="#apidoc.element.sass-lint.space_before_brace.detect" id="apidoc.element.sass-lint.space_before_brace.detect">
        function <span class="apidocSignatureSpan">sass-lint.space_before_brace.</span>detect
        <span class="apidocSignatureSpan">(ast, parser)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">detect = function (ast, parser) {
  var result = [];
  if (ast.syntax === 'scss') {
    ast.traverseByTypes(['block', 'atrulers', 'declaration'], function (block, i, parent) {
      var previous = false,
          whitespace,
          warn = {};

      if ((block.is('block') || block.is('atrulers')) &amp;&amp; !parent.is('value')) {
        previous = parent.get(i - 1);
      }
      else if (block.is('declaration')) {
        if (block.contains('value')) {
          for (var j = 0; j &lt; block.content.length; j++) {
            if (block.content[j].is('value') &amp;&amp; block.content[j].content[0].is('block')) {
              previous = block.content[j - 1];
              warn.line = block.content[j].content[0].start.line;
              warn.col = block.content[j].content[0].start.column;
            }
          }
        }
      }
      whitespace = getLastWhitespace(previous);
      if (whitespace === false) {
        if (parser.options.include) {
          if (!warn.hasOwnProperty('line')) {
            warn.line = block.start.line;
            warn.col = block.start.column;
          }
          result = helpers.addUnique(result, {
            'ruleId': parser.rule.name,
            'line': warn.line,
            'column': warn.col - 1,
            'message': 'Whitespace required before {',
            'severity': parser.severity
          });
        }
      }
      else {
        if (!parser.options.include &amp;&amp; whitespace !== null) {
          result = helpers.addUnique(result, {
            'ruleId': parser.rule.name,
            'line': whitespace.start.line,
            'column': whitespace.start.column,
            'message': 'Whitespace not allowed before {',
            'severity': parser.severity
          });
        }
      }
    });
  }
  return result;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  }

  if (ast.content &amp;&amp; ast.content.length &gt; 0) {
ruleToggles = getToggledRules(ast);
isEnabledFilter = isResultEnabled(ruleToggles);

rules.forEach(function (rule) {
  detects = rule.rule.<span class="apidocCodeKeywordSpan">detect</span>(ast, rule)
    .filter(isEnabledFilter);
  results = results.concat(detects);
  if (detects.length) {
    if (rule.severity === 1) {
      warnings += detects.length;
    }
    else if (rule.severity === 2) {
...</pre></li>
    </ul>






</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.sass-lint.space_before_colon" id="apidoc.module.sass-lint.space_before_colon">module sass-lint.space_before_colon</a></h1>


    <h2>
        <a href="#apidoc.element.sass-lint.space_before_colon.detect" id="apidoc.element.sass-lint.space_before_colon.detect">
        function <span class="apidocSignatureSpan">sass-lint.space_before_colon.</span>detect
        <span class="apidocSignatureSpan">(ast, parser)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">detect = function (ast, parser) {
  var result = [];

  ast.traverseByTypes(['propertyDelimiter', 'operator'], function (delimiter, i, parent) {
    if (delimiter.content === ':') {
      var previous = parent.content[i - 1];

      if (previous &amp;&amp; previous.is('space')) {
        if (!parser.options.include) {
          result = helpers.addUnique(result, {
            'ruleId': parser.rule.name,
            'line': previous.start.line,
            'column': previous.start.column,
            'message': 'No space allowed before `:`',
            'severity': parser.severity
          });
        }
      }
      else {
        if (parser.options.include) {
          result = helpers.addUnique(result, {
            'ruleId': parser.rule.name,
            'line': delimiter.start.line,
            'column': delimiter.start.column - 1,
            'message': 'Space expected before `:`',
            'severity': parser.severity
          });
        }
      }
    }
  });

  return result;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  }

  if (ast.content &amp;&amp; ast.content.length &gt; 0) {
ruleToggles = getToggledRules(ast);
isEnabledFilter = isResultEnabled(ruleToggles);

rules.forEach(function (rule) {
  detects = rule.rule.<span class="apidocCodeKeywordSpan">detect</span>(ast, rule)
    .filter(isEnabledFilter);
  results = results.concat(detects);
  if (detects.length) {
    if (rule.severity === 1) {
      warnings += detects.length;
    }
    else if (rule.severity === 2) {
...</pre></li>
    </ul>






</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.sass-lint.space_between_parens" id="apidoc.module.sass-lint.space_between_parens">module sass-lint.space_between_parens</a></h1>


    <h2>
        <a href="#apidoc.element.sass-lint.space_between_parens.detect" id="apidoc.element.sass-lint.space_between_parens.detect">
        function <span class="apidocSignatureSpan">sass-lint.space_between_parens.</span>detect
        <span class="apidocSignatureSpan">(ast, parser)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">detect = function (ast, parser) {
  var result = [];

  ast.traverseByType('arguments', function (args) {
    var first = args.first(),
        last = args.last();

    if (args.length === 0) {
      return;
    }

    if (parser.options.include) {
      if (!first.is('space')) {
        result = helpers.addUnique(result, {
          'ruleId': parser.rule.name,
          'line': first.start.line,
          'column': first.start.column - 1,
          'message': 'Space expected at beginning of parenthesis',
          'severity': parser.severity
        });
      }
      if (!last.is('space')) {
        result = helpers.addUnique(result, {
          'ruleId': parser.rule.name,
          'line': last.end.line,
          'column': last.end.column,
          'message': 'Space expected at end of parenthesis',
          'severity': parser.severity
        });
      }
    }
    else {
      // Ignore if arguments are multi-line
      if (first.is('space') &amp;&amp; !helpers.hasEOL(first.content)) {
        result = helpers.addUnique(result, {
          'ruleId': parser.rule.name,
          'line': first.start.line,
          'column': first.start.column,
          'message': 'No space allowed at beginning of parenthesis',
          'severity': parser.severity
        });
      }
      if (last.is('space')) {
        // Proceed if arguments aren't multi-line.
        // With Sass we have one extra check for nested nodes where we must
        // check doublePrevious as the last node will be the indentation
        if (
          (ast.syntax === 'scss' &amp;&amp; !helpers.hasEOL(last.content))
          || (ast.syntax === 'sass' &amp;&amp; !helpers.hasEOL(last.content) &amp;&amp; !helpers.hasEOL(args.content[args.content.length - 2].content
))
        ) {
          result = helpers.addUnique(result, {
            'ruleId': parser.rule.name,
            'line': last.start.line,
            'column': last.start.column,
            'message': 'No space allowed at end of parenthesis',
            'severity': parser.severity
          });
        }
      }
    }
  });

  return result;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  }

  if (ast.content &amp;&amp; ast.content.length &gt; 0) {
ruleToggles = getToggledRules(ast);
isEnabledFilter = isResultEnabled(ruleToggles);

rules.forEach(function (rule) {
  detects = rule.rule.<span class="apidocCodeKeywordSpan">detect</span>(ast, rule)
    .filter(isEnabledFilter);
  results = results.concat(detects);
  if (detects.length) {
    if (rule.severity === 1) {
      warnings += detects.length;
    }
    else if (rule.severity === 2) {
...</pre></li>
    </ul>






</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.sass-lint.trailing_semicolon" id="apidoc.module.sass-lint.trailing_semicolon">module sass-lint.trailing_semicolon</a></h1>


    <h2>
        <a href="#apidoc.element.sass-lint.trailing_semicolon.detect" id="apidoc.element.sass-lint.trailing_semicolon.detect">
        function <span class="apidocSignatureSpan">sass-lint.trailing_semicolon.</span>detect
        <span class="apidocSignatureSpan">(ast, parser)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">detect = function (ast, parser) {
  var result = [];

  if (ast.syntax !== 'sass') {
    ast.traverseByType('block', function (block) {
      var last,
          next;

      try {
        last = block.last('declaration');
      }
      catch (e) {
        return;
      }

      block.forEach('declaration', function (item, i, parent) {
        if (item.contains('value')) {
          var valueNode = item.last('value').content[0];

          if (!valueNode.is('block')) {
            if (helpers.isEqual(last, item)) {
              if (parent.content[i + 1]) {
                next = parent.content[i + 1];

                if (next.is('declarationDelimiter')) {
                  if (!parser.options.include) {
                    result = helpers.addUnique(result, {
                      'ruleId': parser.rule.name,
                      'severity': parser.severity,
                      'line': item.end.line,
                      'column': item.end.column,
                      'message': 'No trailing semicolons allowed'
                    });
                  }
                }
                else {
                  if (parser.options.include) {
                    result = helpers.addUnique(result, {
                      'ruleId': parser.rule.name,
                      'severity': parser.severity,
                      'line': item.last('value').start.line,
                      'column': item.last('value').start.column,
                      'message': 'Trailing semicolons required'
                    });
                  }
                }
              }
            }
          }
        }
      });
    });
  }

  return result;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  }

  if (ast.content &amp;&amp; ast.content.length &gt; 0) {
ruleToggles = getToggledRules(ast);
isEnabledFilter = isResultEnabled(ruleToggles);

rules.forEach(function (rule) {
  detects = rule.rule.<span class="apidocCodeKeywordSpan">detect</span>(ast, rule)
    .filter(isEnabledFilter);
  results = results.concat(detects);
  if (detects.length) {
    if (rule.severity === 1) {
      warnings += detects.length;
    }
    else if (rule.severity === 2) {
...</pre></li>
    </ul>






</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.sass-lint.url_quotes" id="apidoc.module.sass-lint.url_quotes">module sass-lint.url_quotes</a></h1>


    <h2>
        <a href="#apidoc.element.sass-lint.url_quotes.detect" id="apidoc.element.sass-lint.url_quotes.detect">
        function <span class="apidocSignatureSpan">sass-lint.url_quotes.</span>detect
        <span class="apidocSignatureSpan">(ast, parser)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">detect = function (ast, parser) {
  var result = [];

  ast.traverseByType('uri', function (node) {
    node.traverse(function (item) {
      if (item.is('raw')) {
        if (!item.content.match(isVarRegex)) {
          result = helpers.addUnique(result, {
            'ruleId': parser.rule.name,
            'severity': parser.severity,
            'line': item.start.line,
            'column': item.start.column,
            'message': 'Quotes around URLs are required'
          });
        }
      }
    });
  });

  return result;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  }

  if (ast.content &amp;&amp; ast.content.length &gt; 0) {
ruleToggles = getToggledRules(ast);
isEnabledFilter = isResultEnabled(ruleToggles);

rules.forEach(function (rule) {
  detects = rule.rule.<span class="apidocCodeKeywordSpan">detect</span>(ast, rule)
    .filter(isEnabledFilter);
  results = results.concat(detects);
  if (detects.length) {
    if (rule.severity === 1) {
      warnings += detects.length;
    }
    else if (rule.severity === 2) {
...</pre></li>
    </ul>






</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.sass-lint.variable_for_property" id="apidoc.module.sass-lint.variable_for_property">module sass-lint.variable_for_property</a></h1>


    <h2>
        <a href="#apidoc.element.sass-lint.variable_for_property.detect" id="apidoc.element.sass-lint.variable_for_property.detect">
        function <span class="apidocSignatureSpan">sass-lint.variable_for_property.</span>detect
        <span class="apidocSignatureSpan">(ast, parser)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">detect = function (ast, parser) {
  var result = [];

  if (parser.options.properties.length) {
    ast.traverseByType('value', function (node, i, parent) {
      var declaration = parent.content[0].content[0],
          declarationType = declaration.type,
          declarationIdent = declaration.content;

      if (declarationType === 'ident') {
        if (parser.options.properties.indexOf(declarationIdent) !== -1) {
          node.forEach(function (valElem) {
            if (!isValidProperty(valElem) &amp;&amp; !isIgnoredType(valElem)) {
              result = helpers.addUnique(result, {
                'ruleId': parser.rule.name,
                'line': declaration.start.line,
                'column': declaration.start.column,
                'message': 'Values for properties of type \'' + declarationIdent + '\' may only be variables',
                'severity': parser.severity
              });
            }
          });
        }
      }
    });
  }
  return result;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  }

  if (ast.content &amp;&amp; ast.content.length &gt; 0) {
ruleToggles = getToggledRules(ast);
isEnabledFilter = isResultEnabled(ruleToggles);

rules.forEach(function (rule) {
  detects = rule.rule.<span class="apidocCodeKeywordSpan">detect</span>(ast, rule)
    .filter(isEnabledFilter);
  results = results.concat(detects);
  if (detects.length) {
    if (rule.severity === 1) {
      warnings += detects.length;
    }
    else if (rule.severity === 2) {
...</pre></li>
    </ul>






</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.sass-lint.variable_name_format" id="apidoc.module.sass-lint.variable_name_format">module sass-lint.variable_name_format</a></h1>


    <h2>
        <a href="#apidoc.element.sass-lint.variable_name_format.detect" id="apidoc.element.sass-lint.variable_name_format.detect">
        function <span class="apidocSignatureSpan">sass-lint.variable_name_format.</span>detect
        <span class="apidocSignatureSpan">(ast, parser)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">detect = function (ast, parser) {
  var result = [];

  ast.traverseByType('variable', function (variable) {
    var strippedName,
        violationMessage = false,
        name = variable.first().content;


    strippedName = name;

    if (parser.options['allow-leading-underscore'] &amp;&amp; name[0] === '_') {
      strippedName = strippedName.slice(1);
    }

    switch (parser.options.convention) {
    case 'hyphenatedlowercase':
      if (!helpers.isHyphenatedLowercase(strippedName)) {
        violationMessage = 'Variable \'' + name + '\' should be written in lowercase with hyphens';
      }
      break;
    case 'camelcase':
      if (!helpers.isCamelCase(strippedName)) {
        violationMessage = 'Variable \'' + name + '\' should be written in camelCase';
      }
      break;
    case 'pascalcase':
      if (!helpers.isPascalCase(strippedName)) {
        violationMessage = 'Variable \'' + name + '\' should be written in PascalCase';
      }
      break;
    case 'snakecase':
      if (!helpers.isSnakeCase(strippedName)) {
        violationMessage = 'Variable \'' + name + '\' should be written in snake_case';
      }
      break;
    case 'strictbem':
      if (!helpers.isStrictBEM(strippedName)) {
        violationMessage = 'Variable \'' + name + '\' should be written in BEM (Block Element Modifier) format';
      }
      break;
    case 'hyphenatedbem':
      if (!helpers.isHyphenatedBEM(strippedName)) {
        violationMessage = 'Variable \'' + name + '\' should be written in hyphenated BEM (Block Element Modifier) format';
      }
      break;
    default:
      if (!(new RegExp(parser.options.convention).test(strippedName))) {
        violationMessage = 'Variable \'' + name + '\' should match regular expression /' + parser.options.convention + '/';

        // convention-message overrides violationMessage
        if (parser.options['convention-explanation']) {
          violationMessage = parser.options['convention-explanation'];
        }
      }
    }

    if (violationMessage) {
      result = helpers.addUnique(result, {
        'ruleId': parser.rule.name,
        'line': variable.start.line,
        'column': variable.start.column,
        'message': violationMessage,
        'severity': parser.severity
      });
    }
  });

  return result;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  }

  if (ast.content &amp;&amp; ast.content.length &gt; 0) {
ruleToggles = getToggledRules(ast);
isEnabledFilter = isResultEnabled(ruleToggles);

rules.forEach(function (rule) {
  detects = rule.rule.<span class="apidocCodeKeywordSpan">detect</span>(ast, rule)
    .filter(isEnabledFilter);
  results = results.concat(detects);
  if (detects.length) {
    if (rule.severity === 1) {
      warnings += detects.length;
    }
    else if (rule.severity === 2) {
...</pre></li>
    </ul>






</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.sass-lint.zero_unit" id="apidoc.module.sass-lint.zero_unit">module sass-lint.zero_unit</a></h1>


    <h2>
        <a href="#apidoc.element.sass-lint.zero_unit.detect" id="apidoc.element.sass-lint.zero_unit.detect">
        function <span class="apidocSignatureSpan">sass-lint.zero_unit.</span>detect
        <span class="apidocSignatureSpan">(ast, parser)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">detect = function (ast, parser) {
  var result = [];

  ast.traverseByType('number', function (item, i, parent) {

    if (item.content === '0') {
      if (parent.type === 'dimension') {
        var next = parent.content[i + 1] || false;

        if (units.indexOf(next.content) !== -1) {
          if (!parser.options.include) {
            result = helpers.addUnique(result, {
              'ruleId': parser.rule.name,
              'severity': parser.severity,
              'line': item.end.line,
              'column': item.end.column,
              'message': 'No unit allowed for values of 0'
            });
          }
        }
      }
      else {
        if (parent.type === 'value') {
          if (parser.options.include) {
            result = helpers.addUnique(result, {
              'ruleId': parser.rule.name,
              'severity': parser.severity,
              'line': item.end.line,
              'column': item.end.column,
              'message': 'Unit required for values of 0'
            });
          }
        }
      }
    }
  });

  return result;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  }

  if (ast.content &amp;&amp; ast.content.length &gt; 0) {
ruleToggles = getToggledRules(ast);
isEnabledFilter = isResultEnabled(ruleToggles);

rules.forEach(function (rule) {
  detects = rule.rule.<span class="apidocCodeKeywordSpan">detect</span>(ast, rule)
    .filter(isEnabledFilter);
  results = results.concat(detects);
  if (detects.length) {
    if (rule.severity === 1) {
      warnings += detects.length;
    }
    else if (rule.severity === 2) {
...</pre></li>
    </ul>






</div>

<div class="apidocFooterDiv">
    [ this document was created with
    <a href="https://github.com/kaizhu256/node-utility2" target="_blank">utility2</a>
    ]
</div>
</div>
</body></html>